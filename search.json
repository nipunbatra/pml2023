[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "ES 654 Machine Learning",
    "section": "",
    "text": "Summary\n\nInstructor: Nipun Batra (nipun.batra@iitgn.ac.in)\nTeaching Assistants: Zeel B Patel, Shriraj Sawant, Shrutimoy, Sarth Dubey, Hitarth Gandhi, Saagar Parikh, Eshan Gujarathi, Gautam Vashishta, Aadesh Desai\nCourse Timings: Tuesday, Thursday 330-450 PM IST in 1/101\nSlack Invite\n\n\n\nPre-requisites:\n\nGood experience in Python programming\nProbability\nLinear Algebra\n\nCourse preparation: Students are encouraged to study some of the following to refresh their understanding of some of the prerequisities before the course formally begins.\n\nFirst four chapters of the Python Data Science handbook\nSome material on Linear Algebra\nKhan academy course on Stats and Probability\n\n\n\nReference textbooks:\n\nGareth James, Daniela Witten, Trevor Hastie and Robert Tibshirani. An Introduction to Statistical Learning with Applications in R\nChristopher Bishop. Pattern Recognition and Machine Learning. Springer, 2006.[Freely available online]\nFriedman J, Hastie T, Tibshirani R. The elements of statistical learning. New York, NY, USA:: Springer series in statistics; 2001.[Freely available online]\nDuda RO, Hart PE, Stork DG. Pattern classification. John Wiley & Sons; 2012 Nov 9.\nMitchell TM. Machine learning. 1997. Burr Ridge, IL: McGraw Hill. 1997;45(37):870-7.\nMurphy, K. Machine Learning: A Probabilistic Perspective. MIT Press\nGoodfellow I, Bengio Y, Courville A, Bengio Y. Deep learning. Cambridge: MIT press; 2016 Nov 18.[Freely available online]\n\n\n\nSome other ML courses\n\nNPTEL course by Balaram Ravindran\nCMU course by Tom Mitchell and Maria-Florina Balcan\nCoursera ML course by Andrew Ng\nFAST.ai course on ML\nPractical deep learning for coders by FAST.ai\nCourse by Alex Ihler, UCI"
  },
  {
    "objectID": "notebooks/posts/python-utils.html",
    "href": "notebooks/posts/python-utils.html",
    "title": "Some Python Utilities",
    "section": "",
    "text": "Function Argument Unpacking\nReference: https://www.youtube.com/watch?v=YWY4BZi_o28\n\ndef print_vec(x, y, z):\n    print(f\"[{x} \\n{y} \\n{z}]\")\n\n\nprint_vec(1, 2, 3)\n\n[1 \n2 \n3]\n\n\n\ntuple_vec = (1, 0, 1)\n#print_vec(tuple_vec)\nprint_vec(tuple_vec[0], tuple_vec[1], tuple_vec[2])\n\n[1 \n0 \n1]\n\n\n\nlist_vec = [1, 0, 1]\n\nprint_vec(tuple_vec[0], tuple_vec[1], tuple_vec[2])\nprint(\"*\"*20)\nprint_vec(*tuple_vec)\nprint(\"*\"*20)\n\nprint_vec(*list_vec)\n\n[1 \n0 \n1]\n********************\n[1 \n0 \n1]\n********************\n[1 \n0 \n1]\n\n\n\ndictionary_vec = {\"x\": 1, \"y\": 0, \"z\": 1}\nprint_vec(**dictionary_vec)\n\n[1 \n0 \n1]\n\n\n\ndictionary_vec = {\"a\": 1, \"b\": 0, \"c\":1}\nprint_vec(**dictionary_vec)\n\nTypeError: print_vec() got an unexpected keyword argument 'a'\n\n\n\nprint(*dictionary_vec)\n\na b c\n\n\n\n\nZip\n\nlist(zip([1, 2, 3], ['a', 'b', 'c'], [7, 8, 9]))\n\n[(1, 'a', 7), (2, 'b', 8), (3, 'c', 9)]\n\n\n\n\nItertools Product\n\nimport itertools\nlist(itertools.product([1, 2], ['a', 'b', 'c'], [7, 8, 9]))\n\n[(1, 'a', 7),\n (1, 'a', 8),\n (1, 'a', 9),\n (1, 'b', 7),\n (1, 'b', 8),\n (1, 'b', 9),\n (1, 'c', 7),\n (1, 'c', 8),\n (1, 'c', 9),\n (2, 'a', 7),\n (2, 'a', 8),\n (2, 'a', 9),\n (2, 'b', 7),\n (2, 'b', 8),\n (2, 'b', 9),\n (2, 'c', 7),\n (2, 'c', 8),\n (2, 'c', 9)]"
  },
  {
    "objectID": "notebooks/posts/logistic.html",
    "href": "notebooks/posts/logistic.html",
    "title": "Logistic Regression",
    "section": "",
    "text": "# Create linearly separable data in 2d\n\nimport numpy as np\nimport matplotlib.pyplot as plt\n%config InlineBackend.figure_format = 'retina'\nfrom sklearn.datasets import make_classification\n\nX, y = make_classification(n_samples=100, n_features=2, n_redundant=0, n_informative=2,\n                            n_clusters_per_class=2, class_sep=1.5, random_state=42)\n\nplt.scatter(X[:, 0], X[:, 1], marker='o', c=y, s=25, edgecolor='k')\n\n<matplotlib.collections.PathCollection at 0x12b5ed280>\n\n\n\n\n\n\nfrom sklearn.linear_model import LogisticRegression\n\n# Without regularization\nclf = LogisticRegression(random_state=0, penalty='none').fit(X, y)\nclf.coef_, clf.intercept_\n\n(array([[26.23339925, -5.01002931]]), array([1.74951957]))\n\n\n\n# Create a surface plot of the decision boundary for any theta_0, theta_1, theta_2\n\ndef plot_decision_boundary(theta_0, theta_1, theta_2):\n    x_lin = np.linspace(-4, 4, 100)\n    y_lin = -(theta_0 + theta_1 * x_lin) / theta_2\n    plt.plot(x_lin, y_lin, 'k--', label='Decision boundary ($\\sigma(z) = 0.5$))', lw=5)\n    plt.xlim(-4, 4)\n    plt.ylim(-4, 4)\n    plt.xlabel(r'$x_1$')\n    plt.ylabel(r'$x_2$')\n    plt.title(r'$\\theta_0 = {:.2f}, \\theta_1 = {:.2f}, \\theta_2 = {:.2f}$'.format(theta_0, theta_1, theta_2))\n\n    # Plot the probability of class 1 contour\n    x1, x2 = np.meshgrid(np.linspace(-4, 4, 100), np.linspace(-4, 4, 100))\n    z = 1 / (1 + np.exp(-(theta_0 + theta_1 * x1 + theta_2 * x2)))\n    plt.contourf(x1, x2, z, linestyles='dashed')\n    plt.colorbar()\n\n    # Plot the data\n    plt.scatter(X[:, 0], X[:, 1], marker='o', c=y, s=25, edgecolor='k')\n    plt.legend(loc='best')\n\n\n# Create a slider widget to explore the decision boundary\n\nfrom ipywidgets import interact, FloatSlider\n\ninteract(plot_decision_boundary,\n            theta_0=FloatSlider(min=-2, max=3, step=0.1, value=0.1),\n            theta_1=FloatSlider(min=-5, max=40, step=0.5, value=0.1),\n            theta_2=FloatSlider(min=-10, max=5, step=0.1, value=0.1))\n\n\n\n\n\n\n<function __main__.plot_decision_boundary(theta_0, theta_1, theta_2)>\n\n\n\n# Create a 3d plot of the decision boundary for any theta_0, theta_1, theta_2\n\nfrom mpl_toolkits.mplot3d import Axes3D\n\ndef plot_decision_boundary_3d(theta_0, theta_1, theta_2, azim=30, elev=30):\n    fig = plt.figure(figsize=(10, 8))\n    ax = fig.add_subplot(111, projection='3d')\n    x_lin = np.linspace(-4, 4, 100)\n    y_lin = np.linspace(-4, 4, 100)\n    X_g, Y_g = np.meshgrid(x_lin, y_lin)\n    Z_g = -(theta_0 + theta_1 * X_g + theta_2 * Y_g)\n    #ax.plot_surface(X_g, Y_g, Z_g, alpha=0.2)\n    ax.set_xlabel(r'$x_1$')\n    ax.set_ylabel(r'$x_2$')\n    ax.set_zlabel(r'$x_3$')\n    ax.set_title(r'$\\theta_0 = {:.2f}, \\theta_1 = {:.2f}, \\theta_2 = {:.2f}$'.format(theta_0, theta_1, theta_2))\n    \n    # Scatter plot of data (class 1 is Z = 1, class 0 is Z = 0)\n    ax.scatter(X[y == 1, 0], X[y == 1, 1], 1, marker='o', c='b', s=25, edgecolor='k')\n    ax.scatter(X[y == 0, 0], X[y == 0, 1], 0, marker='o', c='y', s=25, edgecolor='k')\n\n    # Plot the 3d sigmoid function\n    x1, x2 = np.meshgrid(np.linspace(-4, 4, 100), np.linspace(-4, 4, 100))\n    z = 1 / (1 + np.exp(-(theta_0 + theta_1 * x1 + theta_2 * x2)))\n    ax.plot_surface(x1, x2, z, alpha=0.2, color='green')\n    \n    # Rotate the plot so that the sigmoid function is visible\n    ax.view_init(azim, elev)\n\n    # Plot the decision plane\n    ax.plot_surface(X_g, Y_g, Z_g, alpha=0.2, color='k')\n\n\n\n# Create a slider widget to explore the decision boundary\n\nfrom ipywidgets import interact, FloatSlider\n\ninteract(plot_decision_boundary_3d,\n            theta_0=FloatSlider(min=-2, max=3, step=0.1, value=0.1),\n            theta_1=FloatSlider(min=-5, max=40, step=0.5, value=0.1),\n            theta_2=FloatSlider(min=-10, max=5, step=0.1, value=0.1),\n            azim=FloatSlider(min=-180, max=180, step=1, value=30),\n            elev=FloatSlider(min=-180, max=180, step=1, value=30))\n\n\n\n\n\n\n<function __main__.plot_decision_boundary_3d(theta_0, theta_1, theta_2, azim=30, elev=30)>\n\n\n\n# Create two 3d plot any theta_0, theta_1, theta_2\n# First showing the decision boundary\n# Second showing the probability of class 1\n\nfrom mpl_toolkits.mplot3d import Axes3D\n\ndef plot_decision_boundary_3d(theta_0, theta_1, theta_2, azim=30, elev=30):\n    fig = plt.figure(figsize=(10, 8))\n    ax1 = fig.add_subplot(121, projection='3d')\n    ax2 = fig.add_subplot(122, projection='3d')\n\n    x_lin = np.linspace(-4, 4, 100)\n    y_lin = np.linspace(-4, 4, 100)\n    X_g, Y_g = np.meshgrid(x_lin, y_lin)\n    Z_g = -(theta_0 + theta_1 * X_g + theta_2 * Y_g)\n    #ax.plot_surface(X_g, Y_g, Z_g, alpha=0.2)\n    ax1.set_xlabel(r'$x_1$')\n    ax1.set_ylabel(r'$x_2$')\n    ax1.set_zlabel(r'$x_3$')\n    ax1.set_title(r'$\\theta_0 = {:.2f}, \\theta_1 = {:.2f}, \\theta_2 = {:.2f}$'.format(theta_0, theta_1, theta_2))\n\n    # Scatter plot of data (class 1 is Z = 1, class 0 is Z = 0)\n    ax1.scatter(X[y == 1, 0], X[y == 1, 1], 1, marker='o', c='b', s=25, edgecolor='k')\n    ax1.scatter(X[y == 0, 0], X[y == 0, 1], 0, marker='o', c='y', s=25, edgecolor='k')\n\n    # Plot the 3d sigmoid function\n    x1, x2 = np.meshgrid(np.linspace(-4, 4, 100), np.linspace(-4, 4, 100))\n    z = 1 / (1 + np.exp(-(theta_0 + theta_1 * x1 + theta_2 * x2)))\n\n    # Plot the decision plane\n    ax1.plot_surface(X_g, Y_g, Z_g, alpha=0.2, color='k')\n\n    # Plot the probability of class 1\n    ax2.plot_surface(x1, x2, z, alpha=0.2, color='black')\n    ax2.scatter(X[y == 1, 0], X[y == 1, 1], 1, marker='o', c='b', s=25, edgecolor='k')\n    ax2.scatter(X[y == 0, 0], X[y == 0, 1], 0, marker='o', c='y', s=25, edgecolor='k')\n\n\n     # Rotate the plot so that the sigmoid function is visible\n    ax1.view_init(azim, elev)\n    ax2.view_init(azim, elev)\n\n\n# Create a slider widget to explore the decision boundary\n\nfrom ipywidgets import interact, FloatSlider\n\ninteract(plot_decision_boundary_3d,\n            theta_0=FloatSlider(min=-2, max=3, step=0.1, value=0.1),\n            theta_1=FloatSlider(min=-5, max=40, step=0.5, value=0.1),\n            theta_2=FloatSlider(min=-10, max=5, step=0.1, value=0.1),\n            azim=FloatSlider(min=-180, max=180, step=1, value=30),\n            elev=FloatSlider(min=-180, max=180, step=1, value=30))\n\n\n\n\n\n\n<function __main__.plot_decision_boundary_3d(theta_0, theta_1, theta_2, azim=30, elev=30)>"
  },
  {
    "objectID": "notebooks/posts/names.html",
    "href": "notebooks/posts/names.html",
    "title": "Generating names using MLPs",
    "section": "",
    "text": "import torch\nimport torch.nn.functional as F\nfrom torch import nn\nimport pandas as pd\nimport matplotlib.pyplot as plt # for making figures\n%matplotlib inline\n%config InlineBackend.figure_format = 'retina'\n\n\ntorch.__version__\n\n'2.0.0+cu118'\n\n\n\ndevice = torch.device(\"cuda\" if torch.cuda.is_available() else \"cpu\")\n\n\n# Get some names from https://github.com/MASTREX/List-of-Indian-Names\n\n\n!wget https://raw.githubusercontent.com/balasahebgulave/Dataset-Indian-Names/master/Indian_Names.csv -O names-long.csv\n\n--2023-03-31 17:00:55--  https://raw.githubusercontent.com/balasahebgulave/Dataset-Indian-Names/master/Indian_Names.csv\nResolving raw.githubusercontent.com (raw.githubusercontent.com)... 185.199.110.133, 185.199.109.133, 185.199.108.133, ...\nConnecting to raw.githubusercontent.com (raw.githubusercontent.com)|185.199.110.133|:443... connected.\nHTTP request sent, awaiting response... 200 OK\nLength: 85538 (84K) [text/plain]\nSaving to: ‘names-long.csv’\n\nnames-long.csv      100%[===================>]  83.53K  --.-KB/s    in 0.07s   \n\n2023-03-31 17:00:55 (1.12 MB/s) - ‘names-long.csv’ saved [85538/85538]\n\n\n\n\n!head names-long.csv\n\n,Name\n0,aabid\n1,aabida\n2,aachal\n3,aadesh\n4,aadil\n5,aadish\n6,aaditya\n7,aaenab\n8,aafreen\n\n\n\nwords = pd.read_csv('names-long.csv')[\"Name\"]\nwords = words.str.lower()\nwords = words.str.strip()\nwords = words.str.replace(\" \", \"\")\n\nwords = words[words.str.len() > 2]\nwords = words[words.str.len() < 10]\n\n# Randomly shuffle the words\nwords = words.sample(frac=1).reset_index(drop=True)\nwords = words.tolist()\n\n# Remove words having non alphabets\nwords = [word for word in words if word.isalpha()]\nwords[:10]\n\n['sehran',\n 'iema',\n 'bajinder',\n 'manoj',\n 'nayaka',\n 'ajmal',\n 'navleen',\n 'akhtari',\n 'samsung',\n 'imtyaz']\n\n\n\nlen(words)\n\n6184\n\n\n\n# build the vocabulary of characters and mappings to/from integers\nchars = sorted(list(set(''.join(words))))\nstoi = {s:i+1 for i,s in enumerate(chars)}\nstoi['.'] = 0\nitos = {i:s for s,i in stoi.items()}\nprint(itos)\n\n{1: 'a', 2: 'b', 3: 'c', 4: 'd', 5: 'e', 6: 'f', 7: 'g', 8: 'h', 9: 'i', 10: 'j', 11: 'k', 12: 'l', 13: 'm', 14: 'n', 15: 'o', 16: 'p', 17: 'q', 18: 'r', 19: 's', 20: 't', 21: 'u', 22: 'v', 23: 'w', 24: 'x', 25: 'y', 26: 'z', 0: '.'}\n\n\n\nblock_size = 4 # context length: how many characters do we take to predict the next one?\nX, Y = [], []\nfor w in words[:]:\n  \n  #print(w)\n  context = [0] * block_size\n  for ch in w + '.':\n    ix = stoi[ch]\n    X.append(context)\n    Y.append(ix)\n    #print(''.join(itos[i] for i in context), '--->', itos[ix])\n    context = context[1:] + [ix] # crop and append\n  \n# Move data to GPU\n\nX = torch.tensor(X).to(device)\nY = torch.tensor(Y).to(device)\n\n\nX.shape, X.dtype, Y.shape, Y.dtype\n\n(torch.Size([44325, 4]), torch.int64, torch.Size([44325]), torch.int64)\n\n\n\n# Embedding layer for the context\n\nemb_dim = 2\nemb = torch.nn.Embedding(len(stoi), emb_dim)\n\n\nemb.weight\n\nParameter containing:\ntensor([[-0.7321, -0.0133],\n        [ 0.9890, -0.3715],\n        [-1.2565, -0.3346],\n        [ 0.3989,  1.4209],\n        [-0.5718, -0.1615],\n        [ 0.4853,  2.2499],\n        [ 0.1107,  2.7214],\n        [-1.7009,  1.1288],\n        [-0.6636, -1.1188],\n        [-1.6768,  1.0876],\n        [ 0.1645,  0.0063],\n        [-1.0367, -0.9603],\n        [-3.0939,  1.9831],\n        [-0.8332,  0.8572],\n        [-1.4305, -0.6878],\n        [-0.5197, -0.9626],\n        [-2.3395,  0.6205],\n        [-0.7045,  0.2387],\n        [ 2.8074, -0.8545],\n        [-0.2396, -0.7623],\n        [-1.1135, -0.1288],\n        [-0.5464, -0.0345],\n        [-1.2686,  1.0719],\n        [-1.3973, -0.5510],\n        [ 0.9127,  1.2566],\n        [ 0.6278,  1.1915],\n        [ 0.0465,  1.2633]], requires_grad=True)\n\n\n\n# Function to visualize the embedding in 2d space\n\ndef plot_emb(emb, itos, ax=None):\n    if ax is None:\n        fig, ax = plt.subplots()\n    for i in range(len(itos)):\n        x, y = emb.weight[i].detach().cpu().numpy()\n        ax.scatter(x, y, color='k')\n        ax.text(x + 0.05, y + 0.05, itos[i])\n    return ax\n\nplot_emb(emb, itos)\n\n<AxesSubplot:>\n\n\n\n\n\n\nclass NextChar(nn.Module):\n  def __init__(self, block_size, vocab_size, emb_dim, hidden_size):\n    super().__init__()\n    self.emb = nn.Embedding(vocab_size, emb_dim)\n    self.lin1 = nn.Linear(block_size * emb_dim, hidden_size)\n    self.lin2 = nn.Linear(hidden_size, vocab_size)\n\n  def forward(self, x):\n    x = self.emb(x)\n    x = x.view(x.shape[0], -1)\n    x = F.relu(self.lin1(x))\n    x = self.lin2(x)\n    return x\n    \n\n\n# Generate names from untrained model\n\n\nmodel = NextChar(block_size, len(stoi), emb_dim, 50).to(device)\nmodel = torch.compile(model)\n\ng = torch.Generator()\ng.manual_seed(4000002)\ndef generate_name(model, itos, stoi, block_size, max_len=10):\n    context = [0] * block_size\n    name = ''\n    for i in range(max_len):\n        x = torch.tensor(context).view(1, -1).to(device)\n        y_pred = model(x)\n        ix = torch.distributions.categorical.Categorical(logits=y_pred).sample().item()\n        ch = itos[ix]\n        if ch == '.':\n            break\n        name += ch\n        context = context[1:] + [ix]\n    return name\n\nfor i in range(10):\n    print(generate_name(model, itos, stoi, block_size))\n\n/home/nipun.batra/miniforge3/lib/python3.9/site-packages/torch/_inductor/compile_fx.py:90: UserWarning: TensorFloat32 tensor cores for float32 matrix multiplication available but not enabled. Consider setting `torch.set_float32_matmul_precision('high')` for better performance.\n  warnings.warn(\n\n\nihjzyewjrp\npuijjpnwfk\ngcvvflic\neeokqgmlse\nyiaghsikiv\nsmmggfnsot\nptdmdlmwfi\nyitpyixshw\ngjqapafodl\ndfuhgoowtb\n\n\n\nfor param_name, param in model.named_parameters():\n    print(param_name, param.shape)\n\nemb.weight torch.Size([27, 2])\nlin1.weight torch.Size([50, 8])\nlin1.bias torch.Size([50])\nlin2.weight torch.Size([27, 50])\nlin2.bias torch.Size([27])\n\n\n\n# Train the model\n\nloss_fn = nn.CrossEntropyLoss()\nopt = torch.optim.AdamW(model.parameters(), lr=0.01)\nimport time\n# Mini-batch training\nbatch_size = 4096*32\nprint_every = 400\nelapsed_time = []\nfor epoch in range(10000):\n    start_time = time.time()\n    for i in range(0, X.shape[0], batch_size):\n        x = X[i:i+batch_size]\n        y = Y[i:i+batch_size]\n        y_pred = model(x)\n        loss = loss_fn(y_pred, y)\n        loss.backward()\n        opt.step()\n        opt.zero_grad()\n    end_time = time.time()\n    elapsed_time.append(end_time - start_time)\n    if epoch % print_every == 0:\n        print(epoch, loss.item())\n        print(\"Time taken for 1 epochs: {} seconds\".format(sum(elapsed_time)/print_every))\n\n0 2.0890238285064697\nTime taken for 1 epochs: 6.577968597412109e-06 seconds\n400 2.0890519618988037\nTime taken for 1 epochs: 0.0018871128559112549 seconds\n800 2.088754177093506\nTime taken for 1 epochs: 0.0037400954961776733 seconds\n1200 2.0887293815612793\nTime taken for 1 epochs: 0.005593389868736267 seconds\n1600 2.0884861946105957\nTime taken for 1 epochs: 0.007446771860122681 seconds\n2000 2.0891528129577637\nTime taken for 1 epochs: 0.009300289154052734 seconds\n2400 2.0879929065704346\nTime taken for 1 epochs: 0.011153245568275452 seconds\n2800 2.088449239730835\nTime taken for 1 epochs: 0.013006348609924317 seconds\n3200 2.0879693031311035\nTime taken for 1 epochs: 0.014860434532165527 seconds\n3600 2.0881006717681885\nTime taken for 1 epochs: 0.016712880134582518 seconds\n4000 2.087575912475586\nTime taken for 1 epochs: 0.01856597661972046 seconds\n4400 2.087235689163208\nTime taken for 1 epochs: 0.020418978929519653 seconds\n4800 2.087622880935669\nTime taken for 1 epochs: 0.02227234423160553 seconds\n5200 2.087576150894165\nTime taken for 1 epochs: 0.02412549138069153 seconds\n5600 2.0879015922546387\nTime taken for 1 epochs: 0.025978831052780153 seconds\n6000 2.088137626647949\nTime taken for 1 epochs: 0.027831865549087523 seconds\n6400 2.0875606536865234\nTime taken for 1 epochs: 0.029685078263282774 seconds\n6800 2.0870373249053955\nTime taken for 1 epochs: 0.031538299322128295 seconds\n7200 2.0867090225219727\nTime taken for 1 epochs: 0.033391504883766174 seconds\n7600 2.085026979446411\nTime taken for 1 epochs: 0.035245080590248105 seconds\n8000 2.0854732990264893\nTime taken for 1 epochs: 0.03710031807422638 seconds\n8400 2.0843679904937744\nTime taken for 1 epochs: 0.03895375490188599 seconds\n8800 2.084249258041382\nTime taken for 1 epochs: 0.04080682039260864 seconds\n9200 2.0851705074310303\nTime taken for 1 epochs: 0.042660011649131774 seconds\n9600 2.0844883918762207\nTime taken for 1 epochs: 0.044512977004051206 seconds\n\n\n\n# Visualize the embedding\n\nplot_emb(model.emb, itos)\n\n<AxesSubplot:>\n\n\n\n\n\n\n# Generate names from trained model\n\nfor i in range(10):\n    print(generate_name(model, itos, stoi, block_size))\n\nswina\nmiter\njakul\nposhaban\nnahmishsir\njaillanam\nfibwahir\ngurs\nsakinu\nramta\n\n\nTuning knobs\n\nEmbedding size\nMLP\nContext length"
  },
  {
    "objectID": "notebooks/posts/projection.html",
    "href": "notebooks/posts/projection.html",
    "title": "Linear Regression: Geometric Perspective",
    "section": "",
    "text": "import numpy as np\nimport matplotlib.pyplot as plt\n%matplotlib inline\n%config InlineBackend.figure_format = 'retina'\n\n\n# Two three-dimensional vectors\nv1 = np.array([1, 1, 1])\nv2 = np.array([2, -2, 2])\n\n# y-vector\ny = np.array([2.5, -0.8, 1.2])\n\n\n# plot the vectors in 3D\nfig = plt.figure(figsize=(8, 8))\nax = fig.add_subplot(111, projection='3d')\nax.quiver(0, 0, 0, v1[0], v1[1], v1[2], color='r', label='v1')\nax.quiver(0, 0, 0, v2[0], v2[1], v2[2], color='b', label='v2')\nax.quiver(0, 0, 0, y[0], y[1], y[2], color='g', label='y')\n\nax.set_xlim(0, 3)\nax.set_ylim(0, 4)\nax.set_zlim(0, 3)\nax.set_xlabel('x')\nax.set_ylabel('y')\nax.set_zlabel('z')\nax.legend()\n\nax.view_init(elev=45, azim=60)\n\n\n\n\n\ntheta = np.linalg.lstsq(np.array([v1, v2]).T, y, rcond=None)[0]\ntheta\n\narray([0.525 , 0.6625])\n\n\n\n# Projection of y onto the plane spanned by v1 and v2\ny_proj = np.dot(np.array([v1, v2]).T, theta)\ny_proj\n\narray([ 1.85, -0.8 ,  1.85])\n\n\n\n# Plot the x=z plane filled with color black\nfig, ax = plt.subplots(figsize=(8, 8))\n# 3d projection\nax = fig.add_subplot(111, projection='3d')\nxx, zz = np.meshgrid(np.linspace(-1, 4, 100), np.linspace(-1, 4, 100))\nyy = np.zeros_like(xx)\nax.plot_surface(xx, yy, zz, alpha=0.2, color='k')\n\n\n# plot the vectors in 3D\nax.quiver(0, 0, 0, v1[0], v1[1], v1[2], color='r', label='v1')\nax.quiver(0, 0, 0, v2[0], v2[1], v2[2], color='b', label='v2')\nax.quiver(0, 0, 0, y[0], y[1], y[2], color='g', label='y')\n\n\n# Limit the view to the x-z plane\n\nax.set_xlabel('x')\nax.set_ylabel('y')\nax.set_zlabel('z')\n\n# Set the view angle so that we can see the x-z plane appear at a 45 degree angle\n#ax.view_init(azim=70, elev=200)\nax.view_init(elev=60, azim=-80, roll=90)\nax.view_init(120, -120, -120)\n#ax.view_init(roll=45)\n#ax.view_init(elev=30, azim=45, roll=15)\nax.set_ylim(-4, 4)\nax.set_xlim(0, 4)\nax.set_zlim(0, 4)\n\n\n# Plot the projection of y onto the plane spanned by v1 and v2\nax.quiver(0, 0, 0, y_proj[0], y_proj[1], y_proj[2], color='k', label='Projection of y onto\\n the plane spanned by v1 and v2')\nplt.legend()\n\n<matplotlib.legend.Legend at 0x111d52730>"
  },
  {
    "objectID": "notebooks/posts/autodiff-helper.html",
    "href": "notebooks/posts/autodiff-helper.html",
    "title": "Autodiff",
    "section": "",
    "text": "import torch\nimport torch.nn as nn\nimport torch.nn.functional as F\nimport torch.optim as optim\n\nimport numpy as np\nimport matplotlib.pyplot as plt\n\nfrom torch.utils.data import DataLoader, TensorDataset\nimport seaborn as sns\n\n%matplotlib inline\n%config InlineBackend.figure_format = 'retina'\n\n# Set random seed for reproducibility\ntorch.manual_seed(0)\n\n# Torch version\ntorch.__version__\n\n'2.0.0+cu118'\n\n\n\ntheta_0 = torch.tensor(1.0, requires_grad=True)\ntheta_1 = torch.tensor(1.0, requires_grad=True)\ntheta_2 = torch.tensor(2.0, requires_grad=True)\n\nx1 = torch.tensor(1.0)\nx2 = torch.tensor(2.0)\n\nf1 = theta_1*x1\nf2 = theta_2*x2\n\nf3 = f1 + f2\n\nf4 = f3 + theta_0\n\nf5 = f4*-1\n\nf6 = torch.exp(f5)\n\nf7 = 1 + f6\n\nf8 = 1/f7\n\nf9 = torch.log(f8)\n\nL = f9*-1\n\nall_nodes = {\"theta_0\": theta_0, \"theta_1\": theta_1, \"theta_2\": theta_2,  \n             \"f1\": f1, \"f2\": f2, \"f3\": f3, \"f4\": f4, \"f5\": f5, \"f6\": f6, \"f7\": f7, \"f8\": f8, \"f9\": f9, \"L\": L}\n\n# Retain grad for all nodes\nfor node in all_nodes.values():\n    node.retain_grad()\n\n\n# Print out the function evaluation for all nodes along with name of the node\nfor name, node in all_nodes.items():\n    print(f\"{name}: {node.item()}\")\n\ntheta_0: 1.0\ntheta_1: 1.0\ntheta_2: 2.0\nf1: 1.0\nf2: 4.0\nf3: 5.0\nf4: 6.0\nf5: -6.0\nf6: 0.0024787522852420807\nf7: 1.0024787187576294\nf8: 0.9975274205207825\nf9: -0.0024756414350122213\nL: 0.0024756414350122213\n\n\n\nL.backward()\n\n# Print out the gradient for all nodes along with name of the node\nfor name, node in all_nodes.items():\n    print(f\"{name}: {node.grad.item()}\")\n\ntheta_0: -0.00247262348420918\ntheta_1: -0.00247262348420918\ntheta_2: -0.00494524696841836\nf1: -0.00247262348420918\nf2: -0.00247262348420918\nf3: -0.00247262348420918\nf4: -0.00247262348420918\nf5: 0.00247262348420918\nf6: 0.9975274801254272\nf7: 0.9975274801254272\nf8: -1.0024787187576294\nf9: -1.0\nL: 1.0\n\n\n\n(-1/(f7**2))*-1.00247\n\ntensor(0.9975, grad_fn=<MulBackward0>)\n\n\n\ntorch.exp(f5)*0.9975\n\ntensor(0.0025, grad_fn=<MulBackward0>)"
  },
  {
    "objectID": "notebooks/posts/curse-dimensionality.html",
    "href": "notebooks/posts/curse-dimensionality.html",
    "title": "Curse of Dimensionality",
    "section": "",
    "text": "import numpy as np\nimport matplotlib.pyplot as plt\nimport pandas as pd\n\n%matplotlib inline\n%config InlineBackend.figure_format = 'retina'\n\n\n# \nn = 10\nnp.random.seed(42)\n# Get `n` points in 1d space uniformly distributed from 0 to 1\nx = np.random.uniform(0, 1, n)\nplt.scatter(x, np.zeros(n), c='r', s=100)\n\n<matplotlib.collections.PathCollection at 0x7f55f7e71d60>\n\n\n\n\n\n\n# Pick a random test point\n\nx_test = np.random.uniform(0, 1, 1)\n\n\n# Mark the nearest point and farthest point\nx_nearest = x[np.argmin(np.abs(x - x_test))]\nx_farthest = x[np.argmax(np.abs(x - x_test))]\n\nplt.scatter(x, np.zeros(n), c='r', s=100)\nplt.scatter(x_test, 0, c='b', s=100, marker='*', label='test')\nplt.scatter(x_nearest, 0, c='g', s=100, label='nearest')\nplt.scatter(x_farthest, 0, c='y', s=100, label='farthest')\nplt.legend()\n\nratio = np.abs(x_test - x_nearest) / np.abs(x_test - x_farthest)\nprint('Ratio of distances: {}'.format(ratio))\n\nRatio of distances: [0.040316]\n\n\n\n\n\n\n# Do the above experiment for 1000 times\n\nn = 10\nnp.random.seed(42)\n\nn_exp = 1000\nratios = np.zeros(n_exp)\nfor i in range(n_exp):\n    x = np.random.uniform(0, 1, n)\n    x_test = np.random.uniform(0, 1, 1)\n    x_nearest = x[np.argmin(np.abs(x - x_test))]\n    x_farthest = x[np.argmax(np.abs(x - x_test))]\n    ratios[i] = np.abs(x_test - x_nearest) / np.abs(x_test - x_farthest)\n\n\nimport seaborn as sns\nsns.displot(ratios, kde=False, bins=20)\n\n<seaborn.axisgrid.FacetGrid at 0x7f55f5dc6a90>\n\n\n\n\n\n\n# Repeat the experiment in 2d\n\nn = 10\nnp.random.seed(42)\nx = np.random.uniform(0, 1, (n, 2))\nplt.scatter(x[:, 0], x[:, 1], c='r', s=100)\n\n<matplotlib.collections.PathCollection at 0x7f53d91c9a60>\n\n\n\n\n\n\n# Pick a random test point\n\nx_test = np.random.uniform(0, 1, 2)\n\n# Mark the nearest point and farthest point\nx_nearest = x[np.argmin(np.linalg.norm(x - x_test, axis=1))]\nx_farthest = x[np.argmax(np.linalg.norm(x - x_test, axis=1))]\n\nplt.scatter(x[:, 0], x[:, 1], c='r', s=100)\nplt.scatter(x_test[0], x_test[1], c='b', s=100, marker='*', label='test')\nplt.scatter(x_nearest[0], x_nearest[1], c='g', s=100, label='nearest')\nplt.scatter(x_farthest[0], x_farthest[1], c='y', s=100, label='farthest')\nplt.legend()\n\n<matplotlib.legend.Legend at 0x7f53d91456a0>\n\n\n\n\n\n\n# Find the ratio of distances between the nearest and farthest points in 1000 experiments\n\nn = 10\nnp.random.seed(42)\n\nratios_2d = np.zeros(n_exp)\nfor i in range(n_exp):\n    x = np.random.uniform(0, 1, (n, 2))\n    x_test = np.random.uniform(0, 1, 2)\n    x_nearest = x[np.argmin(np.linalg.norm(x - x_test, axis=1))]\n    x_farthest = x[np.argmax(np.linalg.norm(x - x_test, axis=1))]\n    ratios_2d[i] = np.linalg.norm(x_test - x_nearest) / np.linalg.norm(x_test - x_farthest)\n\n\nsns.displot(ratios_2d, kde=False, bins=20)\n\n<seaborn.axisgrid.FacetGrid at 0x7f53d9094970>\n\n\n\n\n\n\n# Now, let's do the same experiment in dimensions varying from 1 to 20\n\nn = 10\nnp.random.seed(42)\nn_dim = 40\nratios_nd = np.zeros((n_exp, n_dim))\nfor i in range(n_exp):\n    for d in range(1, n_dim + 1):\n        x = np.random.uniform(0, 1, (n, d))\n        x_test = np.random.uniform(0, 1, d)\n        x_nearest = x[np.argmin(np.linalg.norm(x - x_test, axis=1))]\n        x_farthest = x[np.argmax(np.linalg.norm(x - x_test, axis=1))]\n        ratios_nd[i, d - 1] = np.linalg.norm(x_test - x_nearest) / np.linalg.norm(x_test - x_farthest)\n\n\n# Plot the ratio of distances between the nearest and farthest points in 1000 experiments for each dimension\n\nplt.figure(figsize=(10, 6))\nplt.plot(np.arange(1, n_dim + 1), np.mean(ratios_nd, axis=0), 'o-')\nplt.xlabel('Dimension')\nplt.ylabel('Ratio of distances')\nplt.title('Ratio of distances between the nearest and farthest points in 1000 experiments for each dimension')\nplt.ylim(0, 1.)\n\n(0.0, 1.0)\n\n\n\n\n\n\n# Let us now see what happens if we have more points in higher dimensions\n# 1d space: 10 points\n\nn = 10\nnp.random.seed(42)\nn_dim = 4\nratios_nd_more_points = np.zeros((n_exp, n_dim))\nnum_points = [10, 50, 200, 2000]\nfor i in range(n_exp):\n    for d in range(1, n_dim + 1):\n        x = np.random.uniform(0, 1, (num_points[d-1], d))\n        x_test = np.random.uniform(0, 1, d)\n        x_nearest = x[np.argmin(np.linalg.norm(x - x_test, axis=1))]\n        x_farthest = x[np.argmax(np.linalg.norm(x - x_test, axis=1))]\n        ratios_nd_more_points[i, d - 1] = np.linalg.norm(x_test - x_nearest) / np.linalg.norm(x_test - x_farthest)\n\n\n# Plot the ratio of distances between the nearest and farthest points in 1000 experiments for each dimension\n\nplt.figure(figsize=(10, 6))\nplt.plot(np.arange(1, n_dim + 1), np.mean(ratios_nd_more_points, axis=0), 'o-')\nplt.xlabel('Dimension')\nplt.ylabel('Ratio of distances')\nplt.title('Ratio of distances between the nearest and farthest points in 1000 experiments for each dimension')\nplt.ylim(0, 1)\n\n(0.0, 1.0)\n\n\n\n\n\n\n# Now showing how linear regression is affected by curse of dimensionality\n\nn_points = 20\n\nx = np.random.uniform(0, 1, (n_points, 1))\n# sort the x values\nx = np.sort(x, axis=0)\ny = 4 * x + 3 + np.random.normal(0, 0.5, (n_points, 1))\n\nplt.scatter(x, y)\n\n<matplotlib.collections.PathCollection at 0x7f53d8f5feb0>\n\n\n\n\n\n\n# Let us fit a linear regression model of degree d\nfrom sklearn.linear_model import LinearRegression\nfrom sklearn.preprocessing import PolynomialFeatures\n\ndef fit_linear_regression(x, y, d):\n    poly = PolynomialFeatures(degree=d)\n    x = poly.fit_transform(x)\n    model = LinearRegression()\n    model.fit(x, y)\n    return model\n\ndef plot_linear_regression(x, y, d):\n    model = fit_linear_regression(x, y, d)\n    y_pred = model.predict(PolynomialFeatures(degree=d).fit_transform(x))\n    plt.scatter(x, y)\n    plt.plot(x, y_pred, c='r')\n    plt.show()\n\n\nplot_linear_regression(x, y, 1)\n\n\n\n\n\nplot_linear_regression(x, y, 5)\n\n\n\n\n\nplot_linear_regression(x, y, 10)\n\n\n\n\n\nplot_linear_regression(x, y, 15)\n\n\n\n\n\n# Now, we see that if we increase the number of points, the model will fit better\n\nn_points = 1000\n\nx = np.random.uniform(0, 1, (n_points, 1))\n# sort the x values\nx = np.sort(x, axis=0)\ny = 4 * x + 3 + np.random.normal(0, 0.5, (n_points, 1))\n\nplot_linear_regression(x, y, 1)\n\n\n\n\n\nplot_linear_regression(x, y, 5)\n\n\n\n\n\nplot_linear_regression(x, y, 25)"
  },
  {
    "objectID": "notebooks/posts/mle.html",
    "href": "notebooks/posts/mle.html",
    "title": "ES654",
    "section": "",
    "text": "import numpy as np\nimport matplotlib.pyplot as plt\n%matplotlib inline\n%config InlineBackend.figure_format = 'retina'\n\n\ndata = np.array([1, 1, 1, 1, 1, 1, 1, 1, 0, 0])\n\n\nn_h = np.sum(data)\nn_t = len(data) - n_h\n    \n\n\nn_h, n_t\n\n(8, 2)\n\n\n\ndef likelihood(theta):\n    return theta**n_h * (1-theta)**n_t\n\n\ndef log_likelihood(theta):\n    return n_h * np.log(theta) + n_t * np.log(1-theta)\n\n\nlikelihood(0.1)\n\n8.100000000000005e-09\n\n\n\nlikelihood(0.9)\n\n0.004304672099999999\n\n\n\nlikelihood(0.8)\n\n0.0067108864\n\n\n\nfig, ax = plt.subplots(nrows=2, sharex=True)\nx_lin = np.linspace(0.01, 0.99, 100)\ny_lin = likelihood(x_lin)\ny_lin_ll = log_likelihood(x_lin)\nax[0].plot(x_lin, y_lin)\nax[1].plot(x_lin, y_lin_ll)\n\n\n\n\n\nimport torch\n\ntheta = 0.2\nbn = torch.distributions.Bernoulli(probs= theta)\n\ndata = []\nfor i in range(100):\n    data.append(bn.sample())\n\ntensor(59.)"
  },
  {
    "objectID": "notebooks/posts/nn.html",
    "href": "notebooks/posts/nn.html",
    "title": "Neural Network",
    "section": "",
    "text": "import torch\nimport torch.nn as nn\nimport torch.nn.functional as F\nimport torch.optim as optim\n\nimport numpy as np\nimport matplotlib.pyplot as plt\n\nfrom torch.utils.data import DataLoader, TensorDataset\n\n%matplotlib inline\n%config InlineBackend.figure_format = 'retina'\n\n# Set random seed for reproducibility\ntorch.manual_seed(0)\n\n# Torch version\ntorch.__version__\n\n'2.0.0+cu118'\n\n\n\n# MNIST dataset\n\nfrom torchvision import datasets, transforms\nimport torchvision\n\n# Split MNIST into train, validation, and test sets\ntrain_data = datasets.MNIST(root='data', train=True, download=True, transform=transforms.ToTensor())\ntest_data = datasets.MNIST(root='data', train=False, download=True, transform=transforms.ToTensor())\n\n# Split train_data into train and validation sets\nval_data = torch.utils.data.Subset(train_data, range(50000, 51000))\n\n# Reduce the size of the training set to 5,000\ntrain_data = torch.utils.data.Subset(train_data, range(0, 5000))\n\n\n# Create data loaders\nbatch_size = 64\n\ntrain_loader = DataLoader(train_data, batch_size=batch_size, shuffle=True)\nval_loader = DataLoader(val_data, batch_size=batch_size, shuffle=True)\ntest_loader = DataLoader(test_data, batch_size=batch_size, shuffle=True)\n\n\nimg, target = next(iter(train_loader))\nprint(img.shape)\nprint(target.shape)\n\ntorch.Size([64, 1, 28, 28])\ntorch.Size([64])\n\n\n\nplt.imshow(img[0].numpy().squeeze(), cmap='gray_r');\n\n\n\n\n\ntarget\n\ntensor([3, 4, 1, 8, 9, 3, 9, 8, 4, 8, 3, 0, 0, 7, 7, 1, 6, 6, 9, 7, 4, 3, 3, 4,\n        5, 7, 3, 2, 8, 4, 8, 2, 8, 3, 1, 4, 2, 1, 4, 8, 5, 3, 5, 1, 8, 7, 3, 7,\n        7, 2, 0, 3, 1, 3, 7, 0, 7, 1, 7, 6, 4, 1, 8, 0])\n\n\n\n# Store the labels and Images in TensorBoard\n\nfrom torch.utils.tensorboard import SummaryWriter\n\n# Clean up any old runs\n!rm -rf runs\n\n# Default `log_dir` is \"runs\"\nwriter = SummaryWriter('runs/mnist')\n\n# Add images to tensorboard in the form of a grid in batches of 64\ndataiter = iter(DataLoader(train_data, batch_size=64, shuffle=True))\n\n# Add a slider in tensorboard to iterate through the batches\nfor i in range(10):\n    images, labels = next(dataiter)\n    images = torchvision.utils.make_grid(images)\n    # Add images with labels to tensorboard\n    writer.add_image(f'mnist_images_{i}', images, global_step=i)\n\n\n# Define model for 10-class MNIST classification\n\nclass MNISTClassifier(nn.Module):\n    def __init__(self):\n        super().__init__()\n        self.fc1 = nn.Linear(784, 64)\n        self.fc2 = nn.Linear(64, 32)\n        self.fc3 = nn.Linear(32, 10)\n        \n    def forward(self, x):\n        z1 = self.fc1(x)\n        a1 = F.relu(z1)\n        z2 = self.fc2(a1)\n        a2 = F.relu(z2)\n        z3 = self.fc3(a2) # logits\n        return z3\n\n\nmodel = MNISTClassifier()\n\n\n# Forward pass through the model\n\n\n\nsaved_img, saved_target = next(iter(train_loader))\nsaved_img = saved_img.view(saved_img.shape[0], -1)\nprint(saved_img.shape)\n\nplt.imshow(saved_img[0].reshape(28, 28), cmap='gray_r')\nplt.title(saved_target[0].item())\n\n\nwith torch.no_grad():\n    out = model(saved_img.view(saved_img.shape[0], -1))\n\n\n\nprint(out[0])\n\n# Softmax\nprobas = F.softmax(out, dim=1)\nprint(probas[0])\n\ntorch.Size([64, 784])\ntensor([-0.1859, -0.1648,  0.0156,  0.0309,  0.1785, -0.1567, -0.0472,  0.1143,\n        -0.0400, -0.0006])\ntensor([0.0846, 0.0864, 0.1035, 0.1051, 0.1218, 0.0871, 0.0972, 0.1143, 0.0979,\n        0.1019])\n\n\n\n\n\n\nprobas[0:1]\n\ntensor([[0.0846, 0.0864, 0.1035, 0.1051, 0.1218, 0.0871, 0.0972, 0.1143, 0.0979,\n         0.1019]])\n\n\n\n# Predicted label before training\n\npred = torch.argmax(probas[0:1], dim=1).item()\nprint(f\"Prediction:  {pred}, True label: {saved_target[0].item()}\")\n\nPrediction:  4, True label: 2\n\n\n\nmodel.fc1.weight.shape, model.fc1.bias.shape\n\n(torch.Size([64, 784]), torch.Size([64]))\n\n\n\n# Number of parameters in fc1\nprint(\"fc1\", model.fc1.weight.numel() + model.fc1.bias.numel())\n\n# Number of parameters in fc2\nprint(\"fc2\", model.fc2.weight.numel() + model.fc2.bias.numel())\n\n# Number of parameters in fc3\nprint(\"fc3\", model.fc3.weight.numel() + model.fc3.bias.numel())\n\nfc1 50240\nfc2 2080\nfc3 330\n\n\n\n# Get total number of parameters\nprint(\"Total number of parameters:\", sum(p.numel() for p in model.parameters()))\n\nTotal number of parameters: 52650\n\n\n\nlen(train_loader)\n\n79\n\n\n\n# Forward pass through the model and writing to tensorboard\n\nlr = 0.001\noptimizer = optim.Adam(model.parameters(), lr=lr)\ncriterion = nn.CrossEntropyLoss()\n\nnum_epochs = 1\nfor epoch in range(num_epochs):\n    for batch_idx, (data_test, target) in enumerate(train_loader):\n        # Reshape data to input to the network\n        data_test = data_test.view(data_test.shape[0], -1)\n        # Forward pass\n        output = model(data_test)\n        loss = criterion(output, target)\n        # Backward and optimize\n        optimizer.zero_grad()\n        loss.backward()\n        optimizer.step()\n\n        iteration_num = epoch * len(train_loader) + batch_idx\n        \n        # Write to tensorboard\n        writer.add_scalar('Loss/train', loss.item(), iteration_num)\n        writer.add_scalar('Accuracy/train', (output.argmax(dim=1) == target).float().mean(), iteration_num)\n\n        # Find test loss and accuracy\n        runing_loss = 0.0\n        running_acc = 0.0\n        with torch.no_grad():\n            for data_test, target_test in val_loader:\n                data_test = data_test.view(data_test.shape[0], -1)\n                output_test = model(data_test)\n                loss_test = criterion(output_test, target_test)\n                runing_loss += loss_test.item()\n                running_acc += (output_test.argmax(dim=1) == target_test).float().mean()\n        writer.add_scalar('Loss/validation', runing_loss / len(val_loader), iteration_num)\n        writer.add_scalar('Accuracy/validation', running_acc / len(val_loader), iteration_num)\n\n        if batch_idx % 100 == 0:\n            print (f'Epoch [{epoch+1}/{num_epochs}], Step [{batch_idx}/{len(train_loader)}], Loss: {loss.item():.4f}')\n\nEpoch [1/1], Step [0/79], Loss: 2.3027\n\n\n\n# Prediction on the saved image\n\nwith torch.no_grad():\n    out = model(saved_img[0:1])\n    probas = F.softmax(out, dim=1)\n    pred = torch.argmax(probas, dim=1).item()\n    print(pred, saved_target[0].item())\n\n1 1\n\n\n\n# Create a HParam dictionary for batch size and learning rate for tensorboard\n\nb_sizes = [32, 64, 512]\nlrs = [0.001, 0.01, 0.1]\n\n\nnum_epochs  = 1\nfor epoch in range(num_epochs):\n    for b_size in b_sizes:\n        train_loader = DataLoader(train_data, batch_size=b_size, shuffle=True)\n        model = MNISTClassifier()\n        for lr in lrs:\n            print(f\"Batch size: {b_size}, Learning rate: {lr}\")\n            optimizer = optim.Adam(model.parameters(), lr=lr)\n            criterion = nn.CrossEntropyLoss()\n            for batch_idx, (data, target) in enumerate(train_loader):\n                # Reshape data to input to the network\n                data = data.view(data.shape[0], -1)\n                # Forward pass\n                output = model(data)\n                loss = criterion(output, target)\n                # Backward and optimize\n                optimizer.zero_grad()\n                loss.backward()\n                optimizer.step()\n                \n\n                # Write loss as scalar to Tensorboard and hyperparameters to HParams\n                writer.add_scalar('training loss',\n                                loss.item(),\n                                epoch * len(train_loader) + batch_idx)\n                writer.add_hparams({'lr': lr, 'bsize': b_size},\n                                { 'hparam/loss': loss.item()})\n                \n\n    \n\nBatch size: 32, Learning rate: 0.001\nBatch size: 32, Learning rate: 0.01\nBatch size: 32, Learning rate: 0.1\nBatch size: 64, Learning rate: 0.001\nBatch size: 64, Learning rate: 0.01\nBatch size: 64, Learning rate: 0.1\nBatch size: 512, Learning rate: 0.001\nBatch size: 512, Learning rate: 0.01\nBatch size: 512, Learning rate: 0.1"
  },
  {
    "objectID": "notebooks/posts/dt-reg.html",
    "href": "notebooks/posts/dt-reg.html",
    "title": "DT Regression",
    "section": "",
    "text": "import pandas as pd\n\n\ndf = pd.read_csv(\"mins-played.csv\")\n\n\ndf\n\n\n\n\n\n  \n    \n      \n      Day\n      Outlook\n      Temp\n      Humidity\n      Wind\n      Minutes Played\n    \n  \n  \n    \n      0\n      D1\n      Sunny\n      Hot\n      High\n      Weak\n      20\n    \n    \n      1\n      D2\n      Sunny\n      Hot\n      High\n      Strong\n      24\n    \n    \n      2\n      D3\n      Overcast\n      Hot\n      High\n      Weak\n      40\n    \n    \n      3\n      D4\n      Rain\n      Mild\n      High\n      Weak\n      50\n    \n    \n      4\n      D5\n      Rain\n      Cool\n      Normal\n      Weak\n      60\n    \n    \n      5\n      D6\n      Rain\n      Cool\n      Normal\n      Strong\n      10\n    \n    \n      6\n      D7\n      Overcast\n      Cool\n      Normal\n      Strong\n      4\n    \n    \n      7\n      D8\n      Sunny\n      Mild\n      High\n      Weak\n      10\n    \n    \n      8\n      D9\n      Sunny\n      Cool\n      Normal\n      Weak\n      60\n    \n    \n      9\n      D10\n      Rain\n      Mild\n      Normal\n      Weak\n      40\n    \n    \n      10\n      D11\n      Sunny\n      Mild\n      High\n      Strong\n      45\n    \n    \n      11\n      D12\n      Overcast\n      Mild\n      High\n      Strong\n      40\n    \n    \n      12\n      D13\n      Overcast\n      Hot\n      Normal\n      Weak\n      35\n    \n    \n      13\n      D14\n      Rain\n      Mild\n      High\n      Strong\n      20\n    \n  \n\n\n\n\n\ndf[\"Minutes Played\"].std()\n\n18.3111087402348\n\n\n\nimport numpy as np\n# np.std(df[\"Minutes Played\"].values)\n\n\ndf.query(\"Wind=='Weak'\")[\"Minutes Played\"].std()*len(df.query(\"Wind=='Weak'\"))/len(df)\n\n10.180585192846463\n\n\n\ndf.query(\"Wind=='Strong'\")[\"Minutes Played\"].std()*len(df.query(\"Wind=='Strong'\"))/len(df)\n\n6.933944897151599\n\n\n\nout = {}\nfor temp in df[\"Temp\"].unique():\n    print(temp)\n    out[temp] = df.query(\"Temp==@temp\")[\"Minutes Played\"].std()*len(df.query(\"Temp==@temp\"))/len(df)\n    print(out[temp])\n    print()\n\nHot\n2.6636888135137133\n\nMild\n6.696785704762413\n\nCool\n8.770699519880226\n\n\n\n\ndf[\"Minutes Played\"].std() - pd.Series(out).sum()\n\n0.17993470207844808"
  },
  {
    "objectID": "notebooks/posts/gd.html",
    "href": "notebooks/posts/gd.html",
    "title": "Gradient Descent",
    "section": "",
    "text": "import jax.numpy as jnp\nfrom jax import random, jit, vmap, grad, jacfwd, jacrev, hessian, value_and_grad\nimport matplotlib.pyplot as plt\n%matplotlib inline\n%config InlineBackend.figure_format = 'retina'\n\n\n# Simple 2D quadratic function\ndef f(theta_0, theta_1):\n    return theta_0**2 + theta_1**2\n\n\n# Plot surface and contour plots for f using jax.vmap\ndef create_plot(f):\n    theta_0 = jnp.linspace(-2, 2, 100)\n    theta_1 = jnp.linspace(-2, 2, 100)\n    theta_0, theta_1 = jnp.meshgrid(theta_0, theta_1)\n    f_vmap = jnp.vectorize(f, signature='(),()->()')\n    f_vals = f_vmap(theta_0, theta_1)\n\n    # Create a figure with 2 subplots (3d surface and 2d contour)\n    fig = plt.figure(figsize=(12, 4))\n    ax1 = fig.add_subplot(121, projection='3d')\n    ax2 = fig.add_subplot(122)\n\n    # Plot surface and contour plots\n    temp = ax1.plot_surface(theta_0, theta_1, f_vals, cmap='viridis')\n\n    # Filled contour plot and marked level set values using clabel\n    # Set 20 levels between min and max of f_vals\n    levels = jnp.linspace(0.5, int(jnp.max(f_vals))+0.5, 11)\n\n    contours = ax2.contour(theta_0, theta_1, f_vals, levels=levels, cmap='viridis')\n    ax2.clabel(contours, inline=True, fontsize=8)\n\n    # Fill using imshow\n    ax2.imshow(f_vals, extent=[-2, 2, -2, 2], origin='lower', cmap='viridis', alpha=0.5)\n  \n    # Find the global minimum of f using jax.scipy.optimize.minimize\n    from jax.scipy.optimize import minimize\n    def f_min(theta):\n        return f(theta[0], theta[1])\n    res = minimize(f_min, jnp.array([0., 0.]), method='BFGS')\n    theta_min = res.x\n    f_min = res.fun\n    print(f'Global minimum: {f_min} at {theta_min}')\n    # Plot the global minimum\n    ax2.scatter(theta_min[0], theta_min[1], marker='x', color='red', s=100)\n\n    \n\n    ax2.set_aspect('equal')\n\n    # Add labels\n    ax1.set_xlabel(r'$\\theta_0$')\n    ax1.set_ylabel(r'$\\theta_1$')\n    ax1.set_zlabel(r'$f(\\theta_0, \\theta_1)$')\n    ax2.set_xlabel(r'$\\theta_0$')\n    ax2.set_ylabel(r'$\\theta_1$')\n\n    # Add colorbar\n    fig.colorbar(temp, ax=ax1, shrink=0.5, aspect=5)\n\n    # Tight layout\n    plt.tight_layout()\n\n\ncreate_plot(f)\n\nGlobal minimum: 0.0 at [0. 0.]\n\n\n\n\n\n\n# Gradient of f at a given point\ndef grad_f(theta_0, theta_1):\n    return grad(f, argnums=(0, 1))(theta_0, theta_1)\n\n\ngrad_f(2., 1.)\n\n(Array(4., dtype=float32, weak_type=True),\n Array(2., dtype=float32, weak_type=True))\n\n\n\ntheta = jnp.array([2., 1.])\ntheta\n\nArray([2., 1.], dtype=float32)\n\n\n\nf(*theta)\n\nArray(5., dtype=float32)\n\n\n\njnp.array(grad_f(*theta))\n\nArray([4., 2.], dtype=float32)\n\n\n\nlr = 0.1\ntheta = theta- lr * jnp.array(grad_f(*theta))\ntheta\n\nArray([1.6, 0.8], dtype=float32)\n\n\n\nf(*theta)\n\nArray(3.2000003, dtype=float32)\n\n\n\n# Gradient descent loop\n\n# Initial parameters\ntheta = jnp.array([2., 1.])\n\n# Store parameters and function values for plotting\ntheta_vals = [theta]\nf_vals = [f(*theta)]\n\nfor i in range(10):\n    theta = theta - lr * jnp.array(grad_f(*theta))\n    theta_vals.append(theta)\n    f_vals.append(f(*theta))\n    print(f'Iteration {i}: theta = {theta}, f = {f(*theta)}')\n\ntheta_vals = jnp.array(theta_vals)\nf_vals = jnp.array(f_vals)\n\nIteration 0: theta = [1.6 0.8], f = 3.200000286102295\nIteration 1: theta = [1.28 0.64], f = 2.047999858856201\nIteration 2: theta = [1.0239999  0.51199996], f = 1.3107198476791382\nIteration 3: theta = [0.8191999  0.40959996], f = 0.8388606309890747\nIteration 4: theta = [0.6553599  0.32767996], f = 0.5368707776069641\nIteration 5: theta = [0.52428794 0.26214397], f = 0.34359729290008545\nIteration 6: theta = [0.41943035 0.20971517], f = 0.21990226209163666\nIteration 7: theta = [0.3355443  0.16777214], f = 0.14073745906352997\nIteration 8: theta = [0.26843542 0.13421771], f = 0.09007196873426437\nIteration 9: theta = [0.21474834 0.10737417], f = 0.05764605849981308\n\n\n\n# Plot the cost vs iterations\nplt.plot(f_vals)\n\n\n\n\n\n# Simple dataset for linear regression\n\nX = jnp.array([[1.], [2.], [3.]])\ny = jnp.array([1., 2.2, 2.8])\n\nfrom sklearn.linear_model import LinearRegression\nlr = LinearRegression()\nlr.fit(X, y)\n\nLinearRegression()In a Jupyter environment, please rerun this cell to show the HTML representation or trust the notebook. On GitHub, the HTML representation is unable to render, please try loading this page with nbviewer.org.LinearRegressionLinearRegression()\n\n\n\nlr.coef_, lr.intercept_\n\n(array([0.9000001], dtype=float32), 0.19999981)\n\n\n\n# Cost function for linear regression using jax.vmap\ndef cost(theta_0, theta_1):\n    y_hat = (theta_0 + theta_1 * X).flatten()\n    #print(y_hat, y, y-y_hat, (y-y_hat)**2)\n    return jnp.mean((y_hat- y)**2)\n    \n# Plot surface and contour plots for cost function\n#create_plot(cost)\n\n\ncost(2.0, 2.0)\n\nArray(16.826666, dtype=float32)\n\n\n\n(3**2 + 3.8**2 + 5.2**2)/3.\n\n16.826666666666668\n\n\n\n# Gradient of cost function at a given point\ndef grad_cost(theta_0, theta_1):\n    return jnp.array(grad(cost, argnums=(0, 1))(theta_0, theta_1))\n\ngrad_cost(2.0, 2.0)\n\nArray([ 8.      , 17.466667], dtype=float32)\n\n\n\ndef grad_cost_manual(theta_0, theta_1):\n    y_hat = (theta_0 + theta_1 * X).flatten()\n    return jnp.array([2*jnp.mean(y_hat - y), 2*jnp.mean((y_hat - y) * X.flatten())])\n\n\ngrad_cost_manual(2.0, 2.0)\n\nArray([ 8.      , 17.466667], dtype=float32)\n\n\n\n# Plotting cost surface and contours for three points in X individually\n\ndef cost_i(theta_0, theta_1, i = 1):\n    y_hat = theta_0 + theta_1 * X[i-1:i]\n    return jnp.mean((y_hat- y[i-1:i])**2)\n\n\n(cost_i(2.0, 2.0, 1) + cost_i(2.0, 2.0, 2) + cost_i(2.0, 2.0, 3))/3.0\n\nArray(16.826666, dtype=float32)\n\n\n\nfrom functools import partial\n\n\n# Plot surface and contour plots for cost function\nfor i in range(1, 4):\n    cost_i_p = partial(cost_i, i=i)\n    create_plot(cost_i_p)\n\nGlobal minimum: 0.0 at [0.5 0.5]\nGlobal minimum: 0.0 at [0.44000003 0.88000005]\nGlobal minimum: 0.0 at [0.28000003 0.84      ]\n\n\n\n\n\n\n\n\n\n\n\n\ngrad_cost_1 = grad(cost_i, argnums=(0, 1))\ngrad_cost_1(2.0, 2.0)\n\n(Array(6., dtype=float32, weak_type=True),\n Array(6., dtype=float32, weak_type=True))\n\n\n\njnp.array(grad_cost_1(2.0, 2.0, 1)), jnp.array(grad_cost_1(2.0, 2.0, 2)), jnp.array(grad_cost_1(2.0, 2.0, 3))\n\n(Array([6., 6.], dtype=float32),\n Array([ 7.6, 15.2], dtype=float32),\n Array([10.4     , 31.199999], dtype=float32))"
  },
  {
    "objectID": "notebooks/posts/kmeans-segmentation.html",
    "href": "notebooks/posts/kmeans-segmentation.html",
    "title": "Image Segmentation using K-Means Clustering",
    "section": "",
    "text": "import numpy as np\nimport matplotlib.pyplot as plt\nimport pandas as pd\n\n%matplotlib inline\n%config InlineBackend.figure_format = 'retina'\n\n\n!wget https://segment-anything.com/assets/gallery/AdobeStock_94274587_welsh_corgi_pembroke_CD.jpg -O dog.jpg\n\n--2023-04-15 11:58:51--  https://segment-anything.com/assets/gallery/AdobeStock_94274587_welsh_corgi_pembroke_CD.jpg\nResolving segment-anything.com (segment-anything.com)... 108.158.245.28, 108.158.245.33, 108.158.245.84, ...\nConnecting to segment-anything.com (segment-anything.com)|108.158.245.28|:443... connected.\nHTTP request sent, awaiting response... 200 OK\nLength: 221810 (217K) [image/jpeg]\nSaving to: ‘dog.jpg’\n\ndog.jpg             100%[===================>] 216.61K   348KB/s    in 0.6s    \n\n2023-04-15 11:58:53 (348 KB/s) - ‘dog.jpg’ saved [221810/221810]\n\n\n\n\n# Read image and convert to RGB\nimg = plt.imread('dog.jpg')\n\n# Convert to [0, 1] range\n\nimg = img / 255\n\n\n# Plot image\nplt.imshow(img)\n\n<matplotlib.image.AxesImage at 0x7efc88822340>\n\n\n\n\n\n\nimg.shape\n\n(1365, 2048, 3)\n\n\n\nfrom sklearn.cluster import KMeans\n\n# Reshape image to 2D array\nimg_2d = img.reshape(-1, 3)\npd.DataFrame(img_2d).describe()\n\n\n\n\n\n  \n    \n      \n      0\n      1\n      2\n    \n  \n  \n    \n      count\n      2.795520e+06\n      2.795520e+06\n      2.795520e+06\n    \n    \n      mean\n      5.542249e-01\n      4.757675e-01\n      2.935504e-01\n    \n    \n      std\n      2.068960e-01\n      1.844162e-01\n      1.533922e-01\n    \n    \n      min\n      3.921569e-02\n      0.000000e+00\n      0.000000e+00\n    \n    \n      25%\n      3.882353e-01\n      3.176471e-01\n      1.647059e-01\n    \n    \n      50%\n      5.725490e-01\n      4.705882e-01\n      2.666667e-01\n    \n    \n      75%\n      7.294118e-01\n      6.392157e-01\n      4.078431e-01\n    \n    \n      max\n      1.000000e+00\n      1.000000e+00\n      1.000000e+00\n    \n  \n\n\n\n\n\nimg_2d.shape\n\n(2795520, 3)\n\n\n\nnp.unique(img_2d, axis=0).shape\n\n(190571, 3)\n\n\n\n# Fit KMeans from scikit-learn (slow!)\nkmeans = KMeans(n_clusters=5, random_state=0).fit(img_2d)\n\n\nkmeans.cluster_centers_, kmeans.labels_\n\n(array([[0.59260829, 0.48656705, 0.2670584 ],\n        [0.24250138, 0.22963615, 0.12538282],\n        [0.8270407 , 0.74152134, 0.54547183],\n        [0.71622954, 0.62308534, 0.39023071],\n        [0.419752  , 0.3354403 , 0.18325719]]),\n array([1, 1, 1, ..., 4, 4, 4], dtype=int32))\n\n\n\n# instead use FAISS with GPU\n\nimport faiss\n# Set up FAISS index\nd = img_2d.shape[1]  # Dimension of the feature vectors\nn_clusters = 5   # Number of clusters\nn_gpus = 2         # Number of GPUs to use\n\n# Initialize a multi-GPU IndexFlatL2 index\nindex_flat = faiss.IndexFlatL2(d)\nindex = faiss.index_cpu_to_all_gpus(index_flat, ngpu=n_gpus)\n\n\nkmeans_gpu = faiss.Clustering(d, n_clusters)\nkmeans_gpu.verbose = True\nkmeans_gpu.niter = 20\nkmeans_gpu.train(img_2d.astype(np.float32), index)\n\nSampling a subset of 1280 / 2795520 for training\nClustering 1280 points in 3D to 5 clusters, redo 1 times, 20 iterations\n  Preprocessing in 0.03 s\n  Iteration 19 (0.22 s, search 0.00 s): objective=12.4307 imbalance=1.031 nsplit=0       \n\n\n\n_, I = index.search(img_2d.astype(np.float32), 1)  # Search for nearest centroid\ncluster_ids = I.squeeze()\n\n\n# Create segmented image using cluster centers frmo sklearn\nsegmented_img = kmeans.cluster_centers_[kmeans.labels_]\nsegmented_img = segmented_img.reshape(img.shape)\n\ncentroids_gpu = faiss.vector_float_to_array(kmeans_gpu.centroids).reshape(n_clusters, d)\n# Create segmented image using cluster centers from FAISS\nsegmented_img_faiss = centroids_gpu[cluster_ids]\n\n# Plot segmented image side by side\nfig, ax = plt.subplots(1, 2, figsize=(10, 5))\nax[0].imshow(segmented_img)\nax[1].imshow(segmented_img_faiss.reshape(img.shape))\n\n<matplotlib.image.AxesImage at 0x7efa51d55250>\n\n\n\n\n\n\n# Now, let's try to segment the image using a different number of clusters using FAISS\n\ndef segment_plot(img, k=5):\n    # Reshape image to 2D array\n    img_2d = img.reshape(-1, 3)\n\n    # Set up FAISS index\n    d = img_2d.shape[1]  # Dimension of the feature vectors\n    n_clusters = k   # Number of clusters\n    n_gpus = 2         # Number of GPUs to use\n\n    # Initialize a multi-GPU IndexFlatL2 index\n    index_flat = faiss.IndexFlatL2(d)\n    index = faiss.index_cpu_to_all_gpus(index_flat, ngpu=n_gpus)\n\n    kmeans_gpu = faiss.Clustering(d, n_clusters)\n    kmeans_gpu.verbose = True\n    kmeans_gpu.niter = 20\n    kmeans_gpu.train(img_2d.astype(np.float32), index)\n\n    _, I = index.search(img_2d.astype(np.float32), 1)  # Search for nearest centroid\n    cluster_ids = I.squeeze()\n\n    centroids_gpu = faiss.vector_float_to_array(kmeans_gpu.centroids).reshape(n_clusters, d)\n    # Create segmented image using cluster centers from FAISS\n    segmented_img_faiss = centroids_gpu[cluster_ids]\n\n    # Plot segmented image side by side\n    fig, ax = plt.subplots(1, 2, figsize=(10, 5))\n    ax[0].imshow(img)\n    ax[1].imshow(segmented_img_faiss.reshape(img.shape))\n\n    # Plot the color of each cluster\n    fig, ax = plt.subplots(1, 1, figsize=(4, 4))\n    ax.imshow(centroids_gpu.reshape(1, n_clusters, 3))\n    \n\n\nsegment_plot(img, k=2)\n\nSampling a subset of 512 / 2795520 for training\nClustering 512 points in 3D to 2 clusters, redo 1 times, 20 iterations\n  Preprocessing in 0.04 s\n  Iteration 19 (0.25 s, search 0.00 s): objective=14.8063 imbalance=1.000 nsplit=0       \n\n\n\n\n\n\n\n\n\nsegment_plot(img, k=10)\n\nSampling a subset of 2560 / 2795520 for training\nClustering 2560 points in 3D to 10 clusters, redo 1 times, 20 iterations\n  Preprocessing in 0.04 s\n  Iteration 19 (0.03 s, search 0.01 s): objective=13.6225 imbalance=1.202 nsplit=0       \n\n\n\n\n\n\n\n\n\n# Modify segmentation function to mask out all but the given cluster\nfrom copy import deepcopy\ndef segment_plot_mask(img, k=5):\n    # Reshape image to 2D array\n    img_2d = img.reshape(-1, 3)\n\n    # Set up FAISS index\n    d = img_2d.shape[1]  # Dimension of the feature vectors\n    n_clusters = k   # Number of clusters\n    n_gpus = 2         # Number of GPUs to use\n\n    # Initialize a multi-GPU IndexFlatL2 index\n    index_flat = faiss.IndexFlatL2(d)\n    index = faiss.index_cpu_to_all_gpus(index_flat, ngpu=n_gpus)\n\n    kmeans_gpu = faiss.Clustering(d, n_clusters)\n    kmeans_gpu.verbose = True\n    kmeans_gpu.niter = 20\n    kmeans_gpu.train(img_2d.astype(np.float32), index)\n\n    _, I = index.search(img_2d.astype(np.float32), 1)  # Search for nearest centroid\n    cluster_ids = I.squeeze()\n\n    centroids_gpu = faiss.vector_float_to_array(kmeans_gpu.centroids).reshape(n_clusters, d)\n    # Create segmented image using cluster centers from FAISS\n    segmented_img_faiss = centroids_gpu[cluster_ids]\n\n    # Plot segmented image side by side\n    fig, ax = plt.subplots(1, 2, figsize=(10, 5))\n    ax[0].imshow(img)\n    segmented_img_faiss = segmented_img_faiss.reshape(img.shape)\n    ax[1].imshow(segmented_img_faiss)\n\n    # Now, create another figure with number of cluser columns\n    # and plot each cluster with mask applied to the original image\n    # The mask is an alpha channel\n    \n    fig, ax = plt.subplots(1, n_clusters, figsize=(n_clusters*4, 5))\n    for i in range(n_clusters):\n        img_masked = deepcopy(img_2d)\n        img_masked[cluster_ids != i] = 1.0\n        ax[i].imshow(img_masked.reshape(img.shape))\n        ax[i].set_title(f'Cluster {i}')\n        ax[i].axis('off')\n    \n    \n\n    \n\n\nimg.shape\n\n(1365, 2048, 3)\n\n\n\nmask = segment_plot_mask(img, k=2)\n\nSampling a subset of 512 / 2795520 for training\nClustering 512 points in 3D to 2 clusters, redo 1 times, 20 iterations\n  Preprocessing in 0.02 s\n  Iteration 19 (0.46 s, search 0.00 s): objective=14.8063 imbalance=1.000 nsplit=0       \n\n\n\n\n\n\n\n\n\nmask = segment_plot_mask(img, k=3)\n\nSampling a subset of 768 / 2795520 for training\nClustering 768 points in 3D to 3 clusters, redo 1 times, 20 iterations\n  Preprocessing in 0.02 s\n  Iteration 19 (0.46 s, search 0.00 s): objective=12.5181 imbalance=1.009 nsplit=0       \n\n\n\n\n\n\n\n\n\nmask = segment_plot_mask(img, k=4)\n\nSampling a subset of 1024 / 2795520 for training\nClustering 1024 points in 3D to 4 clusters, redo 1 times, 20 iterations\n  Preprocessing in 0.02 s\n  Iteration 19 (0.15 s, search 0.00 s): objective=12.6442 imbalance=1.031 nsplit=0       \n\n\n\n\n\n\n\n\n\n# Now, let us segment the image using not only RGB but also the spatial coordinates\n\n# Reshape image to 2D array\nimg_2d = img.reshape(-1, 3)\n\n# Add spatial coordinates\nx = np.arange(img.shape[0])\ny = np.arange(img.shape[1])\n\n# Scale the spatial coordinates to be between a and b\ndef scale(x, a, b):\n    return (b-a)*(x-x.min())/(x.max()-x.min()) + a\n\nx = scale(x, 0.25, 0.75)\ny = scale(y, 0.25, 0.75)\n\nxx, yy = np.meshgrid(x, y)\nxx = xx.reshape(-1, 1)\nyy = yy.reshape(-1, 1)\n\nimg_2d_spatial = np.hstack((img_2d, xx, yy))\npd.DataFrame(img_2d_spatial).describe()\n\n\n\n\n\n  \n    \n      \n      0\n      1\n      2\n      3\n      4\n    \n  \n  \n    \n      count\n      2.795520e+06\n      2.795520e+06\n      2.795520e+06\n      2.795520e+06\n      2.795520e+06\n    \n    \n      mean\n      5.542249e-01\n      4.757675e-01\n      2.935504e-01\n      5.000000e-01\n      5.000000e-01\n    \n    \n      std\n      2.068960e-01\n      1.844162e-01\n      1.533922e-01\n      1.444434e-01\n      1.444081e-01\n    \n    \n      min\n      3.921569e-02\n      0.000000e+00\n      0.000000e+00\n      2.500000e-01\n      2.500000e-01\n    \n    \n      25%\n      3.882353e-01\n      3.176471e-01\n      1.647059e-01\n      3.750000e-01\n      3.750000e-01\n    \n    \n      50%\n      5.725490e-01\n      4.705882e-01\n      2.666667e-01\n      5.000000e-01\n      5.000000e-01\n    \n    \n      75%\n      7.294118e-01\n      6.392157e-01\n      4.078431e-01\n      6.250000e-01\n      6.250000e-01\n    \n    \n      max\n      1.000000e+00\n      1.000000e+00\n      1.000000e+00\n      7.500000e-01\n      7.500000e-01\n    \n  \n\n\n\n\n\n# Now, modify the segment_plot function to include spatial coordinates\n\ndef segment_plot_spatial(img, k=5):\n    # Reshape image to 2D array\n    img_2d = img.reshape(-1, 3)\n\n    # Add spatial coordinates\n    x = np.arange(img.shape[0])\n    y = np.arange(img.shape[1])\n\n    # Scale the spatial coordinates to be between a and b\n    x = scale(x, 0, 1)\n    y = scale(y, 0, 1)\n\n    xx, yy = np.meshgrid(x, y)\n    xx = xx.reshape(-1, 1)\n    yy = yy.reshape(-1, 1)\n\n    img_2d_spatial = np.hstack((img_2d, xx, yy))\n\n    # Set up FAISS index\n    d = img_2d_spatial.shape[1]  # Dimension of the feature vectors\n    n_clusters = k   # Number of clusters\n    n_gpus = 2         # Number of GPUs to use\n\n    # Initialize a multi-GPU IndexFlatL2 index\n    index_flat = faiss.IndexFlatL2(d)\n    index = faiss.index_cpu_to_all_gpus(index_flat, ngpu=n_gpus)\n\n    kmeans_gpu = faiss.Clustering(d, n_clusters)\n    kmeans_gpu.verbose = True\n    kmeans_gpu.niter = 20    \n    kmeans_gpu.train(img_2d_spatial.astype(np.float32), index)\n\n    _, I = index.search(img_2d_spatial.astype(np.float32), 1)  # Search for nearest centroid\n    cluster_ids = I.squeeze()\n\n    centroids_gpu = faiss.vector_float_to_array(kmeans_gpu.centroids).reshape(n_clusters, d)\n    # Create segmented image using cluster centers from FAISS with spatial coordinates excluded for plotting\n    segmented_img_faiss = centroids_gpu[cluster_ids, :3]\n\n    # Plot segmented image side by side\n    fig, ax = plt.subplots(1, 2, figsize=(10, 5))\n    ax[0].imshow(img)\n    ax[1].imshow(segmented_img_faiss.reshape(img.shape))\n\n    # Now, create another figure with number of cluser columns\n    # and plot each cluster with mask applied to the original image\n    # The mask is an alpha channel\n    \n    fig, ax = plt.subplots(1, n_clusters, figsize=(n_clusters*4, 5))\n    for i in range(n_clusters):\n        img_masked = deepcopy(img_2d_spatial[:, :3 ])\n        img_masked[cluster_ids != i] = 1.0\n        ax[i].imshow(img_masked.reshape(img.shape))\n        ax[i].set_title(f'Cluster {i}')\n        ax[i].axis('off')\n\n\nsegment_plot_spatial(img, k=2)\n\nSampling a subset of 512 / 2795520 for training\nClustering 512 points in 5D to 2 clusters, redo 1 times, 20 iterations\n  Preprocessing in 0.03 s\n  Iteration 19 (0.44 s, search 0.00 s): objective=73.9492 imbalance=1.018 nsplit=0       \n\n\n\n\n\n\n\n\n\nsegment_plot_mask(img, k=2)\n\nSampling a subset of 512 / 2795520 for training\nClustering 512 points in 3D to 2 clusters, redo 1 times, 20 iterations\n  Preprocessing in 0.03 s\n  Iteration 19 (0.47 s, search 0.00 s): objective=14.8063 imbalance=1.000 nsplit=0"
  },
  {
    "objectID": "notebooks/posts/tips.html",
    "href": "notebooks/posts/tips.html",
    "title": "Misc tips",
    "section": "",
    "text": "Miscelleneous tips\n\nTab Complete\na.b?\nBlack format\nrich\n\ntable\ninspect\n\ndir()\ntiming\ntiming with sort?!\ntimeit object\nplotting timing\narray .tolist()\nDataclasses\nAnnotation\nPlotting with pandas (sin, log, question …)\n\n\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport pandas as pd\n\n%matplotlib inline\n%config InlineBackend.figure_format='retina'\n\n\nn = 100\nk = 20\nm = 50\n\nnp.random.seed(0)\na = np.random.randn(n, k)\nb = np.random.randn(k, m)\na.shape, b.shape\n\n((100, 20), (20, 50))\n\n\n\na_list_of_list = a.tolist()\na_list_of_list[0]\n\nlist\n\n\n\n\"list\" in dir(a)[:]\n\nFalse\n\n\n\nimport rich\nrich.inspect(a.tolist, methods=True, all=True)\n\n╭──────────────────────── <built-in method tolist of numpy.ndarray object at 0x164cbb8d0> ────────────────────────╮\n│ def ndarray.tolist(...)                                                                                         │\n│                                                                                                                 │\n│ a.tolist()                                                                                                      │\n│                                                                                                                 │\n│            __doc__ = \"a.tolist()\\n\\n    Return the array as an ``a.ndim``-levels deep nested list of Python     │\n│                      scalars.\\n\\n    Return a copy of the array data as a (nested) Python list.\\n    Data items │\n│                      are converted to the nearest compatible builtin Python type, via\\n    the                  │\n│                      `~numpy.ndarray.item` function.\\n\\n    If ``a.ndim`` is 0, then since the depth of the     │\n│                      nested list is 0, it will\\n    not be a list at all, but a simple Python scalar.\\n\\n       │\n│                      Parameters\\n    ----------\\n    none\\n\\n    Returns\\n    -------\\n    y : object, or list  │\n│                      of object, or list of list of object, or ...\\n        The possibly nested list of array    │\n│                      elements.\\n\\n    Notes\\n    -----\\n    The array may be recreated via ``a =                │\n│                      np.array(a.tolist())``, although this\\n    may sometimes lose precision.\\n\\n    Examples\\n │\n│                      --------\\n    For a 1D array, ``a.tolist()`` is almost the same as ``list(a)``,\\n          │\n│                      except that ``tolist`` changes numpy scalars to Python scalars:\\n\\n    >>> a =             │\n│                      np.uint32([1, 2])\\n    >>> a_list = list(a)\\n    >>> a_list\\n    [1, 2]\\n    >>>           │\n│                      type(a_list[0])\\n    <class 'numpy.uint32'>\\n    >>> a_tolist = a.tolist()\\n    >>>        │\n│                      a_tolist\\n    [1, 2]\\n    >>> type(a_tolist[0])\\n    <class 'int'>\\n\\n    Additionally,    │\n│                      for a 2D array, ``tolist`` applies recursively:\\n\\n    >>> a = np.array([[1, 2], [3,       │\n│                      4]])\\n    >>> list(a)\\n    [array([1, 2]), array([3, 4])]\\n    >>> a.tolist()\\n    [[1,    │\n│                      2], [3, 4]]\\n\\n    The base case for this recursion is a 0D array:\\n\\n    >>> a =          │\n│                      np.array(1)\\n    >>> list(a)\\n    Traceback (most recent call last):\\n      ...\\n          │\n│                      TypeError: iteration over a 0-d array\\n    >>> a.tolist()\\n    1\"                          │\n│         __module__ = None                                                                                       │\n│           __name__ = 'tolist'                                                                                   │\n│       __qualname__ = 'ndarray.tolist'                                                                           │\n│           __self__ = array([[ 1.76405235e+00,  4.00157208e-01,  9.78737984e-01, ...,                            │\n│                              -2.05158264e-01,  3.13067702e-01, -8.54095739e-01],                                │\n│                             [-2.55298982e+00,  6.53618595e-01,  8.64436199e-01, ...,                            │\n│                               1.20237985e+00, -3.87326817e-01, -3.02302751e-01],                                │\n│                             [-1.04855297e+00, -1.42001794e+00, -1.70627019e+00, ...,                            │\n│                               3.02471898e-01, -6.34322094e-01, -3.62741166e-01],                                │\n│                             ...,                                                                                │\n│                             [ 8.73311836e-01,  1.19973618e+00,  4.56153036e-01, ...,                            │\n│                              -1.24021634e+00,  9.00054243e-01,  1.80224223e+00],                                │\n│                             [-2.08285103e-01,  1.57437124e+00,  1.98989494e-01, ...,                            │\n│                               4.32837621e-01, -8.08717532e-01, -1.10412399e+00],                                │\n│                             [-7.89102180e-01,  1.24845579e-03, -1.59939788e-01, ...,                            │\n│                               1.58433847e-01, -1.14190142e+00, -1.31097037e+00]])                               │\n│ __text_signature__ = None                                                                                       │\n│           __call__ = def __call__(*args, **kwargs): Call self as a function.                                    │\n│          __class__ = class __class__():                                                                         │\n│        __delattr__ = def __delattr__(name, /): Implement delattr(self, name).                                   │\n│            __dir__ = def __dir__(): Default dir() implementation.                                               │\n│             __eq__ = def __eq__(value, /): Return self==value.                                                  │\n│         __format__ = def __format__(format_spec, /): Default object formatter.                                  │\n│             __ge__ = def __ge__(value, /): Return self>=value.                                                  │\n│   __getattribute__ = def __getattribute__(name, /): Return getattr(self, name).                                 │\n│             __gt__ = def __gt__(value, /): Return self>value.                                                   │\n│           __hash__ = def __hash__(): Return hash(self).                                                         │\n│           __init__ = def __init__(*args, **kwargs): Initialize self.  See help(type(self)) for accurate         │\n│                      signature.                                                                                 │\n│  __init_subclass__ = def __init_subclass__(...) This method is called when a class is subclassed.               │\n│             __le__ = def __le__(value, /): Return self<=value.                                                  │\n│             __lt__ = def __lt__(value, /): Return self<value.                                                   │\n│             __ne__ = def __ne__(value, /): Return self!=value.                                                  │\n│            __new__ = def __new__(*args, **kwargs): Create and return a new object.  See help(type) for accurate │\n│                      signature.                                                                                 │\n│         __reduce__ = def __reduce__(...) Helper for pickle.                                                     │\n│      __reduce_ex__ = def __reduce_ex__(protocol, /): Helper for pickle.                                         │\n│           __repr__ = def __repr__(): Return repr(self).                                                         │\n│        __setattr__ = def __setattr__(name, value, /): Implement setattr(self, name, value).                     │\n│         __sizeof__ = def __sizeof__(): Size of object in memory, in bytes.                                      │\n│            __str__ = def __str__(): Return str(self).                                                           │\n│   __subclasshook__ = def __subclasshook__(...) Abstract classes can override this to customize issubclass().    │\n╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯\n\n\n\n\nlambda x: np.power(x, 3)\n\n\ndef f(x):\n    return np.power(x, 3)\n\n\nd = {\n    r\"$\\sin(x)$\": np.sin,\n    r\"$\\log(x)$\": np.log,\n    r\"$\\frac{sin(x)}{x}$\": lambda x: np.sin(x) / x,\n    r\"$x^3$\": lambda x: np.power(x, 3),\n}\n\n\nd\n\n{'$\\\\sin(x)$': <ufunc 'sin'>,\n '$\\\\log(x)$': <ufunc 'log'>,\n '$\\\\frac{sin(x)}{x}$': <function __main__.<lambda>(x)>,\n '$x^3$': <function __main__.<lambda>(x)>}\n\n\n\nx = np.arange(0.005, 10.0, 0.005)\n\n\ne = {k: v(x) for k, v in d.items()}\n\n\ne\n\n{'$\\\\sin(x)$': array([ 0.00499998,  0.00999983,  0.01499944, ..., -0.53137431,\n        -0.53560333, -0.53981897]),\n '$\\\\log(x)$': array([-5.29831737, -4.60517019, -4.19970508, ...,  2.30108397,\n         2.30158459,  2.30208497]),\n '$\\\\frac{sin(x)}{x}$': array([ 0.99999583,  0.99998333,  0.9999625 , ..., -0.05321726,\n        -0.05361395, -0.0540089 ]),\n '$x^3$': array([1.25000000e-07, 1.00000000e-06, 3.37500000e-06, ...,\n        9.95506747e+02, 9.97002999e+02, 9.98500750e+02])}\n\n\n\ndf = pd.DataFrame(e, index=x)\n\n\ndf\n\n\n\n\n\n  \n    \n      \n      $\\sin(x)$\n      $\\log(x)$\n      $\\frac{sin(x)}{x}$\n      $x^3$\n    \n  \n  \n    \n      0.005\n      0.005000\n      -5.298317\n      0.999996\n      1.250000e-07\n    \n    \n      0.010\n      0.010000\n      -4.605170\n      0.999983\n      1.000000e-06\n    \n    \n      0.015\n      0.014999\n      -4.199705\n      0.999963\n      3.375000e-06\n    \n    \n      0.020\n      0.019999\n      -3.912023\n      0.999933\n      8.000000e-06\n    \n    \n      0.025\n      0.024997\n      -3.688879\n      0.999896\n      1.562500e-05\n    \n    \n      ...\n      ...\n      ...\n      ...\n      ...\n    \n    \n      9.975\n      -0.522877\n      2.300082\n      -0.052419\n      9.925187e+02\n    \n    \n      9.980\n      -0.527132\n      2.300583\n      -0.052819\n      9.940120e+02\n    \n    \n      9.985\n      -0.531374\n      2.301084\n      -0.053217\n      9.955067e+02\n    \n    \n      9.990\n      -0.535603\n      2.301585\n      -0.053614\n      9.970030e+02\n    \n    \n      9.995\n      -0.539819\n      2.302085\n      -0.054009\n      9.985007e+02\n    \n  \n\n1999 rows × 4 columns\n\n\n\n\ndf.plot()\n\n<AxesSubplot:>\n\n\n\n\n\n\ndf.plot(subplots=True)\n\narray([<AxesSubplot:>, <AxesSubplot:>, <AxesSubplot:>, <AxesSubplot:>],\n      dtype=object)\n\n\n\n\n\n\ndf\n\n\n\n\n\n  \n    \n      \n      $\\sin$\n      log\n      $\\frac{sin(x)}{x}$\n      x^3\n    \n  \n  \n    \n      0.005\n      0.005000\n      -5.298317\n      0.999996\n      1.250000e-07\n    \n    \n      0.010\n      0.010000\n      -4.605170\n      0.999983\n      1.000000e-06\n    \n    \n      0.015\n      0.014999\n      -4.199705\n      0.999963\n      3.375000e-06\n    \n    \n      0.020\n      0.019999\n      -3.912023\n      0.999933\n      8.000000e-06\n    \n    \n      0.025\n      0.024997\n      -3.688879\n      0.999896\n      1.562500e-05\n    \n    \n      ...\n      ...\n      ...\n      ...\n      ...\n    \n    \n      9.975\n      -0.522877\n      2.300082\n      -0.052419\n      9.925187e+02\n    \n    \n      9.980\n      -0.527132\n      2.300583\n      -0.052819\n      9.940120e+02\n    \n    \n      9.985\n      -0.531374\n      2.301084\n      -0.053217\n      9.955067e+02\n    \n    \n      9.990\n      -0.535603\n      2.301585\n      -0.053614\n      9.970030e+02\n    \n    \n      9.995\n      -0.539819\n      2.302085\n      -0.054009\n      9.985007e+02\n    \n  \n\n1999 rows × 4 columns\n\n\n\n\n((df - df.min(axis=0)) / (df.max(axis=0) - df.min(axis=0))).plot()\n\n<AxesSubplot:>\n\n\n\n\n\n\ndf = pd.DataFrame(np.random.randn(1000, 5),\n                  columns=\"a,b,c,d,e\".split(\",\"))\ndf\n\n\n\n\n\n  \n    \n      \n      a\n      b\n      c\n      d\n      e\n    \n  \n  \n    \n      0\n      1.593274\n      0.568722\n      -0.114487\n      0.251630\n      -1.210856\n    \n    \n      1\n      -0.393734\n      0.085253\n      0.099422\n      -1.530616\n      0.327623\n    \n    \n      2\n      0.279196\n      -0.377051\n      0.004175\n      -1.483492\n      -1.479796\n    \n    \n      3\n      0.134687\n      -0.667723\n      -0.011556\n      0.839491\n      -0.173930\n    \n    \n      4\n      -2.810668\n      -0.150654\n      -0.481044\n      -0.234694\n      0.899731\n    \n    \n      ...\n      ...\n      ...\n      ...\n      ...\n      ...\n    \n    \n      995\n      -0.837658\n      1.315288\n      -0.364523\n      1.993571\n      1.584878\n    \n    \n      996\n      -2.104663\n      -2.553118\n      -1.242666\n      0.201987\n      -0.305332\n    \n    \n      997\n      -1.195587\n      -1.577903\n      0.849912\n      0.327590\n      -0.001670\n    \n    \n      998\n      -0.035563\n      -0.489252\n      1.930498\n      -0.262645\n      0.825932\n    \n    \n      999\n      -0.643267\n      -0.828981\n      -0.202735\n      -0.257866\n      0.070815\n    \n  \n\n1000 rows × 5 columns\n\n\n\n\ndf = df.assign(f=df.sum(axis=1))\n\n\ndf\n\n\n\n\n\n  \n    \n      \n      a\n      b\n      c\n      d\n      e\n      f\n    \n  \n  \n    \n      0\n      1.593274\n      0.568722\n      -0.114487\n      0.251630\n      -1.210856\n      1.088284\n    \n    \n      1\n      -0.393734\n      0.085253\n      0.099422\n      -1.530616\n      0.327623\n      -1.412052\n    \n    \n      2\n      0.279196\n      -0.377051\n      0.004175\n      -1.483492\n      -1.479796\n      -3.056967\n    \n    \n      3\n      0.134687\n      -0.667723\n      -0.011556\n      0.839491\n      -0.173930\n      0.120969\n    \n    \n      4\n      -2.810668\n      -0.150654\n      -0.481044\n      -0.234694\n      0.899731\n      -2.777329\n    \n    \n      ...\n      ...\n      ...\n      ...\n      ...\n      ...\n      ...\n    \n    \n      995\n      -0.837658\n      1.315288\n      -0.364523\n      1.993571\n      1.584878\n      3.691555\n    \n    \n      996\n      -2.104663\n      -2.553118\n      -1.242666\n      0.201987\n      -0.305332\n      -6.003792\n    \n    \n      997\n      -1.195587\n      -1.577903\n      0.849912\n      0.327590\n      -0.001670\n      -1.597657\n    \n    \n      998\n      -0.035563\n      -0.489252\n      1.930498\n      -0.262645\n      0.825932\n      1.968971\n    \n    \n      999\n      -0.643267\n      -0.828981\n      -0.202735\n      -0.257866\n      0.070815\n      -1.862035\n    \n  \n\n1000 rows × 6 columns\n\n\n\n\ndf.query(\"f > 5\")[\"f\"].std()\n\n0.6609257763922614\n\n\n\ndf.query(\"f <= 5\")[\"f\"].std()\n\n2.1891090850524444\n\n\n\n\"tolist\" in dir(df)\n\nFalse\n\n\n\ndef search(obj, query):\n    import re\n\n    return list(filter(lambda x: re.search(query, x), dir(obj)))\n\n\nsearch(a, \"lis\")\n\n['tolist']\n\n\n\nimport numpy as np\nimport pandas as pd\n\n\ndef search(obj, query):\n    import re\n    from rich import inspect\n    from rich.pretty import Pretty\n    from rich.panel import Panel\n\n    z = list(filter(lambda x: re.search(query, x), dir(obj)))\n    p = Panel(Pretty(\"a\"), title=f\"Searching for `{query}`\")\n    # return p\n    ps = []\n    for q in z:\n        ps.append(Panel(Pretty(inspect(getattr(obj, q), methods=True, docs=True))))\n\n\nsearch(np.random, \"normal\")\n\n╭─ <built-in method lognormal of numpy.random.mtrand.RandomState object at 0x10c627840> ─╮\n│ def RandomState.lognormal(...)                                                         │\n│                                                                                        │\n│ lognormal(mean=0.0, sigma=1.0, size=None)                                              │\n│                                                                                        │\n│ 29 attribute(s) not shown. Run inspect(inspect) for options.                           │\n╰────────────────────────────────────────────────────────────────────────────────────────╯\n\n\n\n╭─ <built-in method multivariate_normal of numpy.random.mtrand.RandomState object at 0x10c627840> ─╮\n│ def RandomState.multivariate_normal(...)                                                         │\n│                                                                                                  │\n│ multivariate_normal(mean, cov, size=None, check_valid='warn', tol=1e-8)                          │\n│                                                                                                  │\n│ 29 attribute(s) not shown. Run inspect(inspect) for options.                                     │\n╰──────────────────────────────────────────────────────────────────────────────────────────────────╯\n\n\n\n╭─ <built-in method normal of numpy.random.mtrand.RandomState object at 0x10c627840> ─╮\n│ def RandomState.normal(...)                                                         │\n│                                                                                     │\n│ normal(loc=0.0, scale=1.0, size=None)                                               │\n│                                                                                     │\n│ 29 attribute(s) not shown. Run inspect(inspect) for options.                        │\n╰─────────────────────────────────────────────────────────────────────────────────────╯\n\n\n\n╭─ <built-in method standard_normal of numpy.random.mtrand.RandomState object at 0x10c627840> ─╮\n│ def RandomState.standard_normal(...)                                                         │\n│                                                                                              │\n│ standard_normal(size=None)                                                                   │\n│                                                                                              │\n│ 29 attribute(s) not shown. Run inspect(inspect) for options.                                 │\n╰──────────────────────────────────────────────────────────────────────────────────────────────╯\n\n\n\n\ngetattr(pd.DataFrame().values, \"tolist\")\n\n<function ndarray.tolist>\n\n\n\npd.DataFrame.to\n\n\n\n\n\n  \n    \n      \n    \n  \n  \n  \n\n\n\n\n\ndf = pd.DataFrame()\nsearch(df.values, \"list\")\n\n╭───────────────────────────────────────────── Searching for {query} ─────────────────────────────────────────────╮\n│ ['tolist']                                                                                                      │\n╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯\n\n\n\n\nsearch(pd.DataFrame, \"to\")\n\n╭─────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮\n│ [                                                                                                               │\n│     '_constructor',                                                                                             │\n│     '_constructor_sliced',                                                                                      │\n│     '_to_dict_of_blocks',                                                                                       │\n│     'kurtosis',                                                                                                 │\n│     'to_clipboard',                                                                                             │\n│     'to_csv',                                                                                                   │\n│     'to_dict',                                                                                                  │\n│     'to_excel',                                                                                                 │\n│     'to_feather',                                                                                               │\n│     'to_gbq',                                                                                                   │\n│     'to_hdf',                                                                                                   │\n│     'to_html',                                                                                                  │\n│     'to_json',                                                                                                  │\n│     'to_latex',                                                                                                 │\n│     'to_markdown',                                                                                              │\n│     'to_numpy',                                                                                                 │\n│     'to_orc',                                                                                                   │\n│     'to_parquet',                                                                                               │\n│     'to_period',                                                                                                │\n│     'to_pickle',                                                                                                │\n│     'to_records',                                                                                               │\n│     'to_sql',                                                                                                   │\n│     'to_stata',                                                                                                 │\n│     'to_string',                                                                                                │\n│     'to_timestamp',                                                                                             │\n│     'to_xarray',                                                                                                │\n│     'to_xml'                                                                                                    │\n│ ]                                                                                                               │\n╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯\n\n\n\n\nq = \"normal\"\n\n\nnp.random.normal\n\n<function RandomState.normal>\n\n\n\nfrom rich import inspect\n\ninspect(eval(f\"np.random.{q}\"), methods=True, all=True)\n\n╭─────────────── <built-in method normal of numpy.random.mtrand.RandomState object at 0x10c627840> ───────────────╮\n│ def RandomState.normal(...)                                                                                     │\n│                                                                                                                 │\n│ normal(loc=0.0, scale=1.0, size=None)                                                                           │\n│                                                                                                                 │\n│            __doc__ = '\\n        normal(loc=0.0, scale=1.0, size=None)\\n\\n        Draw random samples from a     │\n│                      normal (Gaussian) distribution.\\n\\n        The probability density function of the normal  │\n│                      distribution, first\\n        derived by De Moivre and 200 years later by both Gauss and    │\n│                      Laplace\\n        independently [2]_, is often called the bell curve because of\\n           │\n│                      its characteristic shape (see the example below).\\n\\n        The normal distributions      │\n│                      occurs often in nature.  For example, it\\n        describes the commonly occurring         │\n│                      distribution of samples influenced\\n        by a large number of tiny, random              │\n│                      disturbances, each with its own\\n        unique distribution [2]_.\\n\\n        .. note::\\n  │\n│                      New code should use the ``normal`` method of a ``default_rng()``\\n            instance     │\n│                      instead; please see the :ref:`random-quick-start`.\\n\\n        Parameters\\n                 │\n│                      ----------\\n        loc : float or array_like of floats\\n            Mean (\"centre\") of    │\n│                      the distribution.\\n        scale : float or array_like of floats\\n            Standard     │\n│                      deviation (spread or \"width\") of the distribution. Must be\\n            non-negative.\\n    │\n│                      size : int or tuple of ints, optional\\n            Output shape.  If the given shape is,   │\n│                      e.g., ``(m, n, k)``, then\\n            ``m * n * k`` samples are drawn.  If size is        │\n│                      ``None`` (default),\\n            a single value is returned if ``loc`` and ``scale`` are   │\n│                      both scalars.\\n            Otherwise, ``np.broadcast(loc, scale).size`` samples are        │\n│                      drawn.\\n\\n        Returns\\n        -------\\n        out : ndarray or scalar\\n              │\n│                      Drawn samples from the parameterized normal distribution.\\n\\n        See Also\\n            │\n│                      --------\\n        scipy.stats.norm : probability density function, distribution or\\n       │\n│                      cumulative density function, etc.\\n        random.Generator.normal: which should be used   │\n│                      for new code.\\n\\n        Notes\\n        -----\\n        The probability density for the     │\n│                      Gaussian distribution is\\n\\n        .. math:: p(x) = \\\\frac{1}{\\\\sqrt{ 2 \\\\pi \\\\sigma^2    │\n│                      }}\\n                         e^{ - \\\\frac{ (x - \\\\mu)^2 } {2 \\\\sigma^2} },\\n\\n             │\n│                      where :math:`\\\\mu` is the mean and :math:`\\\\sigma` the standard\\n        deviation. The    │\n│                      square of the standard deviation, :math:`\\\\sigma^2`,\\n        is called the variance.\\n\\n  │\n│                      The function has its peak at the mean, and its \"spread\" increases with\\n        the        │\n│                      standard deviation (the function reaches 0.607 times its maximum at\\n        :math:`x +    │\n│                      \\\\sigma` and :math:`x - \\\\sigma` [2]_).  This implies that\\n        normal is more likely  │\n│                      to return samples lying close to the mean, rather\\n        than those far away.\\n\\n        │\n│                      References\\n        ----------\\n        .. [1] Wikipedia, \"Normal distribution\",\\n         │\n│                      https://en.wikipedia.org/wiki/Normal_distribution\\n        .. [2] P. R. Peebles Jr.,       │\n│                      \"Central Limit Theorem\" in \"Probability,\\n               Random Variables and Random       │\n│                      Signal Principles\", 4th ed., 2001,\\n               pp. 51, 51, 125.\\n\\n        Examples\\n  │\n│                      --------\\n        Draw samples from the distribution:\\n\\n        >>> mu, sigma = 0, 0.1 #  │\n│                      mean and standard deviation\\n        >>> s = np.random.normal(mu, sigma, 1000)\\n\\n         │\n│                      Verify the mean and the variance:\\n\\n        >>> abs(mu - np.mean(s))\\n        0.0  # may  │\n│                      vary\\n\\n        >>> abs(sigma - np.std(s, ddof=1))\\n        0.1  # may vary\\n\\n            │\n│                      Display the histogram of the samples, along with\\n        the probability density          │\n│                      function:\\n\\n        >>> import matplotlib.pyplot as plt\\n        >>> count, bins, ignored │\n│                      = plt.hist(s, 30, density=True)\\n        >>> plt.plot(bins, 1/(sigma * np.sqrt(2 * np.pi)) │\n│                      *\\n        ...                np.exp( - (bins - mu)**2 / (2 * sigma**2) ),\\n        ...    │\n│                      linewidth=2, color=\\'r\\')\\n        >>> plt.show()\\n\\n        Two-by-four array of samples  │\n│                      from N(3, 6.25):\\n\\n        >>> np.random.normal(3, 2.5, size=(2, 4))\\n                    │\n│                      array([[-4.49401501,  4.00950034, -1.81814867,  7.29718677],   # random\\n               [  │\n│                      0.39924804,  4.68456316,  4.99394529,  4.84057254]])  # random\\n\\n        '                │\n│         __module__ = None                                                                                       │\n│           __name__ = 'normal'                                                                                   │\n│       __qualname__ = 'RandomState.normal'                                                                       │\n│           __self__ = RandomState(MT19937) at 0x10C627840                                                        │\n│ __text_signature__ = None                                                                                       │\n│           __call__ = def __call__(*args, **kwargs): Call self as a function.                                    │\n│          __class__ = class __class__():                                                                         │\n│        __delattr__ = def __delattr__(name, /): Implement delattr(self, name).                                   │\n│            __dir__ = def __dir__(): Default dir() implementation.                                               │\n│             __eq__ = def __eq__(value, /): Return self==value.                                                  │\n│         __format__ = def __format__(format_spec, /): Default object formatter.                                  │\n│             __ge__ = def __ge__(value, /): Return self>=value.                                                  │\n│   __getattribute__ = def __getattribute__(name, /): Return getattr(self, name).                                 │\n│             __gt__ = def __gt__(value, /): Return self>value.                                                   │\n│           __hash__ = def __hash__(): Return hash(self).                                                         │\n│           __init__ = def __init__(*args, **kwargs): Initialize self.  See help(type(self)) for accurate         │\n│                      signature.                                                                                 │\n│  __init_subclass__ = def __init_subclass__(...) This method is called when a class is subclassed.               │\n│             __le__ = def __le__(value, /): Return self<=value.                                                  │\n│             __lt__ = def __lt__(value, /): Return self<value.                                                   │\n│             __ne__ = def __ne__(value, /): Return self!=value.                                                  │\n│            __new__ = def __new__(*args, **kwargs): Create and return a new object.  See help(type) for accurate │\n│                      signature.                                                                                 │\n│         __reduce__ = def __reduce__(...) Helper for pickle.                                                     │\n│      __reduce_ex__ = def __reduce_ex__(protocol, /): Helper for pickle.                                         │\n│           __repr__ = def __repr__(): Return repr(self).                                                         │\n│        __setattr__ = def __setattr__(name, value, /): Implement setattr(self, name, value).                     │\n│         __sizeof__ = def __sizeof__(): Size of object in memory, in bytes.                                      │\n│            __str__ = def __str__(): Return str(self).                                                           │\n│   __subclasshook__ = def __subclasshook__(...) Abstract classes can override this to customize issubclass().    │\n╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯\n\n\n\n\ninspect(inspect)\n\n╭─────────────────────────────────────── <function inspect at 0x10f3fc550> ───────────────────────────────────────╮\n│ def inspect(obj: Any, *, console: Optional[ForwardRef('Console')] = None, title: Optional[str] = None, help:    │\n│ bool = False, methods: bool = False, docs: bool = True, private: bool = False, dunder: bool = False, sort: bool │\n│ = True, all: bool = False, value: bool = True) -> None:                                                         │\n│                                                                                                                 │\n│ Inspect any Python object.                                                                                      │\n│                                                                                                                 │\n│ * inspect(<OBJECT>) to see summarized info.                                                                     │\n│ * inspect(<OBJECT>, methods=True) to see methods.                                                               │\n│ * inspect(<OBJECT>, help=True) to see full (non-abbreviated) help.                                              │\n│ * inspect(<OBJECT>, private=True) to see private attributes (single underscore).                                │\n│ * inspect(<OBJECT>, dunder=True) to see attributes beginning with double underscore.                            │\n│ * inspect(<OBJECT>, all=True) to see all attributes.                                                            │\n│                                                                                                                 │\n│ Args:                                                                                                           │\n│     obj (Any): An object to inspect.                                                                            │\n│     title (str, optional): Title to display over inspect result, or None use type. Defaults to None.            │\n│     help (bool, optional): Show full help text rather than just first paragraph. Defaults to False.             │\n│     methods (bool, optional): Enable inspection of callables. Defaults to False.                                │\n│     docs (bool, optional): Also render doc strings. Defaults to True.                                           │\n│     private (bool, optional): Show private attributes (beginning with underscore). Defaults to False.           │\n│     dunder (bool, optional): Show attributes starting with double underscore. Defaults to False.                │\n│     sort (bool, optional): Sort attributes alphabetically. Defaults to True.                                    │\n│     all (bool, optional): Show all attributes. Defaults to False.                                               │\n│     value (bool, optional): Pretty print value. Defaults to True.                                               │\n│                                                                                                                 │\n│ 35 attribute(s) not shown. Run inspect(inspect) for options.                                                    │\n╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯\n\n\n\n\nfrom dataclasses import dataclass\n\n\n@dataclass\nclass InventoryItem:\n    \"\"\"Class for keeping track of an item in inventory.\"\"\"\n\n    name: str\n    unit_price: float\n    quantity_on_hand: int = 0\n\n\nc = InventoryItem(\"A\", 20)\n\n\nc\n\nInventoryItem(name='A', unit_price=20, quantity_on_hand=0)\n\n\n\nclass InventoryItemOld:\n    def __init__(self, name: str, unit_price: float, \n                 quantity_on_hand: int = 0):\n        self.name = name\n        self.unit_price = unit_price\n        self.quantity_on_hand = quantity_on_hand\n\n\nd = InventoryItemOld(\"A\", 2)\nd\n\n<__main__.InventoryItemOld at 0x166340430>\n\n\n\ndef greeting(name: str) -> str:\n    return 'Hello ' + name\n\n\ngreeting(\"Abc\")\n\n'Hello Abc'\n\n\n\ngreeting(10)\n\nTypeError: can only concatenate str (not \"int\") to str"
  },
  {
    "objectID": "notebooks/posts/1d-cnn.html",
    "href": "notebooks/posts/1d-cnn.html",
    "title": "1d CNN",
    "section": "",
    "text": "import torch\nimport torch.nn as nn\nimport torch.nn.functional as F\nimport torch.optim as optim\n\nimport numpy as np\nimport matplotlib.pyplot as plt\n\nfrom torch.utils.data import DataLoader, TensorDataset\nimport seaborn as sns\n\n%matplotlib inline\n%config InlineBackend.figure_format = 'retina'\n\n# Set random seed for reproducibility\ntorch.manual_seed(0)\n\n# Torch version\ntorch.__version__\n\n'2.0.0+cu118'\n\n\n\n# Simple 1d dataset\n\ny = torch.Tensor([1, 1, 1, 0, -1, -1, -1, 0, 1, 1, 1, 1, 0, -1, -1, -1, 0, 1, 1, 1])\nx = torch.arange(0, len(y))\n\nplt.plot(x, y, 'o-')\n\n\n\n\n\n# Filter 1 (detect silence)\n\nwith torch.no_grad():\n    f1 = nn.Conv1d(1, 1, 3, padding=1)\n    f1.weight.data = torch.Tensor([[[-1, -1, -1]]])\n    f1.bias.data = torch.Tensor([0])\n    y1 = F.relu(f1(y.view(1, 1, -1))).view(-1)\n\nplt.plot(x, y, 'o-', label='original')\nplt.plot(x, y1, 'o-', label='filtered f1 (silence)')\nplt.legend()\n\n<matplotlib.legend.Legend at 0x7efecfcccb80>\n\n\n\n\n\n\n# Filter 2 (detect falling edge)\n\nwith torch.no_grad():\n    f2 = nn.Conv1d(1, 1, 3, padding=1)\n    f2.weight.data = torch.Tensor([[[1, 0, -1]]])\n    f2.bias.data = torch.Tensor([0])\n    y2 = F.relu(f2(y.view(1, 1, -1))).view(-1)\n\nplt.plot(x, y, 'o-', label='original')\nplt.plot(x, y2, 'o-', label='filtered f2 (falling edge)')\nplt.legend()\n\n<matplotlib.legend.Legend at 0x7efecfbc7250>\n\n\n\n\n\n\n# Filter 3 (detect rising edge)\n\nwith torch.no_grad():\n    f3 = nn.Conv1d(1, 1, 3, padding=1)\n    f3.weight.data = torch.Tensor([[[-1, 0, 1]]])\n    f3.bias.data = torch.Tensor([0])\n    y3 = F.relu(f3(y.view(1, 1, -1))).view(-1)\n\nplt.plot(x, y, 'o-', label='original')\nplt.plot(x, y3, 'o-', label='filtered f3 (rising edge)')\nplt.legend()\n\n<matplotlib.legend.Legend at 0x7efecfbb88e0>\n\n\n\n\n\n\n# Filter 4 (detect high amplitude)\n\nwith torch.no_grad():\n    f4 = nn.Conv1d(1, 1, 3, padding=1)\n    f4.weight.data = torch.Tensor([[[1, 1, 1]]])\n    f4.bias.data = torch.Tensor([0])\n    y4 = F.relu(f4(y.view(1, 1, -1))).view(-1)\n\nplt.plot(x, y, 'o-', label='original') \nplt.plot(x, y4, 'o-', label='filtered f4 (high amplitude)')\nplt.legend()\n\n<matplotlib.legend.Legend at 0x7efecfb2dfd0>"
  },
  {
    "objectID": "notebooks/posts/svm-rbf.html",
    "href": "notebooks/posts/svm-rbf.html",
    "title": "SVM with RBF kernel",
    "section": "",
    "text": "import numpy as np\nimport pandas as pd\nimport matplotlib.pyplot as plt\nfrom matplotlib import cm\n%matplotlib inline\n\nLet us now understand how the gamma parameter works. For that, we will look at a different dataset\n\nfrom sklearn import datasets\n\niris = datasets.load_iris()\nX = iris.data\ny = iris.target\n\nX = X[y != 0, :2]\ny = y[y != 0]\n\n\nplt.scatter(X[:, 0], X[:, 1], c=y, zorder=10, cmap=plt.cm.Paired,\n                edgecolor='k', s=100)\n\n<matplotlib.collections.PathCollection at 0x7f01db469af0>\n\n\n\n\n\n\nfrom sklearn import svm\n\n\ndef plot_contour(clf, X, y):\n    plt.scatter(X[:, 0], X[:, 1], c=y, zorder=10, cmap=plt.cm.Paired,\n                edgecolor='k', s=100)\n\n\n    plt.axis('tight')\n    x_min = X[:, 0].min()-1\n    x_max = X[:, 0].max()+1\n    y_min = X[:, 1].min()-1\n    y_max = X[:, 1].max()+1\n\n    XX, YY = np.mgrid[x_min:x_max:200j, y_min:y_max:200j]\n    Z = clf.decision_function(np.c_[XX.ravel(), YY.ravel()])\n\n    # Put the result into a color plot\n    Z = Z.reshape(XX.shape)\n    plt.pcolormesh(XX, YY, Z > 0, cmap=plt.cm.Paired, alpha=0.2)\n\n    plt.contour(XX, YY, Z, colors=['k', 'k', 'k'],\n                linestyles=['--', '-', '--'], levels=[-.5, 0, .5])\n\n\n# Fit linear SVM\nclf = svm.SVC(kernel='linear')\nclf.fit(X, y)\nplot_contour(clf, X, y)\n\n\n\n\n\n# Fit polynomial SVM of degree 2, 3, 4\n\nfor degree in range(3, 7):\n    clf = svm.SVC(kernel='poly', degree=degree)\n    clf.fit(X, y)\n    plt.figure()\n    plt.title('degree = {}'.format(degree))\n    plot_contour(clf, X, y)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nX_train = X\ny_train = y\nkernel = 'rbf'\n# Store kernel matrix\nkms = []\nfor fig_num, gamma in enumerate([0.01, 0.1, 1, 10, 100, 1000]):\n    clf = svm.SVC(kernel=kernel, gamma=gamma)\n    clf.fit(X_train, y_train)\n\n    plt.figure(fig_num)\n    plt.clf()\n \n    plt.title(\"gamma = {}\".format(gamma))\n    plot_contour(clf, X_train, y_train)"
  },
  {
    "objectID": "notebooks/posts/parametric-non-parametric.html",
    "href": "notebooks/posts/parametric-non-parametric.html",
    "title": "Parametric v/s Non-Parametric",
    "section": "",
    "text": "import numpy as np\nimport matplotlib.pyplot as plt\nimport pandas as pd\nfrom sklearn.linear_model import LinearRegression, LogisticRegression\nfrom sklearn.neighbors import KNeighborsClassifier, KNeighborsRegressor\nfrom sklearn.tree import DecisionTreeClassifier, DecisionTreeRegressor\nfrom sklearn.neural_network import MLPClassifier, MLPRegressor\n\n%matplotlib inline\n%config InlineBackend.figure_format = 'retina'\nAim:\nGiven Dataset (X, y), learn a function f that maps X to y, i.e. y = f(X).\nWe will consider two cases: - Parametric: f is a function of a fixed number of parameters, e.g. f(x) = ax + b - Non-parametric: f is a function of number of parameters that grows with the size of the dataset."
  },
  {
    "objectID": "notebooks/posts/parametric-non-parametric.html#learnt-functions",
    "href": "notebooks/posts/parametric-non-parametric.html#learnt-functions",
    "title": "Parametric v/s Non-Parametric",
    "section": "Learnt functions",
    "text": "Learnt functions\n\nLogistic Regression\nlogits = X @ w + b\nprob = sigmoid(logits)\ny_pred = prob > 0.5\n\n\nDecision Tree\n\nfrom sklearn.tree import export_graphviz\nimport graphviz\n\ndot_data = export_graphviz(dt, out_file=None, feature_names=['x1', 'x2'], class_names=['0', '1'], filled=True, rounded=True, special_characters=True)\ngraph = graphviz.Source(dot_data)\ngraph\n\n\n\n\n\n\nMLP\nlogits = nn.predict(X)\nprobs = sigmoid(logits)\ny_pred = probs>0.5\n\n\nKNN\nif X1 < 0.5 and X2 < 0.5:\n    y = 0\nelif X1 < 0.5 and X2 >= 0.5:\n    ...\n\n# Sophisticated dataset with 2 classes\n\nfrom sklearn.datasets import make_blobs\n\nX, y = make_blobs(n_samples=100, centers=2, n_features=2, random_state=0, cluster_std=2)\n\n# Plot the dataset\n\nplt.scatter(X[:, 0], X[:, 1], c=y, cmap='viridis')\n\n<matplotlib.collections.PathCollection at 0x7f7a011d2d30>\n\n\n\n\n\n\nlr = LogisticRegression()\nknn = KNeighborsClassifier(n_neighbors=1)\ndt = DecisionTreeClassifier()\nnn = MLPClassifier(hidden_layer_sizes=(100, 100), activation='logistic', max_iter=10000)\n\n# Plot the decision boundaries\n\nplt.figure(figsize=(12, 8))\n\nfor i, model in enumerate([lr, knn, dt, nn]):\n    plt.subplot(2, 2, i + 1)\n    model.fit(X, y)\n    plot_decision_boundary(model, X, y)\n    plt.title(model.__class__.__name__)\n\n\n\n\n\ndot_data = export_graphviz(dt, out_file=None, feature_names=['x1', 'x2'], class_names=['0', '1'], filled=True, rounded=True, special_characters=True)\ngraph = graphviz.Source(dot_data)\ngraph\n\n\n\n\n\ndt.get_depth(), dt.get_n_leaves()\n\n(9, 24)\n\n\n\nlr.coef_\n\narray([[ 0.19758375, -0.7298237 ]])\n\n\n\n# Now, more noise\n\nX, y = make_blobs(n_samples=100, centers=2, n_features=2, random_state=0, cluster_std=5)\n\n# Plot the dataset\n\nplt.scatter(X[:, 0], X[:, 1], c=y, cmap='viridis')\n\n<matplotlib.collections.PathCollection at 0x7f772abcffa0>\n\n\n\n\n\n\nlr = LogisticRegression()\nknn = KNeighborsClassifier(n_neighbors=1)\ndt = DecisionTreeClassifier()\nnn = MLPClassifier(hidden_layer_sizes=(100, 100), activation='logistic', max_iter=10000)\n\n# Plot the decision boundaries\n\nplt.figure(figsize=(12, 8))\n\nfor i, model in enumerate([lr, knn, dt, nn]):\n    plt.subplot(2, 2, i + 1)\n    model.fit(X, y)\n    plot_decision_boundary(model, X, y)\n    plt.title(model.__class__.__name__)\n\n\n\n\n\ndot_data = export_graphviz(dt, out_file=None, feature_names=['x1', 'x2'], class_names=['0', '1'], filled=True, rounded=True, special_characters=True)\ngraph = graphviz.Source(dot_data)\ngraph\n\n\n\n\n\ndt.get_depth(), dt.get_n_leaves()\n\n(11, 36)\n\n\n\nlr.coef_\n\narray([[ 0.03933004, -0.10323595]])"
  },
  {
    "objectID": "notebooks/posts/taylor.html",
    "href": "notebooks/posts/taylor.html",
    "title": "Taylor Series",
    "section": "",
    "text": "import jax.numpy as jnp\nfrom jax import random, jit, vmap, grad, jacfwd, jacrev, hessian, value_and_grad\nimport matplotlib.pyplot as plt\n%matplotlib inline\n%config InlineBackend.figure_format = 'retina'\n\n\n# Define the function to be approximated\n\ndef f(x):\n    return jnp.sin(x)\n\n\n# Plot the function\n\nx = jnp.linspace(-jnp.pi, jnp.pi, 100)\nplt.plot(x, f(x))\n\n\n\n\n\n# First order Taylor approximation for f(x) at x = 0\n\ndef taylor1(f, x, x0=0.):\n    return f(x0) + grad(f)(x0) * (x - x0)\n\n\n# Plot the Taylor approximation\n\nplt.plot(x, f(x), label='f(x)')\nplt.plot(x, taylor1(f, x), label='Taylor approximation')\n\n\n\n\n\n# factorial function in JAX\n\ndef factorial(n):\n    return jnp.prod(jnp.arange(1, n + 1))\n\n\n# Find the nth order Taylor approximation for f(x) at x = 0\n\ndef taylor(f, x, n, x0=0.):\n    grads = {0:f}\n    output = f(x0)\n    for i in range(1, n+1):\n        grads[i] = grad(grads[i-1])\n        output += grads[i](x0) * (x - x0)**i / factorial(i)\n    return output\n\n\nplt.plot(x, f(x), label='f(x)', lw=5)\nplt.plot(x, taylor(f, x, 1), label='Taylor approximation, n=1')\nplt.plot(x, taylor(f, x, 3), label='Taylor approximation, n=3')\nplt.plot(x, taylor(f, x, 5), label='Taylor approximation, n=5')\nplt.legend()\n\n<matplotlib.legend.Legend at 0x1aea5ea90>\n\n\n\n\n\n\nx = jnp.linspace(-4, 4, 100)\n\ndef g(x):\n    return x**2\n\nplt.plot(x, g(x), label='g(x)', lw=4, alpha=0.5)\nplt.plot(x, taylor(g, x, 1), label='Taylor approximation, n=1')\nplt.plot(x, taylor(g, x, 2), label='Taylor approximation, n=3', ls='--')\n\n\n\n\n\nplt.plot(x, g(x), label='g(x)', lw=4, alpha=0.5)\nplt.plot(x, taylor(g, x, 1, 4.1), label='Taylor approximation, n=1')\nplt.plot(x, taylor(g, x, 2, 4.1), label='Taylor approximation, n=3', ls='--')\nplt.ylim((-2, 20))\n\n(-2.0, 20.0)"
  },
  {
    "objectID": "notebooks/posts/log-sum-exp.html",
    "href": "notebooks/posts/log-sum-exp.html",
    "title": "ES654",
    "section": "",
    "text": "import torch\n\n\nxs = torch.linspace(0.01, 1, 1000)\nxs\n\ntensor([0.0100, 0.0110, 0.0120, 0.0130, 0.0140, 0.0150, 0.0159, 0.0169, 0.0179,\n        0.0189, 0.0199, 0.0209, 0.0219, 0.0229, 0.0239, 0.0249, 0.0259, 0.0268,\n        0.0278, 0.0288, 0.0298, 0.0308, 0.0318, 0.0328, 0.0338, 0.0348, 0.0358,\n        0.0368, 0.0377, 0.0387, 0.0397, 0.0407, 0.0417, 0.0427, 0.0437, 0.0447,\n        0.0457, 0.0467, 0.0477, 0.0486, 0.0496, 0.0506, 0.0516, 0.0526, 0.0536,\n        0.0546, 0.0556, 0.0566, 0.0576, 0.0586, 0.0595, 0.0605, 0.0615, 0.0625,\n        0.0635, 0.0645, 0.0655, 0.0665, 0.0675, 0.0685, 0.0695, 0.0705, 0.0714,\n        0.0724, 0.0734, 0.0744, 0.0754, 0.0764, 0.0774, 0.0784, 0.0794, 0.0804,\n        0.0814, 0.0823, 0.0833, 0.0843, 0.0853, 0.0863, 0.0873, 0.0883, 0.0893,\n        0.0903, 0.0913, 0.0923, 0.0932, 0.0942, 0.0952, 0.0962, 0.0972, 0.0982,\n        0.0992, 0.1002, 0.1012, 0.1022, 0.1032, 0.1041, 0.1051, 0.1061, 0.1071,\n        0.1081, 0.1091, 0.1101, 0.1111, 0.1121, 0.1131, 0.1141, 0.1150, 0.1160,\n        0.1170, 0.1180, 0.1190, 0.1200, 0.1210, 0.1220, 0.1230, 0.1240, 0.1250,\n        0.1259, 0.1269, 0.1279, 0.1289, 0.1299, 0.1309, 0.1319, 0.1329, 0.1339,\n        0.1349, 0.1359, 0.1368, 0.1378, 0.1388, 0.1398, 0.1408, 0.1418, 0.1428,\n        0.1438, 0.1448, 0.1458, 0.1468, 0.1477, 0.1487, 0.1497, 0.1507, 0.1517,\n        0.1527, 0.1537, 0.1547, 0.1557, 0.1567, 0.1577, 0.1586, 0.1596, 0.1606,\n        0.1616, 0.1626, 0.1636, 0.1646, 0.1656, 0.1666, 0.1676, 0.1686, 0.1695,\n        0.1705, 0.1715, 0.1725, 0.1735, 0.1745, 0.1755, 0.1765, 0.1775, 0.1785,\n        0.1795, 0.1805, 0.1814, 0.1824, 0.1834, 0.1844, 0.1854, 0.1864, 0.1874,\n        0.1884, 0.1894, 0.1904, 0.1914, 0.1923, 0.1933, 0.1943, 0.1953, 0.1963,\n        0.1973, 0.1983, 0.1993, 0.2003, 0.2013, 0.2023, 0.2032, 0.2042, 0.2052,\n        0.2062, 0.2072, 0.2082, 0.2092, 0.2102, 0.2112, 0.2122, 0.2132, 0.2141,\n        0.2151, 0.2161, 0.2171, 0.2181, 0.2191, 0.2201, 0.2211, 0.2221, 0.2231,\n        0.2241, 0.2250, 0.2260, 0.2270, 0.2280, 0.2290, 0.2300, 0.2310, 0.2320,\n        0.2330, 0.2340, 0.2350, 0.2359, 0.2369, 0.2379, 0.2389, 0.2399, 0.2409,\n        0.2419, 0.2429, 0.2439, 0.2449, 0.2459, 0.2468, 0.2478, 0.2488, 0.2498,\n        0.2508, 0.2518, 0.2528, 0.2538, 0.2548, 0.2558, 0.2568, 0.2577, 0.2587,\n        0.2597, 0.2607, 0.2617, 0.2627, 0.2637, 0.2647, 0.2657, 0.2667, 0.2677,\n        0.2686, 0.2696, 0.2706, 0.2716, 0.2726, 0.2736, 0.2746, 0.2756, 0.2766,\n        0.2776, 0.2786, 0.2795, 0.2805, 0.2815, 0.2825, 0.2835, 0.2845, 0.2855,\n        0.2865, 0.2875, 0.2885, 0.2895, 0.2905, 0.2914, 0.2924, 0.2934, 0.2944,\n        0.2954, 0.2964, 0.2974, 0.2984, 0.2994, 0.3004, 0.3014, 0.3023, 0.3033,\n        0.3043, 0.3053, 0.3063, 0.3073, 0.3083, 0.3093, 0.3103, 0.3113, 0.3123,\n        0.3132, 0.3142, 0.3152, 0.3162, 0.3172, 0.3182, 0.3192, 0.3202, 0.3212,\n        0.3222, 0.3232, 0.3241, 0.3251, 0.3261, 0.3271, 0.3281, 0.3291, 0.3301,\n        0.3311, 0.3321, 0.3331, 0.3341, 0.3350, 0.3360, 0.3370, 0.3380, 0.3390,\n        0.3400, 0.3410, 0.3420, 0.3430, 0.3440, 0.3450, 0.3459, 0.3469, 0.3479,\n        0.3489, 0.3499, 0.3509, 0.3519, 0.3529, 0.3539, 0.3549, 0.3559, 0.3568,\n        0.3578, 0.3588, 0.3598, 0.3608, 0.3618, 0.3628, 0.3638, 0.3648, 0.3658,\n        0.3668, 0.3677, 0.3687, 0.3697, 0.3707, 0.3717, 0.3727, 0.3737, 0.3747,\n        0.3757, 0.3767, 0.3777, 0.3786, 0.3796, 0.3806, 0.3816, 0.3826, 0.3836,\n        0.3846, 0.3856, 0.3866, 0.3876, 0.3886, 0.3895, 0.3905, 0.3915, 0.3925,\n        0.3935, 0.3945, 0.3955, 0.3965, 0.3975, 0.3985, 0.3995, 0.4005, 0.4014,\n        0.4024, 0.4034, 0.4044, 0.4054, 0.4064, 0.4074, 0.4084, 0.4094, 0.4104,\n        0.4114, 0.4123, 0.4133, 0.4143, 0.4153, 0.4163, 0.4173, 0.4183, 0.4193,\n        0.4203, 0.4213, 0.4223, 0.4232, 0.4242, 0.4252, 0.4262, 0.4272, 0.4282,\n        0.4292, 0.4302, 0.4312, 0.4322, 0.4332, 0.4341, 0.4351, 0.4361, 0.4371,\n        0.4381, 0.4391, 0.4401, 0.4411, 0.4421, 0.4431, 0.4441, 0.4450, 0.4460,\n        0.4470, 0.4480, 0.4490, 0.4500, 0.4510, 0.4520, 0.4530, 0.4540, 0.4550,\n        0.4559, 0.4569, 0.4579, 0.4589, 0.4599, 0.4609, 0.4619, 0.4629, 0.4639,\n        0.4649, 0.4659, 0.4668, 0.4678, 0.4688, 0.4698, 0.4708, 0.4718, 0.4728,\n        0.4738, 0.4748, 0.4758, 0.4768, 0.4777, 0.4787, 0.4797, 0.4807, 0.4817,\n        0.4827, 0.4837, 0.4847, 0.4857, 0.4867, 0.4877, 0.4886, 0.4896, 0.4906,\n        0.4916, 0.4926, 0.4936, 0.4946, 0.4956, 0.4966, 0.4976, 0.4986, 0.4995,\n        0.5005, 0.5015, 0.5025, 0.5035, 0.5045, 0.5055, 0.5065, 0.5075, 0.5085,\n        0.5095, 0.5105, 0.5114, 0.5124, 0.5134, 0.5144, 0.5154, 0.5164, 0.5174,\n        0.5184, 0.5194, 0.5204, 0.5214, 0.5223, 0.5233, 0.5243, 0.5253, 0.5263,\n        0.5273, 0.5283, 0.5293, 0.5303, 0.5313, 0.5323, 0.5332, 0.5342, 0.5352,\n        0.5362, 0.5372, 0.5382, 0.5392, 0.5402, 0.5412, 0.5422, 0.5432, 0.5441,\n        0.5451, 0.5461, 0.5471, 0.5481, 0.5491, 0.5501, 0.5511, 0.5521, 0.5531,\n        0.5541, 0.5550, 0.5560, 0.5570, 0.5580, 0.5590, 0.5600, 0.5610, 0.5620,\n        0.5630, 0.5640, 0.5650, 0.5659, 0.5669, 0.5679, 0.5689, 0.5699, 0.5709,\n        0.5719, 0.5729, 0.5739, 0.5749, 0.5759, 0.5768, 0.5778, 0.5788, 0.5798,\n        0.5808, 0.5818, 0.5828, 0.5838, 0.5848, 0.5858, 0.5868, 0.5877, 0.5887,\n        0.5897, 0.5907, 0.5917, 0.5927, 0.5937, 0.5947, 0.5957, 0.5967, 0.5977,\n        0.5986, 0.5996, 0.6006, 0.6016, 0.6026, 0.6036, 0.6046, 0.6056, 0.6066,\n        0.6076, 0.6086, 0.6095, 0.6105, 0.6115, 0.6125, 0.6135, 0.6145, 0.6155,\n        0.6165, 0.6175, 0.6185, 0.6195, 0.6205, 0.6214, 0.6224, 0.6234, 0.6244,\n        0.6254, 0.6264, 0.6274, 0.6284, 0.6294, 0.6304, 0.6314, 0.6323, 0.6333,\n        0.6343, 0.6353, 0.6363, 0.6373, 0.6383, 0.6393, 0.6403, 0.6413, 0.6423,\n        0.6432, 0.6442, 0.6452, 0.6462, 0.6472, 0.6482, 0.6492, 0.6502, 0.6512,\n        0.6522, 0.6532, 0.6541, 0.6551, 0.6561, 0.6571, 0.6581, 0.6591, 0.6601,\n        0.6611, 0.6621, 0.6631, 0.6641, 0.6650, 0.6660, 0.6670, 0.6680, 0.6690,\n        0.6700, 0.6710, 0.6720, 0.6730, 0.6740, 0.6750, 0.6759, 0.6769, 0.6779,\n        0.6789, 0.6799, 0.6809, 0.6819, 0.6829, 0.6839, 0.6849, 0.6859, 0.6868,\n        0.6878, 0.6888, 0.6898, 0.6908, 0.6918, 0.6928, 0.6938, 0.6948, 0.6958,\n        0.6968, 0.6977, 0.6987, 0.6997, 0.7007, 0.7017, 0.7027, 0.7037, 0.7047,\n        0.7057, 0.7067, 0.7077, 0.7086, 0.7096, 0.7106, 0.7116, 0.7126, 0.7136,\n        0.7146, 0.7156, 0.7166, 0.7176, 0.7186, 0.7195, 0.7205, 0.7215, 0.7225,\n        0.7235, 0.7245, 0.7255, 0.7265, 0.7275, 0.7285, 0.7295, 0.7305, 0.7314,\n        0.7324, 0.7334, 0.7344, 0.7354, 0.7364, 0.7374, 0.7384, 0.7394, 0.7404,\n        0.7414, 0.7423, 0.7433, 0.7443, 0.7453, 0.7463, 0.7473, 0.7483, 0.7493,\n        0.7503, 0.7513, 0.7523, 0.7532, 0.7542, 0.7552, 0.7562, 0.7572, 0.7582,\n        0.7592, 0.7602, 0.7612, 0.7622, 0.7632, 0.7641, 0.7651, 0.7661, 0.7671,\n        0.7681, 0.7691, 0.7701, 0.7711, 0.7721, 0.7731, 0.7741, 0.7750, 0.7760,\n        0.7770, 0.7780, 0.7790, 0.7800, 0.7810, 0.7820, 0.7830, 0.7840, 0.7850,\n        0.7859, 0.7869, 0.7879, 0.7889, 0.7899, 0.7909, 0.7919, 0.7929, 0.7939,\n        0.7949, 0.7959, 0.7968, 0.7978, 0.7988, 0.7998, 0.8008, 0.8018, 0.8028,\n        0.8038, 0.8048, 0.8058, 0.8068, 0.8077, 0.8087, 0.8097, 0.8107, 0.8117,\n        0.8127, 0.8137, 0.8147, 0.8157, 0.8167, 0.8177, 0.8186, 0.8196, 0.8206,\n        0.8216, 0.8226, 0.8236, 0.8246, 0.8256, 0.8266, 0.8276, 0.8286, 0.8295,\n        0.8305, 0.8315, 0.8325, 0.8335, 0.8345, 0.8355, 0.8365, 0.8375, 0.8385,\n        0.8395, 0.8405, 0.8414, 0.8424, 0.8434, 0.8444, 0.8454, 0.8464, 0.8474,\n        0.8484, 0.8494, 0.8504, 0.8514, 0.8523, 0.8533, 0.8543, 0.8553, 0.8563,\n        0.8573, 0.8583, 0.8593, 0.8603, 0.8613, 0.8623, 0.8632, 0.8642, 0.8652,\n        0.8662, 0.8672, 0.8682, 0.8692, 0.8702, 0.8712, 0.8722, 0.8732, 0.8741,\n        0.8751, 0.8761, 0.8771, 0.8781, 0.8791, 0.8801, 0.8811, 0.8821, 0.8831,\n        0.8841, 0.8850, 0.8860, 0.8870, 0.8880, 0.8890, 0.8900, 0.8910, 0.8920,\n        0.8930, 0.8940, 0.8950, 0.8959, 0.8969, 0.8979, 0.8989, 0.8999, 0.9009,\n        0.9019, 0.9029, 0.9039, 0.9049, 0.9059, 0.9068, 0.9078, 0.9088, 0.9098,\n        0.9108, 0.9118, 0.9128, 0.9138, 0.9148, 0.9158, 0.9168, 0.9177, 0.9187,\n        0.9197, 0.9207, 0.9217, 0.9227, 0.9237, 0.9247, 0.9257, 0.9267, 0.9277,\n        0.9286, 0.9296, 0.9306, 0.9316, 0.9326, 0.9336, 0.9346, 0.9356, 0.9366,\n        0.9376, 0.9386, 0.9395, 0.9405, 0.9415, 0.9425, 0.9435, 0.9445, 0.9455,\n        0.9465, 0.9475, 0.9485, 0.9495, 0.9505, 0.9514, 0.9524, 0.9534, 0.9544,\n        0.9554, 0.9564, 0.9574, 0.9584, 0.9594, 0.9604, 0.9614, 0.9623, 0.9633,\n        0.9643, 0.9653, 0.9663, 0.9673, 0.9683, 0.9693, 0.9703, 0.9713, 0.9723,\n        0.9732, 0.9742, 0.9752, 0.9762, 0.9772, 0.9782, 0.9792, 0.9802, 0.9812,\n        0.9822, 0.9832, 0.9841, 0.9851, 0.9861, 0.9871, 0.9881, 0.9891, 0.9901,\n        0.9911, 0.9921, 0.9931, 0.9941, 0.9950, 0.9960, 0.9970, 0.9980, 0.9990,\n        1.0000])\n\n\n\nxs.prod()\n\ntensor(0.)\n\n\n\nxs = torch.linspace(0.01, 1, 100)\nxs.prod()\n\ntensor(9.3326e-43)\n\n\n\nxs = torch.linspace(0.01, 1, 1000)\na = xs.log().sum()\n\nb = torch.linspace(0.01, 1, 10000).log().sum()\nprint(a, b)\n\ntensor(-954.8404) tensor(-9536.1816)\n\n\n\ntorch.linspace(0.01, 1, 1000).log().sum()\n\ntensor(-954.8404)\n\n\n\ntorch.linspace(0.01, 1, 10000).log().sum()\n\ntensor(-9536.1816)\n\n\n\n# Trivial example to test the binary cross entropy loss\n\ny_true = torch.tensor([0., 1., 1., 0.])\nlogits = torch.tensor([0.1, 0.9, 0.8, 0.2])\n\nloss = torch.nn.BCEWithLogitsLoss()\nloss(logits, y_true)\n\ntensor(0.5637)\n\n\n\n\ny_hat = torch.nn.Sigmoid()(logits)\ny_hat\n\ntensor([0.5250, 0.7109, 0.6900, 0.5498])\n\n\n\n# BCE\n-(y_true * torch.log(y_hat) + (1 - y_true) * torch.log(1 - y_hat)).mean()\n\ntensor(0.5637)\n\n\n\ndef our_bce(y_true, logits):\n    y_hat = torch.nn.Sigmoid()(logits)\n    return -(y_true * torch.log(y_hat) + (1 - y_true) * torch.log(1 - y_hat)).mean()\n\n\n# check that our implementation is correct\nassert our_bce(y_true, logits) == loss(logits, y_true)\n\n\n# Larger logits\nlogits = torch.tensor([100., 200., 300., 400.])\n\nassert our_bce(y_true, logits) == loss(logits, y_true)\n\n\nAssertionError: \n\n\n\ntorch.nn.Sigmoid()(logits)\n\ntensor([1., 1., 1., 1.])\n\n\n\ntorch.exp(logits)/(1 + torch.exp(logits))\n\ntensor([nan, nan, nan, nan])\n\n\n\ntorch.exp(-logits)\n\ntensor([3.7835e-44, 0.0000e+00, 0.0000e+00, 0.0000e+00])\n\n\n\n1/(1+torch.exp(-logits))\n\ntensor([1., 1., 1., 1.])"
  },
  {
    "objectID": "notebooks/posts/kmeans-num-clusters.html",
    "href": "notebooks/posts/kmeans-num-clusters.html",
    "title": "Number of clusters in K-means",
    "section": "",
    "text": "import numpy as np\nimport matplotlib.pyplot as plt\nimport pandas as pd\n\n%matplotlib inline\n%config InlineBackend.figure_format = 'retina'\n\nfrom sklearn.datasets import make_blobs\nfrom sklearn.cluster import KMeans\n\n\n# Create a dataset with K_dataset clusters\nK_dataset = 5\n\nX, y = make_blobs(n_samples=1000, centers=K_dataset, n_features=2, random_state=0)\n\nplt.scatter(X[:, 0], X[:, 1], c=y, s=10, cmap='viridis')\n\n<matplotlib.collections.PathCollection at 0x7f8e151bfbb0>\n\n\n\n\n\n\n# Fit k-means with different number of clusters\nKs = range(1, 10)\nwithin_cluster_sums = {}\nassignments = {}\ncentroids = {}\n\n\nfor K in Ks:\n    kmeans = KMeans(n_clusters=K, random_state=0)\n    kmeans.fit(X)\n    within_cluster_sums[K] = kmeans.inertia_\n    assignments[K] = kmeans.labels_\n    centroids[K] = kmeans.cluster_centers_\n\n# Plot the results\npd.Series(within_cluster_sums).plot(marker='o')\nplt.xlabel('Number of clusters')\nplt.ylabel('Within-cluster sum of squares')\n\nText(0, 0.5, 'Within-cluster sum of squares')\n\n\n\n\n\n\n# Plot assignments\nfig, axes = plt.subplots(3, 3, figsize=(12, 12))\nfor K, ax in zip(Ks, axes.ravel()):\n    ax.scatter(X[:, 0], X[:, 1], c=assignments[K], s=10, cmap='viridis')\n    ax.set_title(f'K={K}')\n    # Mark centroids\n    ax.scatter(centroids[K][:, 0], centroids[K][:, 1], c='red', s=100, alpha=0.5)"
  },
  {
    "objectID": "notebooks/posts/image-completion.html",
    "href": "notebooks/posts/image-completion.html",
    "title": "Image Completion using Matrix Factorization",
    "section": "",
    "text": "import numpy as np\nimport matplotlib.pyplot as plt\nimport pandas as pd\n\n%matplotlib inline\n%config InlineBackend.figure_format = 'retina'\n\nimg = plt.imread('dog.jpg')\nplt.imshow(img)\n\n<matplotlib.image.AxesImage at 0x7f662ba10430>\n\n\n\n\n\n\n# Convert to grayscale\nimg = img.mean(axis=2)\nplt.imshow(img, cmap='gray')\n\n<matplotlib.image.AxesImage at 0x7f662b94cfd0>\n\n\n\n\n\n\nimg = img/255\nplt.imshow(img, cmap='gray')\n\n<matplotlib.image.AxesImage at 0x7f662b0c4d60>\n\n\n\n\n\n\nimg.shape\n\n(1365, 2048)\n\n\n\n# MF code with missing values\nimport torch\nimport torch.nn as nn\nimport torch.nn.functional as F\n\n# INIT WELL!\n\ndef factorize(A, k, niter=100, lr=1e-3):\n    n, m = A.shape\n    # If we do not init well, our solution is poor\n    W = torch.abs(torch.randn(n, k)/10).to(A.device)\n    H = torch.abs(torch.randn(k, m)/10).to(A.device)\n    #W = torch.randn(n, k).to(A.device)\n    #H = torch.randn(k, m).to(A.device)\n    W.requires_grad = True\n    H.requires_grad = True\n\n    # Mask where A is not missing\n    mask = ~torch.isnan(A).to(A.device)\n    print(mask.shape)\n\n    optimizer = torch.optim.Adam([W, H], lr=lr)\n    for i in range(niter):\n        optimizer.zero_grad()\n        Ahat = W @ H\n        loss = F.mse_loss(Ahat[mask], A[mask])\n        loss.backward()\n        optimizer.step()\n        if i % 50 == 0:\n            print(i, loss.item())\n    return W, H\n\n\ndevice = torch.device('cuda' if torch.cuda.is_available() else 'cpu')\n\n\nA = torch.from_numpy(img).float().to(device)\nW, H = factorize(A, 40, niter=500, lr=1e-2)\n\ntorch.Size([1365, 2048])\n0 0.06899718195199966\n50 0.010017945431172848\n100 0.004583133850246668\n150 0.0028046893421560526\n200 0.0018594106659293175\n250 0.001452349592000246\n300 0.00131764798425138\n350 0.001272885361686349\n400 0.0012544193305075169\n450 0.0012451813090592623\n\n\n\nW@H\n\ntensor([[0.2084, 0.2101, 0.2124,  ..., 0.2132, 0.2165, 0.2187],\n        [0.2090, 0.2107, 0.2130,  ..., 0.2131, 0.2163, 0.2185],\n        [0.2092, 0.2109, 0.2132,  ..., 0.2119, 0.2150, 0.2171],\n        ...,\n        [0.3419, 0.3364, 0.3296,  ..., 0.3340, 0.3331, 0.3322],\n        [0.3406, 0.3352, 0.3286,  ..., 0.3410, 0.3400, 0.3391],\n        [0.3399, 0.3348, 0.3284,  ..., 0.3463, 0.3452, 0.3443]],\n       device='cuda:0', grad_fn=<MmBackward0>)\n\n\n\n# Plot reconstructed image\nplt.imshow((W @ H).cpu().detach().numpy(), cmap='gray')\n\n<matplotlib.image.AxesImage at 0x7f655c3dc400>\n\n\n\n\n\n\n# Now, remove a rectangular patch from the image\n\npatch = [600, 600, 900, 1000]\nimg_copy = img.copy()\n\n# NAN the patch region\nimg_copy[patch[0]:patch[2], patch[1]: patch[3]] = np.NaN\nplt.imshow(img_copy,cmap='gray')\n\n<matplotlib.image.AxesImage at 0x7f655c78f0d0>\n\n\n\n\n\n\nA = torch.from_numpy(img_copy).float().to(device)\nW, H = factorize(A, 40, niter=500, lr=1e-2)\n\ntorch.Size([1365, 2048])\n0 0.06408126652240753\n50 0.009235438890755177\n100 0.004174043890088797\n150 0.002459741896018386\n200 0.0016036551678553224\n250 0.0012612321879714727\n300 0.001155527075752616\n350 0.0011186705669388175\n400 0.0011004399275407195\n450 0.001089434023015201\n\n\n\nplt.imshow((W@H).cpu().detach().numpy(), cmap='gray')\n\n<matplotlib.image.AxesImage at 0x7f655c76a730>\n\n\n\n\n\n\nA = torch.from_numpy(img_copy).float().to(device)\nW, H = factorize(A, 200, niter=1000, lr=1e-2)\n\ntorch.Size([1365, 2048])\n0 0.745537519454956\n50 0.014033811166882515\n100 0.006585388910025358\n150 0.0039051645435392857\n200 0.0023795326706022024\n250 0.0014881007373332977\n300 0.0009968953672796488\n350 0.0007123255636543036\n400 0.0005354612949304283\n450 0.0004198925453238189\n500 0.0003404634480830282\n550 0.00028347159968689084\n600 0.0002411041350569576\n650 0.00020870099251624197\n700 0.0001833428832469508\n750 0.00016311286890413612\n800 0.0001467068213969469\n850 0.00013321208825800568\n900 0.00012197894102428108\n950 0.0001125385460909456\n\n\n\nplt.imshow((W@H).cpu().detach().numpy(), cmap='gray')\n\n<matplotlib.image.AxesImage at 0x7f655c6cfd00>\n\n\n\n\n\n\nimport numpy.ma as ma\n\nimg_copy_mar = img.copy()\n# Mask 50% of the values\nmask = np.random.rand(*img_copy_mar.shape) < 0.5\nimg_copy_mar[mask] = np.NaN\n\nplt.imshow(img_copy_mar, cmap='gray', interpolation='none')\n\n<matplotlib.image.AxesImage at 0x7f655c6be8e0>\n\n\n\n\n\n\nA = torch.from_numpy(img_copy_mar).float().to(device)\nW, H = factorize(A, 40, niter=500, lr=1e-2)\n\ntorch.Size([1365, 2048])\n0 0.06749840080738068\n50 0.009521582163870335\n100 0.004410044755786657\n150 0.0026408638805150986\n200 0.00173112191259861\n250 0.0013635847717523575\n300 0.00121410156134516\n350 0.001163529814220965\n400 0.00114450475666672\n450 0.0011350518325343728\n\n\n\nplt.imshow((W@H).cpu().detach().numpy(), cmap='gray')\n\n<matplotlib.image.AxesImage at 0x7f655c628cd0>\n\n\n\n\n\n\nimg_copy_mar = img.copy()\n# Mask 95% of the values\nmask = np.random.rand(*img_copy_mar.shape) < 0.90\nimg_copy_mar[mask] = np.NaN\n\nplt.imshow(img_copy_mar, cmap='gray', interpolation='none')\n\n<matplotlib.image.AxesImage at 0x7f655c59c790>\n\n\n\n\n\n\nA = torch.from_numpy(img_copy_mar).float().to(device)\nW, H = factorize(A, 12, niter=500, lr=1e-2)\n\ntorch.Size([1365, 2048])\n0 0.1652921885251999\n50 0.011481668800115585\n100 0.010577931068837643\n150 0.00767508614808321\n200 0.005586703773587942\n250 0.004488078411668539\n300 0.0038986506406217813\n350 0.003568559419363737\n400 0.0033569824881851673\n450 0.0032061892561614513\n\n\n\nplt.imshow((W@H).cpu().detach().numpy(), cmap='gray')\n\n<matplotlib.image.AxesImage at 0x7f655c4ff3d0>"
  },
  {
    "objectID": "notebooks/posts/pivot-cross.html",
    "href": "notebooks/posts/pivot-cross.html",
    "title": "Pandas tips",
    "section": "",
    "text": "import pandas as pd\nimport numpy as np\n\n\nDataset creation\n\n# Create a DataFrame for whether or not a person plays tennis. \n# It has discrete features and 14 rows.\n\ndf = pd.DataFrame({\n    'Outlook': ['Sunny', 'Sunny', 'Overcast', 'Rain', 'Rain', 'Rain', 'Overcast', 'Sunny', 'Sunny', 'Rain', 'Sunny', 'Overcast', 'Overcast', 'Rain'],\n    'Temperature': ['Hot', 'Hot', 'Hot', 'Mild', 'Cool', 'Cool', 'Cool', 'Mild', 'Cool', 'Mild', 'Mild', 'Mild', 'Hot', 'Mild'],\n    'Humidity': ['High', 'High', 'High', 'High', 'Normal', 'Normal', 'Normal', 'High', 'Normal', 'Normal', 'Normal', 'High', 'Normal', 'High'],\n    'Wind': ['Weak', 'Strong', 'Weak', 'Weak', 'Weak', 'Strong', 'Strong', 'Weak', 'Weak', 'Weak', 'Strong', 'Strong', 'Weak', 'Strong'],\n    'PlayTennis': ['No', 'No', 'Yes', 'Yes', 'Yes', 'No', 'Yes', 'No', 'Yes', 'Yes', 'Yes', 'Yes', 'Yes', 'No']\n})\n\n\n\nCounting values of outcome variable (useful for calculating entropy)\n\nser = df['PlayTennis'].value_counts()\nser\n\nYes    9\nNo     5\nName: PlayTennis, dtype: int64\n\n\n\n\nUsing cross tab to quickly capture the relationship between two variables\n\ndf_out = pd.crosstab(df['Outlook'], df['PlayTennis'])\ndf_out\n\n\n\n\n\n  \n    \n      PlayTennis\n      No\n      Yes\n    \n    \n      Outlook\n      \n      \n    \n  \n  \n    \n      Overcast\n      0\n      4\n    \n    \n      Rain\n      2\n      3\n    \n    \n      Sunny\n      3\n      2\n    \n  \n\n\n\n\n\ndf_out.index, df_out.columns\n\n(Index(['Overcast', 'Rain', 'Sunny'], dtype='object', name='Outlook'),\n Index(['No', 'Yes'], dtype='object', name='PlayTennis'))\n\n\n\ne = df_out.sum(axis=1)\ne\n\nOutlook\nOvercast    4\nRain        5\nSunny       5\ndtype: int64\n\n\n\n# Find the fraction of each row that is a 'Yes' and 'No' for PlayTennis\ndf_out['Yes'] = df_out['Yes'] / e\ndf_out['No'] = df_out['No'] / e\ndf_out\n\n\n\n\n\n  \n    \n      PlayTennis\n      No\n      Yes\n    \n    \n      Outlook\n      \n      \n    \n  \n  \n    \n      Overcast\n      0.0\n      1.0\n    \n    \n      Rain\n      0.4\n      0.6\n    \n    \n      Sunny\n      0.6\n      0.4\n    \n  \n\n\n\n\n\n\nMore efficient cross tabulation (using normalize)\n\npd.crosstab(df['Outlook'], df['PlayTennis'], normalize='index')\n\n\n\n\n\n  \n    \n      PlayTennis\n      No\n      Yes\n    \n    \n      Outlook\n      \n      \n    \n  \n  \n    \n      Overcast\n      0.0\n      1.0\n    \n    \n      Rain\n      0.4\n      0.6\n    \n    \n      Sunny\n      0.6\n      0.4\n    \n  \n\n\n\n\n\n\nUsing pd.groupby()\n\ndf.groupby([\"Outlook\"]).groups\n\n{'Overcast': [2, 6, 11, 12], 'Rain': [3, 4, 5, 9, 13], 'Sunny': [0, 1, 7, 8, 10]}\n\n\n\ndf.groupby([\"Outlook\"]).get_group(\"Sunny\")\n\n\n\n\n\n  \n    \n      \n      Outlook\n      Temperature\n      Humidity\n      Wind\n      PlayTennis\n    \n  \n  \n    \n      0\n      Sunny\n      Hot\n      High\n      Weak\n      No\n    \n    \n      1\n      Sunny\n      Hot\n      High\n      Strong\n      No\n    \n    \n      7\n      Sunny\n      Mild\n      High\n      Weak\n      No\n    \n    \n      8\n      Sunny\n      Cool\n      Normal\n      Weak\n      Yes\n    \n    \n      10\n      Sunny\n      Mild\n      Normal\n      Strong\n      Yes\n    \n  \n\n\n\n\n\ndf.groupby([\"Outlook\"]).get_group(\"Sunny\")[\"PlayTennis\"]\n\n0      No\n1      No\n7      No\n8     Yes\n10    Yes\nName: PlayTennis, dtype: object\n\n\n\ndf.groupby([\"Outlook\"]).get_group(\"Sunny\")[\"PlayTennis\"].value_counts()\n\nNo     3\nYes    2\nName: PlayTennis, dtype: int64\n\n\n\ndf.groupby([\"Outlook\", \"PlayTennis\"]).groups\n\n{('Overcast', 'Yes'): [2, 6, 11, 12], ('Rain', 'No'): [5, 13], ('Rain', 'Yes'): [3, 4, 9], ('Sunny', 'No'): [0, 1, 7], ('Sunny', 'Yes'): [8, 10]}\n\n\n\ndf.groupby([\"Outlook\", \"PlayTennis\"]).get_group((\"Sunny\", \"Yes\"))\n\n\n\n\n\n  \n    \n      \n      Outlook\n      Temperature\n      Humidity\n      Wind\n      PlayTennis\n    \n  \n  \n    \n      8\n      Sunny\n      Cool\n      Normal\n      Weak\n      Yes\n    \n    \n      10\n      Sunny\n      Mild\n      Normal\n      Strong\n      Yes\n    \n  \n\n\n\n\n\ndf.groupby([\"Outlook\", \"PlayTennis\"]).size()\n\nOutlook   PlayTennis\nOvercast  Yes           4\nRain      No            2\n          Yes           3\nSunny     No            3\n          Yes           2\ndtype: int64\n\n\n\ndf.groupby([\"Outlook\", \"PlayTennis\"]).size().index\n\nMultiIndex([('Overcast', 'Yes'),\n            (    'Rain',  'No'),\n            (    'Rain', 'Yes'),\n            (   'Sunny',  'No'),\n            (   'Sunny', 'Yes')],\n           names=['Outlook', 'PlayTennis'])\n\n\n\ndf.groupby([\"Outlook\", \"PlayTennis\"]).size().unstack()\n\n\n\n\n\n  \n    \n      PlayTennis\n      No\n      Yes\n    \n    \n      Outlook\n      \n      \n    \n  \n  \n    \n      Overcast\n      NaN\n      4.0\n    \n    \n      Rain\n      2.0\n      3.0\n    \n    \n      Sunny\n      3.0\n      2.0\n    \n  \n\n\n\n\n\ndf.groupby([\"Outlook\", \"PlayTennis\"]).size().unstack(fill_value=0)\n\n\n\n\n\n  \n    \n      PlayTennis\n      No\n      Yes\n    \n    \n      Outlook\n      \n      \n    \n  \n  \n    \n      Overcast\n      0\n      4\n    \n    \n      Rain\n      2\n      3\n    \n    \n      Sunny\n      3\n      2\n    \n  \n\n\n\n\n\n\nUsing pd.pivot_table\n\npivot_table = df.pivot_table(index='Outlook', columns='PlayTennis', aggfunc='size', fill_value=0)\npivot_table\n\n\n\n\n\n  \n    \n      PlayTennis\n      No\n      Yes\n    \n    \n      Outlook\n      \n      \n    \n  \n  \n    \n      Overcast\n      0\n      4\n    \n    \n      Rain\n      2\n      3\n    \n    \n      Sunny\n      3\n      2\n    \n  \n\n\n\n\n\ndf_out.plot(kind='bar', stacked=True)\n\n<AxesSubplot:xlabel='Outlook'>\n\n\n\n\n\n\ndf_out.plot(kind='bar', stacked=False)\n\n<AxesSubplot:xlabel='Outlook'>"
  },
  {
    "objectID": "notebooks/posts/svm.html",
    "href": "notebooks/posts/svm.html",
    "title": "SVM",
    "section": "",
    "text": "import numpy as np\nimport pandas as pd\nimport matplotlib.pyplot as plt\nfrom matplotlib import cm\n%matplotlib inline\n\n\n# Linearly separable data in 2d\n\n# Generate data\nnp.random.seed(0)\nX = np.r_[np.random.randn(20, 2) - [2, 2], np.random.randn(20, 2) + [2, 2]]\ny = [0] * 20 + [1] * 20\n\n# Plot data\nplt.scatter(X[:, 0], X[:, 1], c=y, cmap=cm.Paired)\n\n<matplotlib.collections.PathCollection at 0x7f8db31dea00>\n\n\n\n\n\n\n# Fit SVM\nfrom sklearn.svm import SVC\nclf = SVC(kernel='linear')\nclf.fit(X, y)\n\n# Plot decision boundary\nw = clf.coef_[0]\na = -w[0] / w[1]\nxx = np.linspace(-5, 5)\nyy = a * xx - (clf.intercept_[0]) / w[1]\nplt.plot(xx, yy, 'k-')\n\n# Plot support vectors\nplt.scatter(clf.support_vectors_[:, 0], clf.support_vectors_[:, 1], s=80, facecolors='none')\n\n# Plot margins\nb = clf.support_vectors_[0]\nyy_down = a * xx + (b[1] - a * b[0])\nb = clf.support_vectors_[-1]\nyy_up = a * xx + (b[1] - a * b[0])\nplt.plot(xx, yy_down, 'k--')\nplt.plot(xx, yy_up, 'k--')\n\n# Plot data\nplt.scatter(X[:, 0], X[:, 1], c=y, cmap=cm.Paired)\n\n<matplotlib.collections.PathCollection at 0x7f8b940742b0>\n\n\n\n\n\n\n# Magnitude of w\nnp.linalg.norm(w)\n\n1.111010607589106"
  },
  {
    "objectID": "notebooks/posts/autodiff-jax-torch.html",
    "href": "notebooks/posts/autodiff-jax-torch.html",
    "title": "AutoDiff in JAX and PyTorch",
    "section": "",
    "text": "import jax.numpy as jnp\nimport jax\n\nimport torch\nprint(torch.__version__)\nprint(jax.__version__)\n\nArray(1., dtype=float32, weak_type=True)\n\n\n\ndef f(x):\n    return jnp.sin(x)\n\nArray(1., dtype=float32, weak_type=True)\n\n\n\nz = torch.tensor(0.0, requires_grad=True)\ntorch.sin(z).backward()\nprint(jax.grad(f)(0.0), z.grad)\n\ntensor(1.)\n\n\n\ndef f(x):\n    return jnp.abs(x)\n\n\nz1 = torch.tensor(0.0001, requires_grad=True)\ntorch.abs(z1).backward()\n\nz2 = torch.tensor(-0.0001, requires_grad=True)\ntorch.abs(z2).backward()\n\nz3 = torch.tensor(0.0, requires_grad=True)\ntorch.abs(z3).backward()\n\nprint(jax.grad(f)(0.0), z1.grad, z2.grad, z3.grad)\n\n1.0 tensor(1.) tensor(-1.) tensor(0.)\n\n\n\n# Use functorch\n\nimport functorch\n\nImportError: dlopen(/Users/nipun/miniconda3/lib/python3.9/site-packages/functorch/_C.cpython-39-darwin.so, 0x0002): Symbol not found: __ZN2at4_ops10as_strided4callERKNS_6TensorEN3c108ArrayRefINS5_6SymIntEEES8_NS5_8optionalIS7_EE\n  Referenced from: <12715304-4308-3E9B-A374-E4ADB3345E65> /Users/nipun/miniconda3/lib/python3.9/site-packages/functorch/_C.cpython-39-darwin.so\n  Expected in:     <22ECBAD5-EEDD-3C80-9B5A-0564B60B6811> /Users/nipun/miniconda3/lib/python3.9/site-packages/torch/lib/libtorch_cpu.dylib\n\n\n\n\n\n'1.12.1'"
  },
  {
    "objectID": "notebooks/posts/kmeans-init.html",
    "href": "notebooks/posts/kmeans-init.html",
    "title": "KMeans initialisation",
    "section": "",
    "text": "import numpy as np\nimport matplotlib.pyplot as plt\nimport pandas as pd\n\n%matplotlib inline\n%config InlineBackend.figure_format = 'retina'\n\n\nfrom sklearn.datasets import make_blobs\n\nX, y = make_blobs(n_samples=1000, centers=3, n_features=2, random_state=42, cluster_std=3.5)\nplt.scatter(X[:, 0], X[:, 1], c=y, s=50, cmap='viridis');\n\n\n\n\n\n# Run k-means with 3 clusters with various initializations\n\nfrom sklearn.cluster import KMeans\nfig, ax = plt.subplots(2, 6, figsize=(24, 6))\nfor i, init in enumerate(['random', 'k-means++']):\n    for j, random_state in enumerate(range(6)):\n        km = KMeans(n_clusters=5, random_state=random_state*10, init=init)\n        km.fit(X)\n        y_km = km.predict(X)\n        ax[i, j].scatter(X[:, 0], X[:, 1], c=y_km, s=50, cmap='viridis')\n        ax[i, j].scatter(km.cluster_centers_[:, 0], km.cluster_centers_[:, 1], s=200, marker='*', c='red')\n        ax[i, j].set_title(f'init={init}, random_state={random_state}\\n inertia={km.inertia_:.2f}')\n        \nfig.tight_layout()\n\n\n\n\nWe get the same result with different initializations!\n\n\n# Run k-means with 3 clusters with various initializations\n\nfrom sklearn.cluster import KMeans\nfig, ax = plt.subplots(2, 6, figsize=(24, 6))\nfor i, init in enumerate(['random', 'k-means++']):\n    for j, random_state in enumerate(range(6)):\n        km = KMeans(n_clusters=5, random_state=random_state*10, init=init,\n                    n_init=1)\n        km.fit(X)\n        y_km = km.predict(X)\n        ax[i, j].scatter(X[:, 0], X[:, 1], c=y_km, s=50, cmap='viridis')\n        ax[i, j].scatter(km.cluster_centers_[:, 0], km.cluster_centers_[:, 1], s=200, marker='*', c='red')\n        ax[i, j].set_title(f'init={init}, random_state={random_state}\\n inertia={km.inertia_:.2f}')\n        \nfig.tight_layout()      \n\n\n\n\n\nimport numpy as np\nimport matplotlib.pyplot as plt\nfrom sklearn.cluster import KMeans\nfrom sklearn.datasets import make_blobs\n\nX, y = make_blobs(n_samples=200, centers=3, n_features=2, random_state=42, cluster_std=3.5)\n\nrandom_inertias = []\nkmeans_inertias = []\n\n# Run KMeans with random initialization and KMeans++ initialization\n# for various number of clusters\nfor k in range(2, 7):\n    random_inertias.append([])\n    kmeans_inertias.append([])\n    for i in range(10):\n        #print(i, k)\n        km_random = KMeans(n_clusters=k, init='random', n_init=1, random_state=i)\n        km_kmeans = KMeans(n_clusters=k, init='k-means++', n_init=1, random_state=i)\n        \n        km_random.fit(X)\n        km_kmeans.fit(X)\n        random_inertias[-1].append(km_random.inertia_)\n        kmeans_inertias[-1].append(km_kmeans.inertia_)\n\n\nimport pandas as pd\ndf = pd.DataFrame({'random': np.array(random_inertias).mean(axis=1),\n                     'kmeans++': np.array(kmeans_inertias).mean(axis=1)},\n                    index=range(2, 7))\nyerr = pd.DataFrame({'random': np.array(random_inertias).std(axis=1),\n                        'kmeans++': np.array(kmeans_inertias).std(axis=1)},\n                          index=range(2, 7))\nax = df.plot(kind='bar', yerr=yerr, figsize=(10, 6), rot=0)\n\n\n\n\n\n\n# Let us rather work in higher dimensions\nX, y = make_blobs(n_samples=500, centers=3, n_features=10, random_state=42, cluster_std=3.5)\n\nrandom_inertias = []\nkmeans_inertias = []\n\n# Run KMeans with random initialization and KMeans++ initialization\n# for various number of clusters\nfor k in range(2, 7):\n    random_inertias.append([])\n    kmeans_inertias.append([])\n    for i in range(10):\n        #print(i, k)\n        km_random = KMeans(n_clusters=k, init='random', n_init=1, random_state=i)\n        km_kmeans = KMeans(n_clusters=k, init='k-means++', n_init=1, random_state=i)\n        \n        km_random.fit(X)\n        km_kmeans.fit(X)\n        random_inertias[-1].append(km_random.inertia_)\n        kmeans_inertias[-1].append(km_kmeans.inertia_)\n\n\ndf = pd.DataFrame({'random': np.array(random_inertias).mean(axis=1),\n                     'kmeans++': np.array(kmeans_inertias).mean(axis=1)},\n                    index=range(2, 7))\nyerr = pd.DataFrame({'random': np.array(random_inertias).std(axis=1),\n                        'kmeans++': np.array(kmeans_inertias).std(axis=1)},\n                          index=range(2, 7))\nax = df.plot(kind='bar', yerr=yerr, figsize=(10, 6), rot=0)"
  },
  {
    "objectID": "notebooks/posts/svm-kernel.html",
    "href": "notebooks/posts/svm-kernel.html",
    "title": "SVM Kernel",
    "section": "",
    "text": "import numpy as np\nimport pandas as pd\nimport matplotlib.pyplot as plt\nfrom matplotlib import cm\n%matplotlib inline\n\n\nX = np.array([-2, -1, 0, 1, 2, 3, 4]).reshape(-1, 1)\ny = np.array([-1, -1, 1, 1, 1, -1, -1])\n\n\nplt.scatter(X.flatten(), np.zeros_like(X), c=y, cmap=cm.Paired)\n\n<matplotlib.collections.PathCollection at 0x7f8e0b18f490>\n\n\n\n\n\n\ndef phi(x):\n    return np.hstack([x, x**2])\n\n\nphi(X)\n\narray([[-2,  4],\n       [-1,  1],\n       [ 0,  0],\n       [ 1,  1],\n       [ 2,  4],\n       [ 3,  9],\n       [ 4, 16]])\n\n\n\nplt.scatter(phi(X)[:, 0], phi(X)[:, 1], c = y,cmap = cm.Paired)\n\n<matplotlib.collections.PathCollection at 0x7f8beb7f5fa0>\n\n\n\n\n\n\nfrom sklearn.svm import SVC\n\n\nc = SVC(C=1, kernel='linear')\n\n\nc.fit(phi(X), y)\n\nSVC(C=1, kernel='linear')\n\n\n\nplt.scatter(phi(X)[:, 0], phi(X)[:, 1], c = y, zorder=10, cmap =cm.Paired, edgecolors='k', alpha=1, s=200)\nx_min = phi(X)[:, 0].min()-1\nx_max = phi(X)[:, 0].max()+1\ny_min = phi(X)[:, 1].min()-1\ny_max = phi(X)[:, 1].max()+1\n\nXX, YY = np.mgrid[x_min:x_max:200j, y_min:y_max:200j]\nZ = c.decision_function(np.c_[XX.ravel(), YY.ravel()])\n\n# Put the result into a color plot\nZ = Z.reshape(XX.shape)\nplt.pcolormesh(XX, YY, Z > 0, cmap=plt.cm.Paired, alpha=0.6)\nplt.contour(XX, YY, Z, colors=['k', 'k', 'k'],\n            linestyles=['--', '-', '--'], levels=[-1, 0, 1])\nplt.xlabel(r\"$x_1 = X$\")\nplt.ylabel(r\"$x_2 = X^2$\")\nplt.title(r\"Decision surface: {:0.1f}*x_1 + {:0.1f}*x_2 + {:0.1f} = 0\".format(c.coef_[0, 0], c.coef_[0, 1], c.intercept_[0]))\n\nText(0.5, 1.0, 'Decision surface: 1.3*x_1 + -0.7*x_2 + 1.0 = 0')\n\n\n\n\n\n\n# Fit a SVM with polynomial kernel\n\nc = SVC(C=1, kernel='poly', degree=2)\n\nc.fit(X, y)\n\nSVC(C=1, degree=2, kernel='poly')"
  },
  {
    "objectID": "notebooks/posts/condition-inverse.html",
    "href": "notebooks/posts/condition-inverse.html",
    "title": "Conditioning and Linear Regression",
    "section": "",
    "text": "import numpy as np\nimport matplotlib.pyplot as plt\n%matplotlib inline\n%config InlineBackend.figure_format = 'retina'\n\n\n# Showing that np.linalg.solve is better conditioned than np.linalg.inv for linear regression normal equations\n\n# Generate data\nn = 100\np = 10\nX = np.random.randn(n, p)\ntheta = np.random.randn(p)\ny = X @ theta + np.random.randn(n)\n\n# Solve normal equations\ntheta_hat = np.linalg.solve(X.T @ X, X.T @ y)\ntheta_hat_inv = np.linalg.inv(X.T @ X) @ X.T @ y\n\n# Compare the condition numbers\nprint(np.linalg.cond(X.T @ X))\nprint(np.linalg.cond(np.linalg.inv(X.T @ X)))\n\n# Plot the difference between the two solutions\nplt.plot(theta_hat - theta_hat_inv)\nplt.title('Difference between solutions')\nplt.xlabel('Index')\nplt.ylabel('Difference')\nplt.show()\n\n\n2.980877596192165\n2.980877596192165"
  },
  {
    "objectID": "notebooks/posts/cnn.html",
    "href": "notebooks/posts/cnn.html",
    "title": "CNN",
    "section": "",
    "text": "import torch\nimport torch.nn as nn\nimport torch.nn.functional as F\nimport torch.optim as optim\n\nimport numpy as np\nimport matplotlib.pyplot as plt\n\nfrom torch.utils.data import DataLoader, TensorDataset\nimport seaborn as sns\n\n%matplotlib inline\n%config InlineBackend.figure_format = 'retina'\n\n# Set random seed for reproducibility\ntorch.manual_seed(0)\n\n# Torch version\ntorch.__version__\n\n'2.0.0+cu118'\n\n\n\n# MNIST dataset\n\nfrom torchvision import datasets, transforms\nimport torchvision\n\n# Split MNIST into train, validation, and test sets\ntrain_data = datasets.MNIST(root='data', train=True, download=True, transform=transforms.ToTensor())\ntest_data = datasets.MNIST(root='data', train=False, download=True, transform=transforms.ToTensor())\n\n# Split train_data into train and validation sets\nval_data = torch.utils.data.Subset(train_data, range(50000, 51000))\n\n# Reduce the size of the training set to 5,000\ntrain_data = torch.utils.data.Subset(train_data, range(0, 5000))\n\n\n# Create data loaders\nbatch_size = 64\n\ntrain_loader = DataLoader(train_data, batch_size=batch_size, shuffle=True)\nval_loader = DataLoader(val_data, batch_size=batch_size, shuffle=True)\ntest_loader = DataLoader(test_data, batch_size=batch_size, shuffle=True)\n\n\nimg, target = next(iter(train_loader))\nprint(img.shape)\nprint(target.shape)\n\ntorch.Size([64, 1, 28, 28])\ntorch.Size([64])\n\n\n\nplt.imshow(img[0].numpy().squeeze(), cmap='gray_r');\n\n\n\n\n\nimg[0].shape\n\ntorch.Size([1, 28, 28])\n\n\n\n# Create a simple LeNet like CNN\n\nclass LeNet5(nn.Module):\n    def __init__(self):\n        super(LeNet5, self).__init__()\n        # 1 input image channel, 6 output channels, 5x5 square convolution\n        self.conv1 = nn.Conv2d(1, 6, 5) \n        # 6 input image channel, 16 output channels, 5x5 square convolution\n        self.conv2 = nn.Conv2d(6, 16, 5)\n        self.fc1 = nn.Linear(16 * 4 * 4, 120)\n        self.fc2 = nn.Linear(120, 84)\n        self.fc3 = nn.Linear(84, 10)\n        \n    def forward(self, x):\n        x = self.conv1(x) # 28x28x1 -> 24x24x6\n        x = F.max_pool2d(F.relu(x), 2) # 24x24x6 -> 12x12x6\n        x = self.conv2(x) # 12x12x6 -> 8x8x16\n        x = F.max_pool2d(F.relu(x), 2) # 8x8x16 -> 4x4x16\n        x = x.view(-1, self.num_flat_features(x)) # 4x4x16 -> 256\n        x = self.fc1(x) # 256 -> 120\n        x = F.relu(x)\n        x = self.fc2(x) # 120 -> 84\n        x = F.relu(x)\n        x = self.fc3(x) # 84 -> 10\n        return x\n    \n    def num_flat_features(self, x):\n        size = x.size()[1:]\n        num_features = 1\n        for s in size:\n            num_features *= s\n        return num_features\n\n\n# Create a model\n\nmodel = LeNet5()\nprint(model)\n\nLeNet5(\n  (conv1): Conv2d(1, 6, kernel_size=(5, 5), stride=(1, 1))\n  (conv2): Conv2d(6, 16, kernel_size=(5, 5), stride=(1, 1))\n  (fc1): Linear(in_features=256, out_features=120, bias=True)\n  (fc2): Linear(in_features=120, out_features=84, bias=True)\n  (fc3): Linear(in_features=84, out_features=10, bias=True)\n)\n\n\n\n# Train the model\n\n# Define the loss and optimizer\ncriterion = nn.CrossEntropyLoss()\noptimizer = optim.Adam(model.parameters(), lr=0.001)\n\n# Train the model\nn_epochs = 10\n\ntrain_losses = []\nval_losses = []\n\nfor epoch in range(n_epochs):\n    train_loss = 0.0\n    val_loss = 0.0\n    \n    # Train the model\n    model.train()\n    for data, target in train_loader:\n        optimizer.zero_grad()\n        output = model(data)\n        loss = criterion(output, target)\n        loss.backward()\n        optimizer.step()\n        train_loss += loss.item()*data.size(0)\n        \n    # Evaluate the model\n    model.eval()\n    for data, target in val_loader:\n        output = model(data)\n        loss = criterion(output, target)\n        val_loss += loss.item()*data.size(0)\n        \n    # Calculate average losses\n    train_loss = train_loss/len(train_loader.sampler)\n    val_loss = val_loss/len(val_loader.sampler)\n    train_losses.append(train_loss)\n    val_losses.append(val_loss)\n    \n    # Print training/validation statistics \n    print('Epoch: {} \\tTraining Loss: {:.6f} \\tValidation Loss: {:.6f}'.format(\n        epoch+1, \n        train_loss,\n        val_loss\n        ))\n\nEpoch: 1    Training Loss: 1.437300     Validation Loss: 0.653900\nEpoch: 2    Training Loss: 0.424091     Validation Loss: 0.367598\nEpoch: 3    Training Loss: 0.303504     Validation Loss: 0.308797\nEpoch: 4    Training Loss: 0.219186     Validation Loss: 0.257062\nEpoch: 5    Training Loss: 0.195089     Validation Loss: 0.214157\nEpoch: 6    Training Loss: 0.153489     Validation Loss: 0.190220\nEpoch: 7    Training Loss: 0.130065     Validation Loss: 0.189110\nEpoch: 8    Training Loss: 0.114033     Validation Loss: 0.173153\nEpoch: 9    Training Loss: 0.103402     Validation Loss: 0.167645\nEpoch: 10   Training Loss: 0.089715     Validation Loss: 0.156438\n\n\n\n# Plot the training and validation loss\n\nplt.plot(train_losses, label='Training loss')\nplt.plot(val_losses, label='Validation loss')\n\n\n\n\n\n# Test the model\n\nwith torch.no_grad():\n    correct = 0\n    total = 0\n    for data, target in test_loader:\n        output = model(data)\n        _, predicted = torch.max(output.data, 1)\n        total += target.size(0)\n        correct += (predicted == target).sum().item()\n\n    print('Test Accuracy: {}%'.format(100 * correct / total))\n\nTest Accuracy: 96.1%\n\n\n\n# Now, let us take an image and walk it through the model\n\ntest_img = train_data[1][0].unsqueeze(0)\n\n\nplt.imshow(test_img.numpy().squeeze(), cmap='gray_r');\n\n\n\n\n\n# Get weights and biases from the first convolutional layer\n\nweights = model.conv1.weight.data\nw = weights.numpy()\n\n# Plot the weights\n\nfig, axes = plt.subplots(2, 3, figsize=(18, 10))\nax = axes.ravel()\n\nfor i in range(6):\n    sns.heatmap(w[i][0], ax=ax[i], cmap='gray', cbar=False, annot=True)\n    ax[i].set_title('Filter {}'.format(i+1))\n\n\n\n\n\n# Get output from model's first conv1 layer\n\nconv1 = F.relu(model.conv1(test_img))\n\n# For plotting bring all the images to the same scale\nc1 = conv1 - conv1.min()\nc1 = c1 / conv1.max()\n\nprint(c1.shape)\nprint(\"1 image, 6 channels, 24x24 pixels\")\n\ntorch.Size([1, 6, 24, 24])\n1 image, 6 channels, 24x24 pixels\n\n\n\n# Visualizae the output of the first convolutional layer\n\nfig, axes = plt.subplots(2, 3, figsize=(18, 10))\nax = axes.ravel()\n\nfor i in range(6):\n    sns.heatmap(c1[0][i].detach().numpy(), ax=ax[i], cmap='gray')\n    ax[i].set_title('Image {}'.format(i+1))\n\n\n\n\n\n# Get output from model after max pooling\n\npool1 = F.max_pool2d(conv1, 2)\n\n# For plotting bring all the images to the same scale\np1 = pool1 - pool1.min()\np1 = p1 / pool1.max()\n\nprint(p1.shape)\nprint(\"1 image, 6 channels, 12x12 pixels\")\n\n# Visualizae the output of the first convolutional layer\n\nfig, axes = plt.subplots(2, 3, figsize=(18, 10))\nax = axes.ravel()\n\nfor i in range(6):\n    sns.heatmap(p1[0][i].detach().numpy(), ax=ax[i], cmap='gray')\n    ax[i].set_title('Image {}'.format(i+1))\n\ntorch.Size([1, 6, 12, 12])\n1 image, 6 channels, 12x12 pixels\n\n\n\n\n\n\n# Visualize the filters in the second convolutional layer\n\nweights = model.conv2.weight.data\nw = weights.numpy()\n\n# Plot the weights\n\nfig, axes = plt.subplots(4, 4, figsize=(16, 16))\nax = axes.ravel()\n\nfor i in range(16):\n    sns.heatmap(w[i][0], ax=ax[i], cmap='gray', cbar=False)\n    ax[i].set_title('Filter {}'.format(i+1))\n\n\n\n\n\n# Get output from model's second conv2 layer\n\nconv2 = F.relu(model.conv2(pool1))\n\n# For plotting bring all the images to the same scale\nc2 = conv2 - conv2.min()\nc2 = c2 / conv2.max()\n\nprint(c2.shape)\nprint(\"1 image, 16 channels, 8x8 pixels\")\n\n# Visualizae the output of the first convolutional layer\n\nfig, axes = plt.subplots(4, 4, figsize=(18, 18))\nax = axes.ravel()\n\nfor i in range(16):\n    sns.heatmap(c2[0][i].detach().numpy(), ax=ax[i], cmap='gray')\n    ax[i].set_title('Image {}'.format(i+1))\n\ntorch.Size([1, 16, 8, 8])\n1 image, 16 channels, 8x8 pixels\n\n\n\n\n\n\n# Get output from model after max pooling\n\npool2 = F.max_pool2d(conv2, 2)\n\n# For plotting bring all the images to the same scale\np2 = pool2 - pool2.min()\np2 = p2 / pool2.max()\n\nprint(p2.shape)\nprint(\"1 image, 16 channels, 4x4 pixels\")\n\n# Visualizae the output of the first convolutional layer\n\nfig, axes = plt.subplots(4, 4, figsize=(18, 18))\nax = axes.ravel()\n\nfor i in range(16):\n    sns.heatmap(p2[0][i].detach().numpy(), ax=ax[i], cmap='gray')\n    ax[i].set_title('Image {}'.format(i+1))\n\ntorch.Size([1, 16, 4, 4])\n1 image, 16 channels, 4x4 pixels\n\n\n\n\n\n\n# Flatten the output of the second convolutional layer\n\nflat = pool2.view(pool2.size(0), -1)\nprint(flat.shape)\n\ntorch.Size([1, 256])\n\n\n\n# Repeat the above process as a function to visualize the convolution outputs for any image for any layer\ndef scale_img(img):\n    \"\"\"\n    Scale the image to the same scale\n    \"\"\"\n    img = img - img.min()\n    img = img / img.max()\n    return img\n\ndef visualize_conv_output(model, img):\n    \"\"\"\n    Visualize the output of a convolutional layer\n    \"\"\"\n    # Get output from model's first conv1 layer\n    conv1 = F.relu(model.conv1(img))\n\n    # For plotting bring all the images to the same scale\n    c1 = scale_img(conv1)\n\n    # Visualizae the output of the first convolutional layer\n    fig, axes = plt.subplots(2, 3, figsize=(18, 10))\n    ax = axes.ravel()\n\n\n    for i in range(6):\n        sns.heatmap(c1[0][i].detach().numpy(), ax=ax[i], cmap='gray')\n        ax[i].set_title('Image {}'.format(i+1))\n    # Add title to the figure\n    fig.suptitle('Convolutional Layer 1', fontsize=16)\n    \n    # Get output from model after max pooling\n    pool1 = F.max_pool2d(conv1, 2)\n\n    # For plotting bring all the images to the same scale\n    p1 = scale_img(pool1)\n\n    # Visualizae the output of the first convolutional layer\n    fig, axes = plt.subplots(2, 3, figsize=(18, 10))\n    ax = axes.ravel()\n\n\n    for i in range(6):\n        sns.heatmap(p1[0][i].detach().numpy(), ax=ax[i], cmap='gray')\n        ax[i].set_title('Image {}'.format(i+1))\n    # Add title to the figure\n    fig.suptitle('Max Pooling Layer 1', fontsize=16)\n\n    # Get output from model's second conv2 layer\n    conv2 = F.relu(model.conv2(pool1))\n\n    # For plotting bring all the images to the same scale\n    c2 = scale_img(conv2)\n\n    # Visualizae the output of the first convolutional layer\n    fig, axes = plt.subplots(4, 4, figsize=(18, 18))\n    ax = axes.ravel()\n\n    \n    for i in range(16):\n        sns.heatmap(c2[0][i].detach().numpy(), ax=ax[i], cmap='gray')\n        ax[i].set_title('Image {}'.format(i+1))\n    # Add title to the figure\n    fig.suptitle('Convolutional Layer 2', fontsize=16)\n\n    # Get output from model after max pooling\n    pool2 = F.max_pool2d(conv2, 2)\n\n    # For plotting bring all the images to the same scale\n    p2 = scale_img(pool2)\n\n    # Visualizae the output of the first convolutional layer\n    fig, axes = plt.subplots(4, 4, figsize=(18, 18))\n    ax = axes.ravel()\n\n    for i in range(16):\n        sns.heatmap(p2[0][i].detach().numpy(), ax=ax[i], cmap='gray')\n        ax[i].set_title('Image {}'.format(i+1))\n    # Add title to the figure\n    fig.suptitle('Max Pooling Layer 2', fontsize=16)\n\n\nvisualize_conv_output(model, train_data[2][0].unsqueeze(0))\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nvisualize_conv_output(model, train_data[4][0].unsqueeze(0))"
  },
  {
    "objectID": "notebooks/posts/maths-jax.html",
    "href": "notebooks/posts/maths-jax.html",
    "title": "Maths and JAX",
    "section": "",
    "text": "import pandas as pd\nimport numpy as np\nimport jax.numpy as jnp\nimport jax\n\n\ndef func(x, y, z):\n    return x**2 + jnp.sin(y) + z\n\n\nfunc(1, 2, 3)\n\nDeviceArray(4.9092975, dtype=float32, weak_type=True)\n\n\n\nfrom sympy import *\ninit_printing()\n\nx, y, z = symbols('x y z')\nf = x**2 + sin(y) + z\nf\n\n\\(\\displaystyle x^{2} + z + \\sin{\\left(y \\right)}\\)\n\n\n\ndiff(f, x)\n\n\\(\\displaystyle 2 x\\)\n\n\n\n# Find the derivative of f with respect to x, y, and z using sympy\ndel_x, del_y, del_z = diff(f, x), diff(f, y), diff(f, z)\ndel_x, del_y, del_z\n\n\\(\\displaystyle \\left( 2 x, \\  \\cos{\\left(y \\right)}, \\  1\\right)\\)\n\n\n\ngrad_f = lambdify((x, y, z), [del_x, del_y, del_z])\ngrad_f(1, 2, 3)\n\n\\(\\displaystyle \\left[ 2, \\  -0.416146836547142, \\  1\\right]\\)\n\n\n\ngrad_f_jax = jax.grad(func, argnums=(0, 1, 2))\ngrad_f_jax(1., 2., 3.)\n\n(DeviceArray(2., dtype=float32, weak_type=True),\n DeviceArray(-0.41614684, dtype=float32, weak_type=True),\n DeviceArray(1., dtype=float32, weak_type=True))\n\n\n\nn = 20\nA = jax.random.normal(shape=(1, n), key=jax.random.PRNGKey(0), dtype=jnp.float32)\ntheta = jax.random.normal(shape=(n, 1), key=jax.random.PRNGKey(0), dtype=jnp.float32)\nb = A @ theta \n\nb\n\nDeviceArray([[28.684494]], dtype=float32)\n\n\n\nb.flatten(), b.item()\n\n(DeviceArray([28.684494], dtype=float32), 28.684494018554688)\n\n\n\ndef a_theta(A, theta):\n    return A @ theta\n\n\na_theta(A, theta)\n\nDeviceArray([[28.684494]], dtype=float32)\n\n\n\ngrad_a_theta = jax.grad(a_theta, argnums=1)\n\n\njax.jacobian(a_theta, argnums=1)(A, theta)[0, 0, :].shape\n\n\\(\\displaystyle \\left( 20, \\  1\\right)\\)\n\n\n\nA.shape\n\n\\(\\displaystyle \\left( 1, \\  20\\right)\\)\n\n\n\n# Sympy version\n\n\nA = MatrixSymbol('A', 1, n)\ntheta = MatrixSymbol('theta', n, 1)\nA, theta\n\n\\(\\displaystyle \\left( A, \\  \\theta\\right)\\)\n\n\n\ndiff(A*theta, theta)\n\n\\(\\displaystyle A^{T}\\)"
  },
  {
    "objectID": "notebooks/posts/cnn-edge.html",
    "href": "notebooks/posts/cnn-edge.html",
    "title": "CNN Edge 2d",
    "section": "",
    "text": "import torch\nimport torch.nn.functional as F\nfrom torch import nn\nimport pandas as pd\nimport matplotlib.pyplot as plt # for making figures\nimport seaborn as sns\n%matplotlib inline\n\n\n# Create a tensor of size 6x6 with first three columns as 1 and rest as 0\nx = torch.zeros(6, 6)\nx[:, :3] = 1\nprint(x)\n\ntensor([[1., 1., 1., 0., 0., 0.],\n        [1., 1., 1., 0., 0., 0.],\n        [1., 1., 1., 0., 0., 0.],\n        [1., 1., 1., 0., 0., 0.],\n        [1., 1., 1., 0., 0., 0.],\n        [1., 1., 1., 0., 0., 0.]])\n\n\n\nx.shape\n\ntorch.Size([6, 6])\n\n\n\n# Plot the tensor with equal aspect ratio\nplt.figure(figsize=(6, 6))\nsns.heatmap(x, cbar=False, xticklabels=False, yticklabels=False, cmap='gray', annot=True)\n\n<AxesSubplot: >\n\n\n\n\n\n\n# Create a 3x3 kernel with first column as 1, second as 0 and third as -1\n\nk = torch.tensor([[1, 0, -1], [1, 0, -1], [1, 0, -1]]).float()\nprint(k)\n\ntensor([[ 1.,  0., -1.],\n        [ 1.,  0., -1.],\n        [ 1.,  0., -1.]])\n\n\n\n# Apply the kernel to the image\n\n\ny = F.conv2d(x.view(1, 1, 6, 6), k.view(1, 1, 3, 3))\nprint(y)\n\n# Create figure of size of y\nplt.figure(figsize=(y.shape[2], y.shape[3]))\nsns.heatmap(y[0, 0], cbar=False, xticklabels=False, yticklabels=False, cmap='gray', annot=True)\n\ntensor([[[[0., 3., 3., 0.],\n          [0., 3., 3., 0.],\n          [0., 3., 3., 0.],\n          [0., 3., 3., 0.]]]])\n\n\n<AxesSubplot: >\n\n\n\n\n\n\nim = plt.imread('lm.jpeg')\nplt.imshow(im)\n\n<matplotlib.image.AxesImage at 0x151220670>\n\n\n\n\n\n\n# Crop to left 180 X 180 pixels\n\nim = im[:180, :180]\nplt.imshow(im, cmap='gray')\n\n<matplotlib.image.AxesImage at 0x1512b3cd0>\n\n\n\n\n\n\n# Convert to grayscale\nim = im.mean(axis=2)\nplt.imshow(im, cmap='gray')\n\n<matplotlib.image.AxesImage at 0x15133dac0>\n\n\n\n\n\n\nim.shape\n\n(180, 180)\n\n\n\n# Detect edges using our filter\n\nk = torch.tensor([[1, 0, -1], [1, 0, -1], [1, 0, -1]]).float()\n\n# Apply the kernel to the image\ny = F.conv2d(torch.tensor(im).float().view(1, 1, 180, 180), k.view(1, 1, 3, 3))\n\n\n\n# plot the result\n#plt.figure(figsize=(y.shape[2], y.shape[3]))\nplt.imshow(y[0, 0], cmap='gray')\n\n<matplotlib.image.AxesImage at 0x197097430>\n\n\n\n\n\n\n# Detect horizontal edges using our filter\n\nk = torch.tensor([[1, 0, -1], [1, 0, -1], [1, 0, -1]]).float().T\n\n# Apply the kernel to the image\ny = F.conv2d(torch.tensor(im).float().view(1, 1, 180, 180), k.view(1, 1, 3, 3))\nplt.imshow(y[0, 0], cmap='gray')\n\n<matplotlib.image.AxesImage at 0x197105730>"
  },
  {
    "objectID": "notebooks/posts/knn-lsh.html",
    "href": "notebooks/posts/knn-lsh.html",
    "title": "KNN LSH",
    "section": "",
    "text": "import numpy as np\nimport matplotlib.pyplot as plt\nimport pandas as pd\n\n%matplotlib inline\n%config InlineBackend.figure_format = 'retina'\n\n\n# Generate some data\n\nX = np.random.randn(3000, 2)\n\n# Plot the data\n\nplt.scatter(X[:, 0], X[:, 1], s=30)\n\n<matplotlib.collections.PathCollection at 0x7f321da32c10>\n\n\n\n\n\n\n# Naive KNN\n\ndef naive_knn_for_loop(X, x_test, k=3):\n    dists = np.zeros(X.shape[0])\n    for i in range(X.shape[0]): # N iterations (N = number of data points)\n        dists[i] = np.dot(X[i] - x_test, X[i] - x_test) # Time complexity: O(D)\n    \n    # Time complexity to create the distance array: O(N*D)\n\n    # Now, we need to find the k smallest distances\n    return np.argpartition(dists, k)[:k] # Time complexity: O(Nk) or O(N) depending on the implementation\n  \n\n\nnaive_knn_for_loop(X, np.array([0, 0]))\n\narray([2529,  958,  804])\n\n\n\nX[naive_knn_for_loop(X, np.array([0, 0]))]\n\narray([[-0.02103967,  0.02703294],\n       [ 0.0092843 ,  0.02548091],\n       [-0.03094897,  0.01750535]])\n\n\n\n%timeit naive_knn_for_loop(X, np.array([0, 0]))\n\n12.3 ms ± 47.7 µs per loop (mean ± std. dev. of 7 runs, 100 loops each)\n\n\n\n# Implement using numpy\n\ndef naive_knn_numpy(X, x_test, k=3):\n    dists = np.sum((X - x_test)**2, axis=1)\n    #return np.partition(dists, k)[:k]\n    sorted_dists = np.argsort(dists)\n    return sorted_dists[:k]\n\n\nnaive_knn_numpy(X, np.array([0, 0]))\n\narray([ 958, 2529,  804])\n\n\n\n%timeit naive_knn_numpy(X, np.array([0, 0]))\n\n240 µs ± 631 ns per loop (mean ± std. dev. of 7 runs, 1,000 loops each)\n\n\n\n# Implement using numpy\n\ndef naive_knn_numpy(X, x_test, k=3):\n    dists = np.sum((X - x_test)**2, axis=1)\n    return np.argpartition(dists, k)[:k]\n    #sorted_dists = np.argsort(dists)\n    #return sorted_dists[:k]\n\n\n%timeit naive_knn_numpy(X, np.array([0, 0]))\n\n84.6 µs ± 607 ns per loop (mean ± std. dev. of 7 runs, 10,000 loops each)\n\n\n\n# Show LSH implementation step by step\n\n# Creating a random separating hyperplane\n\nw = np.random.randn(2)\nb = np.random.randn(1)/4.0\n\n# Plot the separating hyperplane\n\nx = np.linspace(-3, 3, 100)\ny = -(w[0] * x + b) / w[1]\n\nplt.scatter(X[:, 0], X[:, 1], s=30)\nplt.plot(x, y, 'r', linewidth=3)\n\n# Color the points based on which side of the hyperplane they are on\n\ncolors = X[:, 0]*w[0] + X[:, 1]*w[1] + b > 0\n\nplt.scatter(X[:, 0], X[:, 1], s=30, c=colors)\n\n<matplotlib.collections.PathCollection at 0x7f31106b4ac0>\n\n\n\n\n\n\n# Create three random hyperplanes and color the points based on which side of the hyperplane they are on. \n# there should be 2^3 = 8 different colors\n# each separating hyperplane corresponds to a bit in the hash\n\nhash = np.zeros((X.shape[0], 3)).astype(int)\nws = []\nbs = []\n# Cost for creating the hash table: O(N*H*D) \nfor H in range(3): # H = number of hyperplanes\n    w = np.random.randn(2)\n    b = np.random.randn(1)/4.0\n    ws.append(w)\n    bs.append(b)\n    hash[:, H] = X[:, 0]*w[0] + X[:, 1]*w[1] + b > 0 # D computations per iteration\n\n# Convert the hash to a decimal number\n\nhash_dec = np.sum(hash * 2**np.arange(3)[::-1], axis=1)\n\n# Plot the hash\n\nplt.scatter(X[:, 0], X[:, 1], s=30, c=hash)\n\n# Plot the hash with the separating hyperplanes\n\nplt.scatter(X[:, 0], X[:, 1], s=30, c=hash_dec)\nfor w, b in zip(ws, bs):\n    print(w, b)\n    x = np.linspace(-3, 3, 100)\n    y = -(w[0] * x + b) / w[1]\n    plt.plot(x, y, 'r')\n\n# Mark the test point\n\nx_test = np.array([0, 0])\nplt.scatter(x_test[0], x_test[1], s=100, c='r')\n\n[-1.78798897 -1.3408181 ] [-0.08094113]\n[ 0.9447324  -2.47059549] [0.09350769]\n[0.20531227 0.97521902] [-0.22471283]\n\n\n<matplotlib.collections.PathCollection at 0x7f31105bf280>\n\n\n\n\n\n\ndf = pd.DataFrame(hash)\ndf.columns = ['h1', 'h2', 'h3']\ndf['hash_dec'] = hash_dec\ndf['x'] = X[:, 0]\ndf['y'] = X[:, 1]\n\ndf.head(10)\n\n\n\n\n\n  \n    \n      \n      h1\n      h2\n      h3\n      hash_dec\n      x\n      y\n    \n  \n  \n    \n      0\n      1\n      1\n      0\n      6\n      -1.289013\n      -0.497073\n    \n    \n      1\n      1\n      1\n      0\n      6\n      0.721631\n      -1.923390\n    \n    \n      2\n      1\n      1\n      0\n      6\n      0.042595\n      -0.177549\n    \n    \n      3\n      1\n      1\n      0\n      6\n      0.148706\n      -0.452442\n    \n    \n      4\n      1\n      1\n      0\n      6\n      -0.047372\n      -0.431685\n    \n    \n      5\n      1\n      1\n      0\n      6\n      -0.478764\n      -0.304759\n    \n    \n      6\n      0\n      1\n      0\n      2\n      0.812057\n      -0.574337\n    \n    \n      7\n      1\n      0\n      1\n      5\n      -1.493164\n      1.209339\n    \n    \n      8\n      0\n      1\n      0\n      2\n      0.820065\n      -0.575965\n    \n    \n      9\n      0\n      0\n      1\n      1\n      1.045276\n      1.143788\n    \n  \n\n\n\n\n\n\npd.DataFrame(hash).value_counts()\n\n0  1  2\n1  1  0    846\n0  0  1    827\n   1  0    491\n1  0  0    346\n      1    243\n0  1  1    210\n   0  0     37\ndtype: int64\n\n\n\n# Predict the K nearest neighbors using LSH\n\n# Compute the hash for the test point\n\nx_test = np.array([0, 0])\nhash_test = x_test[0]*ws[0][0] + x_test[1]*ws[0][1] + bs[0] > 0\n\n#convert to decimal\nhash_test_dec = np.sum(hash_test * 2**np.arange(3)[::-1])\n\nhash_test_dec\n\n0\n\n\n\n# Find subset of points with the same hash\n\nX_subset = X[hash_dec == hash_test_dec]\nX_subset.shape\n\n(37, 2)\n\n\n\n# Now, we can use the naive KNN implementation to find the K nearest neighbors\n\nix = naive_knn_numpy(X_subset, x_test, k=3)\nX_subset[ix]\n\narray([[-0.04090763,  0.07013394],\n       [-0.00419256,  0.08614131],\n       [-0.05284791,  0.06786371]])\n\n\n\n%timeit naive_knn_numpy(X_subset, x_test, k=3)\n\n10.5 µs ± 31.4 ns per loop (mean ± std. dev. of 7 runs, 100,000 loops each)\n\n\n\n# Using FAISS from Facebook\n\nimport faiss\n\n# Create an index\nindex = faiss.IndexFlatL2(2)   # build the index\n\n# Add the data to the index\nindex.add(X.astype(np.float32))                  # add vectors to the index\n\n\n# Search for the K nearest neighbors\nD, I = index.search(x_test.astype(np.float32).reshape(1, -1), k=3)     # actual search\n\n\nD\n\narray([[0.00073547, 0.00117345, 0.00126428]], dtype=float32)\n\n\n\nI\n\narray([[ 958, 2529,  804]])\n\n\n\nX[I[0]]\n\narray([[ 0.0092843 ,  0.02548091],\n       [-0.02103967,  0.02703294],\n       [-0.03094897,  0.01750535]])\n\n\n\n%timeit index.search(x_test.astype(np.float32).reshape(1, -1), k=3)\n\n50.9 µs ± 212 ns per loop (mean ± std. dev. of 7 runs, 10,000 loops each)\n\n\n\n# Now, run on GPU\n\nres = faiss.StandardGpuResources()  # use a single GPU\n\n# Create an index\nindex = faiss.IndexFlatL2(2)   # build the index\n\ngpu_index_flat = faiss.index_cpu_to_gpu(res, 0, index)\n\n# Add the data to the index\ngpu_index_flat.add(X.astype(np.float32))                  # add vectors to the index\n\n\n%timeit gpu_index_flat.search(x_test.astype(np.float32).reshape(1, -1), k=3)\n\n79.8 µs ± 674 ns per loop (mean ± std. dev. of 7 runs, 10,000 loops each)\n\n\n\n# The above is slow because\n# 1. We are copying the data to the GPU\n# 2. We are copying the data back to the CPU\n# 3. Not enough data and low dimensional data"
  },
  {
    "objectID": "notebooks/posts/hierarchial-clustering.html",
    "href": "notebooks/posts/hierarchial-clustering.html",
    "title": "Hierarchical Clustering",
    "section": "",
    "text": "import numpy as np\nimport matplotlib.pyplot as plt\nimport pandas as pd\n\n%matplotlib inline\n%config InlineBackend.figure_format = 'retina'\n\nfrom sklearn.datasets import make_blobs\nfrom sklearn.cluster import KMeans\n\n\n# Create a dataset with K_dataset clusters\nK_dataset = 3\n\nX, y = make_blobs(n_samples=10, centers=K_dataset, n_features=2, random_state=0)\n\nplt.scatter(X[:, 0], X[:, 1], c=y, s=200, cmap='viridis')\n# Annotate sample number\nfor i in range(X.shape[0]):\n    plt.annotate(i, (X[i, 0], X[i, 1]), fontsize=20)\n\n\n\n\n\n# Show after 1 step of hierarchical clustering\nfrom scipy.cluster.hierarchy import dendrogram, linkage\n\nZ = linkage(X, 'average')\nplt.figure(figsize=(10, 5))\n\ndendrogram(Z, labels=range(X.shape[0]), leaf_rotation=90, leaf_font_size=20)\nplt.show()\n\n\n\n\n\n# Pairwise distance matrix\nfrom scipy.spatial.distance import pdist, squareform\n\n# Compute the distance matrix\ndist = pdist(X, metric='euclidean')\ndist = squareform(dist)\nX_index = [f\"P{x}\" for x in np.arange(X.shape[0])]\ndf = pd.DataFrame(dist, index=X_index, columns=X_index)\ndf\n\n\n\n\n\n  \n    \n      \n      P0\n      P1\n      P2\n      P3\n      P4\n      P5\n      P6\n      P7\n      P8\n      P9\n    \n  \n  \n    \n      P0\n      0.000000\n      1.468503\n      5.849187\n      1.072565\n      4.001437\n      4.311101\n      5.641206\n      5.617833\n      4.732056\n      1.796596\n    \n    \n      P1\n      1.468503\n      0.000000\n      4.427098\n      0.911272\n      3.289419\n      3.124431\n      5.879548\n      4.149512\n      3.283718\n      0.332095\n    \n    \n      P2\n      5.849187\n      4.427098\n      0.000000\n      4.904326\n      3.705648\n      2.158345\n      7.350236\n      1.347556\n      1.194950\n      4.132565\n    \n    \n      P3\n      1.072565\n      0.911272\n      4.904326\n      0.000000\n      2.966927\n      3.253476\n      5.083095\n      4.830950\n      3.843925\n      1.193839\n    \n    \n      P4\n      4.001437\n      3.289419\n      3.705648\n      2.966927\n      0.000000\n      1.575484\n      3.691478\n      4.465344\n      3.299630\n      3.257210\n    \n    \n      P5\n      4.311101\n      3.124431\n      2.158345\n      3.253476\n      1.575484\n      0.000000\n      5.263313\n      2.910477\n      1.771561\n      2.937847\n    \n    \n      P6\n      5.641206\n      5.879548\n      7.350236\n      5.083095\n      3.691478\n      5.263313\n      0.000000\n      8.154381\n      6.982831\n      6.034281\n    \n    \n      P7\n      5.617833\n      4.149512\n      1.347556\n      4.830950\n      4.465344\n      2.910477\n      8.154381\n      0.000000\n      1.180379\n      3.821671\n    \n    \n      P8\n      4.732056\n      3.283718\n      1.194950\n      3.843925\n      3.299630\n      1.771561\n      6.982831\n      1.180379\n      0.000000\n      2.976718\n    \n    \n      P9\n      1.796596\n      0.332095\n      4.132565\n      1.193839\n      3.257210\n      2.937847\n      6.034281\n      3.821671\n      2.976718\n      0.000000\n    \n  \n\n\n\n\n\nimport seaborn as sns\n# use lower triangle of matrix\nmask = np.zeros_like(dist, dtype=np.bool_)\nmask[np.triu_indices_from(mask)] = True\nplt.figure(figsize=(10, 10))\n# Make heatmap with seaborn and mask, mentining column and row names\nsns.heatmap(dist, mask=mask, xticklabels=X_index, yticklabels=X_index, annot=True, cmap='viridis')\n\n<AxesSubplot:>\n\n\n\n\n\n\n# Combine closest clusters \n# (i.e. the two clusters with the smallest distance)\n\n# Find the two clusters with the smallest distance ignoring the diagonal\n# (i.e. the distance between a cluster and itself)\nnp.fill_diagonal(dist, np.inf)\ni, j= np.unravel_index(np.argmin(dist), dist.shape)\nprint(i, j)\n\n1 9\n\n\n\n# Combine the two clusters to a single \"point\"\nX_new = np.vstack([X[i], X[j]])\nnew_point_name = f'{i} & {j}'\nnew_point_value = X_new.mean(axis=0)\nprint(new_point_name, new_point_value)\n\n# Add new point to the dataset, remove the two old points\nX = np.vstack([X, new_point_value])\nX = np.delete(X, [i, j], axis=0)\nprint(X.shape)\n#Update X_index to reflect the new point and the removed points\nX_index = [f\"P{x}\" for x in range(10) if x not in [i, j]]\nX_index.append(new_point_name)\n\n# Compute the distance matrix\ndist = pdist(X, metric='euclidean')\ndist = squareform(dist)\ndf = pd.DataFrame(dist, index=X_index, columns=X_index)\n\n1 & 9 [1.83183315 4.28894623]\n(9, 2)\n\n\n\ndf\n\n\n\n\n\n  \n    \n      \n      P0\n      P2\n      P3\n      P4\n      P5\n      P6\n      P7\n      P8\n      1 & 9\n    \n  \n  \n    \n      P0\n      0.000000\n      5.849187\n      1.072565\n      4.001437\n      4.311101\n      5.641206\n      5.617833\n      4.732056\n      1.632347\n    \n    \n      P2\n      5.849187\n      0.000000\n      4.904326\n      3.705648\n      2.158345\n      7.350236\n      1.347556\n      1.194950\n      4.279144\n    \n    \n      P3\n      1.072565\n      4.904326\n      0.000000\n      2.966927\n      3.253476\n      5.083095\n      4.830950\n      3.843925\n      1.048934\n    \n    \n      P4\n      4.001437\n      3.705648\n      2.966927\n      0.000000\n      1.575484\n      3.691478\n      4.465344\n      3.299630\n      3.269140\n    \n    \n      P5\n      4.311101\n      2.158345\n      3.253476\n      1.575484\n      0.000000\n      5.263313\n      2.910477\n      1.771561\n      3.028025\n    \n    \n      P6\n      5.641206\n      7.350236\n      5.083095\n      3.691478\n      5.263313\n      0.000000\n      8.154381\n      6.982831\n      5.955102\n    \n    \n      P7\n      5.617833\n      1.347556\n      4.830950\n      4.465344\n      2.910477\n      8.154381\n      0.000000\n      1.180379\n      3.985504\n    \n    \n      P8\n      4.732056\n      1.194950\n      3.843925\n      3.299630\n      1.771561\n      6.982831\n      1.180379\n      0.000000\n      3.129577\n    \n    \n      1 & 9\n      1.632347\n      4.279144\n      1.048934\n      3.269140\n      3.028025\n      5.955102\n      3.985504\n      3.129577\n      0.000000\n    \n  \n\n\n\n\n\nmask = np.zeros_like(dist, dtype=np.bool_)\nmask[np.triu_indices_from(mask)] = True\nplt.figure(figsize=(10, 10))\n# Make heatmap with seaborn and mask, mentining column and row names\nsns.heatmap(dist, mask=mask, xticklabels=X_index, yticklabels=X_index, annot=True, cmap='viridis')\n\n<AxesSubplot:>"
  },
  {
    "objectID": "notebooks/posts/lowrank-matrix.html",
    "href": "notebooks/posts/lowrank-matrix.html",
    "title": "Maths and JAX: Low Rank",
    "section": "",
    "text": "Multiplying a matrix A with a vector x transforms x\n\n\n\n\nTransforming a vector via a low rank matrix in the shown examples leads to a line\n\nWe first study Goal 1. The interpretation of matrix vector product is borrowed from the excellent videos from the 3Blue1Brown channel. I’ll first set up the environment by importing a few relevant libraries.\n\n\n\nimport numpy as np\nimport seaborn as sns\nimport pandas as pd\nimport matplotlib.patches as mpatches\nimport matplotlib.pyplot as plt\nfrom sympy import Matrix, MatrixSymbol, Eq, MatMul\n\nsns.reset_defaults()\nsns.set_context(context=\"talk\", font_scale=0.75)\n%matplotlib inline\n%config InlineBackend.figure_format='retina'\n\n\nsympy_A = MatrixSymbol(\"A\", 2, 2)\nsympy_x = MatrixSymbol(\"x\", 2, 1)\ny = MatrixSymbol(\"y\", 2, 1)\n\nEq(y, sympy_A*sympy_x, evaluate=False)\n\n\\(\\displaystyle y = A x\\)\n\n\nGiven a matrix A and a vector x, we are trying to get y=Ax. Let us first see the values for a specific instance in the 2d space.\n\nA = np.array([[2, 1], [1, 4]])\n\nx = np.array([1, 1])\nAx = A @ x\n\nEq(Matrix(Ax), MatMul(Matrix(A), Matrix(x)),evaluate=False)\n\n\\(\\displaystyle \\left[\\begin{matrix}3\\\\5\\end{matrix}\\right] = \\left[\\begin{matrix}2 & 1\\\\1 & 4\\end{matrix}\\right] \\left[\\begin{matrix}1\\\\1\\end{matrix}\\right]\\)\n\n\nHere, we have A = \\(\\left[\\begin{matrix}2 & 1\\\\1 & 4\\end{matrix}\\right]\\) and x = \\({\\text{[1 1]}}\\)\nNow some code to create arrows to represent arrows.\n\ndef plot_arrow(ax, x, color, label):\n    x_head, y_head = x[0], x[1]\n    x_tail = 0.0\n    y_tail = 0.0\n    dx = x_head - x_tail\n    dy = y_head - y_tail\n\n    arrow = mpatches.FancyArrowPatch(\n        (x_tail, y_tail), (x_head, y_head), mutation_scale=10, color=color, label=label\n    )\n\n    ax.add_patch(arrow)\n    ax.legend(bbox_to_anchor=(1.6, 1), borderaxespad=0)\n\nNow some code to plot the vector corresponding to Ax\n\ndef plot_transform(A, x):\n    Ax = A @ x\n    fig, ax = plt.subplots()\n    plot_arrow(ax, x, \"k\", f\"Original (x) {x}\")\n    plot_arrow(ax, Ax, \"g\", f\"Transformed (Ax) {Ax}\")\n    plt.xlim((-5, 5))\n    plt.ylim((-5, 5))\n    plt.grid(alpha=0.1)\n    ax.set_aspect(\"equal\")\n    plt.title(f\"A = {A}\")\n    sns.despine(left=True, bottom=True)\n    plt.tight_layout()\n\n\nplot_transform(np.array([[1.0, 1.0], [1.0, -1.0]]), [1.0, 2.0])\nplt.savefig(\"Ax1.png\", dpi=100)\n\n\n\n\nIn the plot above, we can see that the vector [1, 2] is transformed to [3, -1] via the matrix A.\nLet us now write some code to create the rotation matrix and apply it on our input x\n\ndef rot(angle):\n    theta = np.radians(angle)\n    c, s = np.cos(theta), np.sin(theta)\n    R = np.array(((c, -s), (s, c)))\n    return np.round(R, 2)\n\n\nx = np.array([1.0, 2.0])\nplot_transform(rot(90), x)\nplt.savefig(\"Ax2\", dpi=100)\n\n\n\n\nAs we can see above, creating the 90 degree rotation matrix indeed transforms our vector anticlockwise 90 degrees.\nNow let us talk about matrices A that are low rank. I am creating a simple low rank matrix where the second row is some constant times the first row.\n\ndef plot_lr(x, slope):\n    low_rank = np.array([1.0, 2.0])\n    low_rank = np.vstack((low_rank, slope * low_rank))\n    plot_transform(low_rank, x)\n    x_lin = np.linspace(-5, 5, 100)\n    y = x_lin * slope\n    plt.plot(x_lin, y, alpha=0.4, lw=5, label=f\"y = {slope}x\")\n    plt.legend(bbox_to_anchor=(1.2, 1), borderaxespad=0)\n\n\nplot_lr(x, 1.01)\nplt.tight_layout()\nplt.savefig(\"lr-1.png\", bbox_inches=\"tight\", dpi=100)\n\n\n\n\n\nplot_lr([1.0, -1.0], 1.01)\nplt.tight_layout()\nplt.savefig(\"lr-2.png\", bbox_inches=\"tight\", dpi=100)\n\n\n\n\n\nplot_lr([0.5, -0.7], 1.01)\nplt.tight_layout()\nplt.savefig(\"lr-3.png\", bbox_inches=\"tight\", dpi=100)\n\n\n\n\n\nplot_lr([-1.0, 0.0], 1.01)\nplt.tight_layout()\nplt.savefig(\"lr-4.png\", bbox_inches=\"tight\", dpi=100)\n\n\n\n\nTo summarize\n\nIn the above plots we can see that changing our x to any vector in the 2d space leads to us to transformed vector not covering the whole 2d space, but on line in the 2d space. One can easily take this learning to higher dimensional matrices A."
  },
  {
    "objectID": "notebooks/posts/movie-recommendation-knn-mf.html",
    "href": "notebooks/posts/movie-recommendation-knn-mf.html",
    "title": "Movie Recommendation using KNN and Matrix Factorization",
    "section": "",
    "text": "import numpy as np\nimport matplotlib.pyplot as plt\nimport pandas as pd\n\n%matplotlib inline\n%config InlineBackend.figure_format = 'retina'\n\n\n# Generate some toy user and movie data\n\n# Number of users\nn_users = 100\n\n# Number of movies\nn_movies = 10\n\n# Number of ratings\nn_ratings = 1000\n\n# Generate random user ids\nuser_ids = np.random.randint(0, n_users, n_ratings)\n\n# Generate random movie ids\nmovie_ids = np.random.randint(0, n_movies, n_ratings)\n\n# Generate random ratings\nratings = np.random.randint(1, 6, n_ratings)\n\n# Create a dataframe with the data\ndf = pd.DataFrame({'user_id': user_ids, 'movie_id': movie_ids, 'rating': ratings})\n\n# We should not have any duplicate ratings for the same user and movie\n# Drop any rows that have duplicate user_id and movie_id pairs\ndf = df.drop_duplicates(['user_id', 'movie_id'])\n\n\ndf\n\n\n\n\n\n  \n    \n      \n      user_id\n      movie_id\n      rating\n    \n  \n  \n    \n      0\n      66\n      7\n      2\n    \n    \n      1\n      54\n      7\n      4\n    \n    \n      2\n      38\n      5\n      3\n    \n    \n      3\n      56\n      6\n      1\n    \n    \n      4\n      4\n      0\n      4\n    \n    \n      ...\n      ...\n      ...\n      ...\n    \n    \n      987\n      77\n      8\n      3\n    \n    \n      992\n      99\n      3\n      3\n    \n    \n      994\n      8\n      5\n      3\n    \n    \n      998\n      22\n      2\n      3\n    \n    \n      999\n      88\n      9\n      1\n    \n  \n\n642 rows × 3 columns\n\n\n\n\n# Create a user-item matrix\n\nA = df.pivot(index='user_id', columns='movie_id', values='rating')\nA\n\n\n\n\n\n  \n    \n      movie_id\n      0\n      1\n      2\n      3\n      4\n      5\n      6\n      7\n      8\n      9\n    \n    \n      user_id\n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n    \n  \n  \n    \n      0\n      3.0\n      4.0\n      NaN\n      5.0\n      5.0\n      1.0\n      2.0\n      5.0\n      2.0\n      4.0\n    \n    \n      1\n      4.0\n      2.0\n      NaN\n      1.0\n      NaN\n      3.0\n      3.0\n      5.0\n      3.0\n      1.0\n    \n    \n      2\n      3.0\n      NaN\n      NaN\n      4.0\n      1.0\n      5.0\n      NaN\n      2.0\n      NaN\n      2.0\n    \n    \n      3\n      4.0\n      NaN\n      4.0\n      2.0\n      NaN\n      3.0\n      NaN\n      2.0\n      NaN\n      4.0\n    \n    \n      4\n      4.0\n      3.0\n      3.0\n      3.0\n      NaN\n      NaN\n      4.0\n      NaN\n      NaN\n      NaN\n    \n    \n      ...\n      ...\n      ...\n      ...\n      ...\n      ...\n      ...\n      ...\n      ...\n      ...\n      ...\n    \n    \n      95\n      1.0\n      3.0\n      1.0\n      2.0\n      3.0\n      NaN\n      1.0\n      NaN\n      5.0\n      NaN\n    \n    \n      96\n      1.0\n      2.0\n      NaN\n      NaN\n      NaN\n      NaN\n      3.0\n      2.0\n      2.0\n      5.0\n    \n    \n      97\n      3.0\n      1.0\n      4.0\n      NaN\n      3.0\n      1.0\n      NaN\n      NaN\n      5.0\n      NaN\n    \n    \n      98\n      5.0\n      3.0\n      NaN\n      NaN\n      2.0\n      NaN\n      1.0\n      3.0\n      4.0\n      3.0\n    \n    \n      99\n      1.0\n      5.0\n      2.0\n      3.0\n      NaN\n      2.0\n      4.0\n      3.0\n      3.0\n      NaN\n    \n  \n\n100 rows × 10 columns\n\n\n\n\n# Fill in the missing values with zeros\nA = A.fillna(0)\n\nA\n\n\n\n\n\n  \n    \n      movie_id\n      0\n      1\n      2\n      3\n      4\n      5\n      6\n      7\n      8\n      9\n    \n    \n      user_id\n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n    \n  \n  \n    \n      0\n      3.0\n      4.0\n      0.0\n      5.0\n      5.0\n      1.0\n      2.0\n      5.0\n      2.0\n      4.0\n    \n    \n      1\n      4.0\n      2.0\n      0.0\n      1.0\n      0.0\n      3.0\n      3.0\n      5.0\n      3.0\n      1.0\n    \n    \n      2\n      3.0\n      0.0\n      0.0\n      4.0\n      1.0\n      5.0\n      0.0\n      2.0\n      0.0\n      2.0\n    \n    \n      3\n      4.0\n      0.0\n      4.0\n      2.0\n      0.0\n      3.0\n      0.0\n      2.0\n      0.0\n      4.0\n    \n    \n      4\n      4.0\n      3.0\n      3.0\n      3.0\n      0.0\n      0.0\n      4.0\n      0.0\n      0.0\n      0.0\n    \n    \n      ...\n      ...\n      ...\n      ...\n      ...\n      ...\n      ...\n      ...\n      ...\n      ...\n      ...\n    \n    \n      95\n      1.0\n      3.0\n      1.0\n      2.0\n      3.0\n      0.0\n      1.0\n      0.0\n      5.0\n      0.0\n    \n    \n      96\n      1.0\n      2.0\n      0.0\n      0.0\n      0.0\n      0.0\n      3.0\n      2.0\n      2.0\n      5.0\n    \n    \n      97\n      3.0\n      1.0\n      4.0\n      0.0\n      3.0\n      1.0\n      0.0\n      0.0\n      5.0\n      0.0\n    \n    \n      98\n      5.0\n      3.0\n      0.0\n      0.0\n      2.0\n      0.0\n      1.0\n      3.0\n      4.0\n      3.0\n    \n    \n      99\n      1.0\n      5.0\n      2.0\n      3.0\n      0.0\n      2.0\n      4.0\n      3.0\n      3.0\n      0.0\n    \n  \n\n100 rows × 10 columns\n\n\n\n\n# Cosine similarity between U1 and U2\n\n# User 1\nu1 = A.loc[0]\n\n# User 2\nu2 = A.loc[1]\n\n# Compute the dot product\ndot = np.dot(u1, u2)\n\n# Compute the L2 norm\nnorm_u1 = np.linalg.norm(u1)\nnorm_u2 = np.linalg.norm(u2)\n\n# Compute the cosine similarity\ncos_sim = dot / (norm_u1 * norm_u2)\ncos_sim\n\n0.7174278379758501\n\n\n\n# Calculate the cosine similarity between users\nfrom sklearn.metrics.pairwise import cosine_similarity\n\nsim_matrix = cosine_similarity(A)\n\npd.DataFrame(sim_matrix)\n\n\n\n\n\n  \n    \n      \n      0\n      1\n      2\n      3\n      4\n      5\n      6\n      7\n      8\n      9\n      ...\n      90\n      91\n      92\n      93\n      94\n      95\n      96\n      97\n      98\n      99\n    \n  \n  \n    \n      0\n      1.000000\n      0.717428\n      0.663734\n      0.565794\n      0.547289\n      0.742468\n      0.539472\n      0.599021\n      0.748964\n      0.523832\n      ...\n      0.876593\n      0.593722\n      0.615664\n      0.722496\n      0.783190\n      0.657754\n      0.665375\n      0.446627\n      0.774667\n      0.703313\n    \n    \n      1\n      0.717428\n      1.000000\n      0.650769\n      0.591169\n      0.559964\n      0.585314\n      0.300491\n      0.255039\n      0.693395\n      0.500193\n      ...\n      0.609392\n      0.313893\n      0.510454\n      0.550459\n      0.624622\n      0.493197\n      0.644346\n      0.476288\n      0.802740\n      0.781611\n    \n    \n      2\n      0.663734\n      0.650769\n      1.000000\n      0.758954\n      0.406780\n      0.372046\n      0.416654\n      0.270593\n      0.746685\n      0.560180\n      ...\n      0.519274\n      0.322243\n      0.772529\n      0.253842\n      0.712485\n      0.257761\n      0.322830\n      0.283373\n      0.441886\n      0.459929\n    \n    \n      3\n      0.565794\n      0.591169\n      0.758954\n      1.000000\n      0.549030\n      0.540128\n      0.671775\n      0.572892\n      0.611794\n      0.489225\n      ...\n      0.424052\n      0.586110\n      0.456327\n      0.506719\n      0.715831\n      0.210494\n      0.506585\n      0.492312\n      0.551652\n      0.424052\n    \n    \n      4\n      0.547289\n      0.559964\n      0.406780\n      0.549030\n      1.000000\n      0.354329\n      0.304478\n      0.541185\n      0.821353\n      0.202287\n      ...\n      0.667638\n      0.527306\n      0.339913\n      0.435159\n      0.582943\n      0.478699\n      0.417780\n      0.450063\n      0.502836\n      0.741820\n    \n    \n      ...\n      ...\n      ...\n      ...\n      ...\n      ...\n      ...\n      ...\n      ...\n      ...\n      ...\n      ...\n      ...\n      ...\n      ...\n      ...\n      ...\n      ...\n      ...\n      ...\n      ...\n      ...\n    \n    \n      95\n      0.657754\n      0.493197\n      0.257761\n      0.210494\n      0.478699\n      0.519615\n      0.452602\n      0.571548\n      0.551553\n      0.405674\n      ...\n      0.564076\n      0.556890\n      0.604211\n      0.682793\n      0.661382\n      1.000000\n      0.412568\n      0.796715\n      0.678637\n      0.693008\n    \n    \n      96\n      0.665375\n      0.644346\n      0.322830\n      0.506585\n      0.417780\n      0.853538\n      0.359095\n      0.538977\n      0.351369\n      0.191776\n      ...\n      0.498686\n      0.640033\n      0.190421\n      0.690704\n      0.682163\n      0.412568\n      1.000000\n      0.280141\n      0.734105\n      0.581800\n    \n    \n      97\n      0.446627\n      0.476288\n      0.283373\n      0.492312\n      0.450063\n      0.400743\n      0.709211\n      0.532239\n      0.469979\n      0.566223\n      ...\n      0.262641\n      0.446564\n      0.501441\n      0.689500\n      0.637007\n      0.796715\n      0.280141\n      1.000000\n      0.659366\n      0.481508\n    \n    \n      98\n      0.774667\n      0.802740\n      0.441886\n      0.551652\n      0.502836\n      0.844146\n      0.446610\n      0.473016\n      0.617575\n      0.335738\n      ...\n      0.546861\n      0.500390\n      0.305585\n      0.673754\n      0.687116\n      0.678637\n      0.734105\n      0.659366\n      1.000000\n      0.600213\n    \n    \n      99\n      0.703313\n      0.781611\n      0.459929\n      0.424052\n      0.741820\n      0.527274\n      0.294579\n      0.578997\n      0.732042\n      0.435869\n      ...\n      0.818182\n      0.615435\n      0.581559\n      0.645439\n      0.623673\n      0.693008\n      0.581800\n      0.481508\n      0.600213\n      1.000000\n    \n  \n\n100 rows × 100 columns\n\n\n\n\nimport seaborn as sns\n\nsns.heatmap(sim_matrix, cmap='Greys')\n\n<AxesSubplot:>\n\n\n\n\n\n\n# Find the most similar users to user u \n\ndef k_nearest_neighbors(A, u, k):\n    \"\"\"Find the k nearest neighbors for user u\"\"\"\n    # Find the index of the user in the matrix\n    u_index = A.index.get_loc(u)\n    \n    # Compute the similarity between the user and all other users\n    sim_matrix = cosine_similarity(A)\n\n    # Find the k most similar users\n    k_nearest = np.argsort(sim_matrix[u_index])[::-1][1:k+1]\n    \n    # Return the user ids\n    return A.index[k_nearest]\n\n\nk_nearest_neighbors(A, 0, 5)\n\nInt64Index([28, 46, 90, 32, 87], dtype='int64', name='user_id')\n\n\n\n# Show matrix of movie ratings for u and k nearest neighbors\n\ndef show_neighbors(A, u, k):\n    \"\"\"Show the movie ratings for user u and k nearest neighbors\"\"\"\n    # Get the user ids of the k nearest neighbors\n    neighbors = k_nearest_neighbors(A, u, k)\n    \n    # Get the movie ratings for user u and the k nearest neighbors\n    df = A.loc[[u] + list(neighbors)]\n    \n    # Return the dataframe\n    return df\n\n\nshow_neighbors(A, 0, 5)\n\n\n\n\n\n  \n    \n      movie_id\n      0\n      1\n      2\n      3\n      4\n      5\n      6\n      7\n      8\n      9\n    \n    \n      user_id\n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n    \n  \n  \n    \n      0\n      3.0\n      4.0\n      0.0\n      5.0\n      5.0\n      1.0\n      2.0\n      5.0\n      2.0\n      4.0\n    \n    \n      28\n      5.0\n      0.0\n      0.0\n      5.0\n      4.0\n      2.0\n      1.0\n      4.0\n      0.0\n      5.0\n    \n    \n      46\n      3.0\n      0.0\n      2.0\n      5.0\n      5.0\n      1.0\n      0.0\n      4.0\n      2.0\n      2.0\n    \n    \n      90\n      1.0\n      5.0\n      1.0\n      5.0\n      2.0\n      0.0\n      2.0\n      4.0\n      0.0\n      1.0\n    \n    \n      32\n      3.0\n      2.0\n      2.0\n      5.0\n      4.0\n      5.0\n      3.0\n      5.0\n      0.0\n      3.0\n    \n    \n      87\n      1.0\n      0.0\n      0.0\n      5.0\n      4.0\n      0.0\n      3.0\n      4.0\n      4.0\n      2.0\n    \n  \n\n\n\n\n\n# Rating for user u for movie 0 is: (4.0 + 3.0) / 2 = 3.5 (Discard 0s)\n\ndef predict_rating(A, u, m, k=5):\n    \"\"\"Predict the rating for user u for movie m\"\"\"\n    # Get the user ids of the k nearest neighbors\n    neighbors = k_nearest_neighbors(A, u, k)\n    \n    # Get the movie ratings for user u and the k nearest neighbors\n    df = A.loc[[u] + list(neighbors)]\n    \n    # Get the ratings for movie m\n    ratings = df[m]\n    \n    # Calculate the mean of the ratings\n    mean = ratings[1:][ratings != 0].mean()\n    \n    # Return the mean\n    return mean\n\n\npredict_rating(A, 0, 5)\n\n2.6666666666666665\n\n\n\n# Now working with real data\n\n# Load the data\n\ndf = pd.read_excel(\"mov-rec.xlsx\")\ndf.head()\n\n\n\n\n\n  \n    \n      \n      Timestamp\n      Your name\n      Sholay\n      Swades (We The People)\n      The Matrix (I)\n      Interstellar\n      Dangal\n      Taare Zameen Par\n      Shawshank Redemption\n      The Dark Knight\n      Notting Hill\n      Uri: The Surgical Strike\n    \n  \n  \n    \n      0\n      2023-04-11 10:58:44.990\n      Nipun\n      4.0\n      5.0\n      4.0\n      4.0\n      5.0\n      5.0\n      4.0\n      5.0\n      4.0\n      5.0\n    \n    \n      1\n      2023-04-11 10:59:49.617\n      Gautam Vashishtha\n      3.0\n      4.0\n      4.0\n      5.0\n      3.0\n      1.0\n      5.0\n      5.0\n      4.0\n      3.0\n    \n    \n      2\n      2023-04-11 11:12:44.033\n      Eshan Gujarathi\n      4.0\n      NaN\n      5.0\n      5.0\n      4.0\n      5.0\n      5.0\n      5.0\n      NaN\n      4.0\n    \n    \n      3\n      2023-04-11 11:13:48.674\n      Sai Krishna Avula\n      5.0\n      3.0\n      3.0\n      4.0\n      4.0\n      5.0\n      5.0\n      3.0\n      3.0\n      4.0\n    \n    \n      4\n      2023-04-11 11:13:55.658\n      Ankit Yadav\n      3.0\n      3.0\n      2.0\n      5.0\n      2.0\n      5.0\n      5.0\n      3.0\n      3.0\n      4.0\n    \n  \n\n\n\n\n\n# Discard the timestamp column\n\ndf = df.drop('Timestamp', axis=1)\n\n# Make the \"Your Name\" column the index\n\ndf = df.set_index('Your name')\ndf\n\n\n\n\n\n  \n    \n      \n      Sholay\n      Swades (We The People)\n      The Matrix (I)\n      Interstellar\n      Dangal\n      Taare Zameen Par\n      Shawshank Redemption\n      The Dark Knight\n      Notting Hill\n      Uri: The Surgical Strike\n    \n    \n      Your name\n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n    \n  \n  \n    \n      Nipun\n      4.0\n      5.0\n      4.0\n      4.0\n      5.0\n      5.0\n      4.0\n      5.0\n      4.0\n      5.0\n    \n    \n      Gautam Vashishtha\n      3.0\n      4.0\n      4.0\n      5.0\n      3.0\n      1.0\n      5.0\n      5.0\n      4.0\n      3.0\n    \n    \n      Eshan Gujarathi\n      4.0\n      NaN\n      5.0\n      5.0\n      4.0\n      5.0\n      5.0\n      5.0\n      NaN\n      4.0\n    \n    \n      Sai Krishna Avula\n      5.0\n      3.0\n      3.0\n      4.0\n      4.0\n      5.0\n      5.0\n      3.0\n      3.0\n      4.0\n    \n    \n      Ankit Yadav\n      3.0\n      3.0\n      2.0\n      5.0\n      2.0\n      5.0\n      5.0\n      3.0\n      3.0\n      4.0\n    \n    \n      Dhruv\n      NaN\n      NaN\n      5.0\n      5.0\n      3.0\n      NaN\n      5.0\n      5.0\n      4.0\n      5.0\n    \n    \n      Saatvik Rao\n      4.0\n      3.0\n      4.0\n      5.0\n      2.0\n      2.0\n      4.0\n      5.0\n      3.0\n      5.0\n    \n    \n      Zeel B Patel\n      5.0\n      4.0\n      5.0\n      4.0\n      4.0\n      4.0\n      NaN\n      2.0\n      NaN\n      5.0\n    \n    \n      Neel\n      4.0\n      NaN\n      5.0\n      5.0\n      3.0\n      3.0\n      5.0\n      5.0\n      NaN\n      4.0\n    \n    \n      Sachin Jalan\n      4.0\n      NaN\n      5.0\n      5.0\n      3.0\n      4.0\n      4.0\n      5.0\n      NaN\n      3.0\n    \n    \n      Ayush Shrivastava\n      5.0\n      4.0\n      5.0\n      5.0\n      3.0\n      3.0\n      4.0\n      4.0\n      NaN\n      4.0\n    \n    \n      ....\n      4.0\n      4.0\n      NaN\n      4.0\n      4.0\n      4.0\n      NaN\n      4.0\n      NaN\n      4.0\n    \n    \n      Hari Hara Sudhan\n      4.0\n      3.0\n      5.0\n      4.0\n      4.0\n      5.0\n      4.0\n      5.0\n      3.0\n      5.0\n    \n    \n      Etikikota Hrushikesh\n      NaN\n      NaN\n      1.0\n      1.0\n      1.0\n      2.0\n      1.0\n      1.0\n      NaN\n      NaN\n    \n    \n      Chirag\n      5.0\n      3.0\n      4.0\n      5.0\n      5.0\n      2.0\n      3.0\n      4.0\n      2.0\n      5.0\n    \n    \n      Aaryan Darad\n      5.0\n      4.0\n      4.0\n      5.0\n      3.0\n      4.0\n      3.0\n      3.0\n      NaN\n      4.0\n    \n    \n      Hetvi Patel\n      4.0\n      3.0\n      2.0\n      5.0\n      4.0\n      4.0\n      5.0\n      3.0\n      3.0\n      5.0\n    \n    \n      Kalash Kankaria\n      4.0\n      NaN\n      4.0\n      5.0\n      3.0\n      4.0\n      NaN\n      NaN\n      NaN\n      3.0\n    \n    \n      Rachit Verma\n      NaN\n      NaN\n      4.0\n      5.0\n      3.0\n      5.0\n      5.0\n      5.0\n      NaN\n      4.0\n    \n    \n      shriraj\n      3.0\n      2.0\n      5.0\n      4.0\n      2.0\n      3.0\n      4.0\n      5.0\n      4.0\n      5.0\n    \n    \n      Bhavini Korthi\n      NaN\n      NaN\n      NaN\n      NaN\n      4.0\n      5.0\n      NaN\n      NaN\n      NaN\n      5.0\n    \n    \n      Hitarth Gandhi\n      3.0\n      NaN\n      4.0\n      5.0\n      3.0\n      4.0\n      5.0\n      5.0\n      NaN\n      NaN\n    \n    \n      Radhika Joglekar\n      3.0\n      3.0\n      3.0\n      4.0\n      5.0\n      5.0\n      2.0\n      1.0\n      2.0\n      5.0\n    \n    \n      Medhansh Singh\n      4.0\n      3.0\n      5.0\n      5.0\n      3.0\n      5.0\n      5.0\n      5.0\n      5.0\n      5.0\n    \n    \n      Arun Mani\n      NaN\n      NaN\n      4.0\n      5.0\n      4.0\n      5.0\n      5.0\n      5.0\n      4.0\n      NaN\n    \n    \n      Satyam\n      3.0\n      5.0\n      5.0\n      5.0\n      4.0\n      3.0\n      5.0\n      5.0\n      NaN\n      5.0\n    \n    \n      Karan Kumar\n      4.0\n      3.0\n      5.0\n      4.0\n      5.0\n      5.0\n      3.0\n      5.0\n      5.0\n      4.0\n    \n    \n      R Yeeshu Dhurandhar\n      5.0\n      NaN\n      4.0\n      5.0\n      4.0\n      4.0\n      5.0\n      5.0\n      NaN\n      NaN\n    \n    \n      Satyam Gupta\n      5.0\n      5.0\n      NaN\n      5.0\n      4.0\n      4.0\n      NaN\n      4.0\n      NaN\n      2.0\n    \n    \n      rushali\n      NaN\n      NaN\n      NaN\n      5.0\n      4.0\n      3.0\n      NaN\n      NaN\n      NaN\n      NaN\n    \n    \n      shridhar\n      5.0\n      4.0\n      5.0\n      5.0\n      4.0\n      4.0\n      5.0\n      4.0\n      3.0\n      3.0\n    \n    \n      Tanvi Jain\n      4.0\n      3.0\n      NaN\n      NaN\n      4.0\n      5.0\n      NaN\n      NaN\n      NaN\n      5.0\n    \n    \n      Manish Prabhubhai Salvi\n      4.0\n      5.0\n      4.0\n      5.0\n      5.0\n      5.0\n      NaN\n      4.0\n      NaN\n      5.0\n    \n    \n      Varun Barala\n      5.0\n      5.0\n      5.0\n      5.0\n      4.0\n      4.0\n      5.0\n      4.0\n      3.0\n      4.0\n    \n    \n      Kevin Shah\n      3.0\n      4.0\n      5.0\n      5.0\n      4.0\n      5.0\n      5.0\n      4.0\n      3.0\n      5.0\n    \n    \n      Inderjeet\n      4.0\n      NaN\n      4.0\n      5.0\n      4.0\n      3.0\n      5.0\n      5.0\n      NaN\n      3.0\n    \n    \n      Gangaram Siddam\n      4.0\n      4.0\n      3.0\n      3.0\n      5.0\n      5.0\n      4.0\n      4.0\n      3.0\n      5.0\n    \n    \n      Aditi\n      4.0\n      4.0\n      NaN\n      5.0\n      1.0\n      3.0\n      5.0\n      4.0\n      NaN\n      4.0\n    \n    \n      Madhuri Awachar\n      5.0\n      4.0\n      5.0\n      4.0\n      5.0\n      3.0\n      5.0\n      5.0\n      4.0\n      5.0\n    \n    \n      Anupam\n      5.0\n      5.0\n      NaN\n      5.0\n      5.0\n      5.0\n      NaN\n      NaN\n      NaN\n      5.0\n    \n    \n      Jinay\n      3.0\n      1.0\n      4.0\n      3.0\n      4.0\n      3.0\n      5.0\n      5.0\n      4.0\n      3.0\n    \n    \n      Shrutimoy\n      5.0\n      5.0\n      5.0\n      5.0\n      4.0\n      5.0\n      5.0\n      5.0\n      NaN\n      2.0\n    \n    \n      Aadesh Desai\n      4.0\n      4.0\n      3.0\n      5.0\n      3.0\n      3.0\n      5.0\n      5.0\n      4.0\n      5.0\n    \n    \n      Dhairya\n      5.0\n      4.0\n      4.0\n      5.0\n      3.0\n      5.0\n      NaN\n      4.0\n      NaN\n      4.0\n    \n    \n      Rahul C\n      3.0\n      3.0\n      4.0\n      4.0\n      4.0\n      4.0\n      4.0\n      5.0\n      NaN\n      NaN\n    \n  \n\n\n\n\n\ndf.index\n\nIndex(['Nipun', 'Gautam Vashishtha', 'Eshan Gujarathi', 'Sai Krishna Avula',\n       'Ankit Yadav ', 'Dhruv', 'Saatvik Rao ', 'Zeel B Patel', 'Neel ',\n       'Sachin Jalan ', 'Ayush Shrivastava', '....', 'Hari Hara Sudhan',\n       'Etikikota Hrushikesh', 'Chirag', 'Aaryan Darad', 'Hetvi Patel',\n       'Kalash Kankaria', 'Rachit Verma', 'shriraj', 'Bhavini Korthi ',\n       'Hitarth Gandhi ', 'Radhika Joglekar ', 'Medhansh Singh', 'Arun Mani',\n       'Satyam ', 'Karan Kumar ', 'R Yeeshu Dhurandhar', 'Satyam Gupta',\n       'rushali', 'shridhar', 'Tanvi Jain ', 'Manish Prabhubhai Salvi ',\n       'Varun Barala', 'Kevin Shah ', 'Inderjeet', 'Gangaram Siddam ', 'Aditi',\n       'Madhuri Awachar', 'Anupam', 'Jinay', 'Shrutimoy', 'Aadesh Desai',\n       'Dhairya', 'Rahul C'],\n      dtype='object', name='Your name')\n\n\n\n# Get index for user and movie\nuser = 'Rahul C'\n\nprint(user in df.index)\n\n# Get the movie ratings for user\nuser_ratings = df.loc[user]\nuser_ratings\n\nTrue\n\n\nSholay                      3.0\nSwades (We The People)      3.0\nThe Matrix (I)              4.0\nInterstellar                4.0\nDangal                      4.0\nTaare Zameen Par            4.0\nShawshank Redemption        4.0\nThe Dark Knight             5.0\nNotting Hill                NaN\nUri: The Surgical Strike    NaN\nName: Rahul C, dtype: float64\n\n\n\ndf_copy = df.copy()\ndf_copy.fillna(0, inplace=True)\nshow_neighbors(df_copy, user, 5)\n\n\n\n\n\n  \n    \n      \n      Sholay\n      Swades (We The People)\n      The Matrix (I)\n      Interstellar\n      Dangal\n      Taare Zameen Par\n      Shawshank Redemption\n      The Dark Knight\n      Notting Hill\n      Uri: The Surgical Strike\n    \n    \n      Your name\n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n    \n  \n  \n    \n      Rahul C\n      3.0\n      3.0\n      4.0\n      4.0\n      4.0\n      4.0\n      4.0\n      5.0\n      0.0\n      0.0\n    \n    \n      Shrutimoy\n      5.0\n      5.0\n      5.0\n      5.0\n      4.0\n      5.0\n      5.0\n      5.0\n      0.0\n      2.0\n    \n    \n      Hitarth Gandhi\n      3.0\n      0.0\n      4.0\n      5.0\n      3.0\n      4.0\n      5.0\n      5.0\n      0.0\n      0.0\n    \n    \n      R Yeeshu Dhurandhar\n      5.0\n      0.0\n      4.0\n      5.0\n      4.0\n      4.0\n      5.0\n      5.0\n      0.0\n      0.0\n    \n    \n      shridhar\n      5.0\n      4.0\n      5.0\n      5.0\n      4.0\n      4.0\n      5.0\n      4.0\n      3.0\n      3.0\n    \n    \n      Sachin Jalan\n      4.0\n      0.0\n      5.0\n      5.0\n      3.0\n      4.0\n      4.0\n      5.0\n      0.0\n      3.0\n    \n  \n\n\n\n\n\ndf.describe()\n\n\n\n\n\n  \n    \n      \n      Sholay\n      Swades (We The People)\n      The Matrix (I)\n      Interstellar\n      Dangal\n      Taare Zameen Par\n      Shawshank Redemption\n      The Dark Knight\n      Notting Hill\n      Uri: The Surgical Strike\n    \n  \n  \n    \n      count\n      39.000000\n      32.000000\n      38.000000\n      43.000000\n      45.000000\n      44.000000\n      35.000000\n      40.000000\n      21.000000\n      39.000000\n    \n    \n      mean\n      4.102564\n      3.718750\n      4.131579\n      4.581395\n      3.644444\n      3.977273\n      4.400000\n      4.250000\n      3.476190\n      4.230769\n    \n    \n      std\n      0.753758\n      0.958304\n      0.991070\n      0.793802\n      1.003529\n      1.067242\n      0.976187\n      1.080123\n      0.813575\n      0.902089\n    \n    \n      min\n      3.000000\n      1.000000\n      1.000000\n      1.000000\n      1.000000\n      1.000000\n      1.000000\n      1.000000\n      2.000000\n      2.000000\n    \n    \n      25%\n      4.000000\n      3.000000\n      4.000000\n      4.000000\n      3.000000\n      3.000000\n      4.000000\n      4.000000\n      3.000000\n      4.000000\n    \n    \n      50%\n      4.000000\n      4.000000\n      4.000000\n      5.000000\n      4.000000\n      4.000000\n      5.000000\n      5.000000\n      3.000000\n      4.000000\n    \n    \n      75%\n      5.000000\n      4.000000\n      5.000000\n      5.000000\n      4.000000\n      5.000000\n      5.000000\n      5.000000\n      4.000000\n      5.000000\n    \n    \n      max\n      5.000000\n      5.000000\n      5.000000\n      5.000000\n      5.000000\n      5.000000\n      5.000000\n      5.000000\n      5.000000\n      5.000000\n    \n  \n\n\n\n\n\n# Predict the rating for user u for movie m\n\npredict_rating(df_copy, user, 'The Dark Knight')\n\n4.8\n\n\n\npredict_rating(df_copy, user, 'Sholay')\n\n4.4\n\n\n\n# Generic Matrix Factorization (without missing values)\n\nimport torch\nimport torch.nn as nn\nimport torch.nn.functional as F\nimport torch.optim as optim\n\n\n# A is a matrix of size (n_users, n_movies) randomly generated values between 1 and 5\nA = torch.randint(1, 6, (n_users, n_movies), dtype=torch.float)\nA\n\ntensor([[1., 5., 4., 3., 4., 3., 1., 3., 3., 4.],\n        [3., 3., 4., 4., 4., 2., 5., 2., 2., 4.],\n        [2., 5., 5., 3., 3., 1., 4., 5., 2., 5.],\n        [4., 2., 1., 5., 1., 5., 1., 1., 5., 1.],\n        [4., 3., 5., 3., 4., 1., 2., 4., 1., 5.],\n        [1., 2., 2., 1., 2., 4., 1., 1., 3., 3.],\n        [4., 2., 2., 3., 5., 3., 3., 2., 5., 2.],\n        [2., 2., 1., 1., 2., 4., 5., 1., 4., 3.],\n        [1., 3., 2., 1., 3., 4., 1., 5., 5., 1.],\n        [4., 4., 2., 4., 1., 4., 2., 1., 4., 4.],\n        [1., 3., 1., 2., 3., 1., 3., 2., 4., 4.],\n        [5., 3., 5., 1., 4., 5., 4., 2., 1., 5.],\n        [5., 1., 5., 3., 4., 4., 4., 2., 2., 2.],\n        [1., 1., 2., 3., 5., 4., 3., 1., 1., 1.],\n        [3., 2., 5., 4., 3., 5., 2., 4., 4., 3.],\n        [2., 2., 4., 1., 2., 3., 2., 4., 3., 5.],\n        [4., 2., 4., 5., 2., 2., 1., 2., 1., 1.],\n        [4., 3., 2., 1., 1., 1., 5., 2., 1., 1.],\n        [2., 1., 2., 1., 1., 1., 5., 5., 1., 4.],\n        [1., 3., 5., 1., 5., 5., 5., 5., 2., 2.],\n        [1., 2., 2., 5., 1., 1., 5., 4., 2., 5.],\n        [5., 1., 2., 2., 1., 5., 2., 3., 5., 2.],\n        [2., 2., 1., 5., 5., 5., 5., 3., 4., 3.],\n        [1., 1., 4., 1., 2., 5., 5., 5., 2., 1.],\n        [5., 3., 3., 1., 2., 3., 3., 2., 2., 3.],\n        [2., 4., 5., 1., 2., 3., 5., 3., 1., 5.],\n        [2., 1., 1., 1., 2., 2., 5., 5., 2., 1.],\n        [3., 1., 1., 3., 3., 3., 2., 1., 3., 2.],\n        [4., 4., 4., 5., 1., 3., 4., 3., 2., 2.],\n        [4., 4., 4., 5., 2., 5., 2., 1., 4., 3.],\n        [3., 3., 5., 1., 4., 3., 3., 3., 3., 2.],\n        [2., 4., 2., 3., 4., 2., 4., 3., 3., 3.],\n        [5., 4., 1., 5., 4., 3., 5., 1., 3., 4.],\n        [3., 5., 3., 2., 4., 2., 5., 1., 2., 5.],\n        [2., 5., 4., 1., 1., 5., 1., 5., 2., 4.],\n        [1., 3., 3., 4., 4., 5., 2., 5., 3., 5.],\n        [3., 3., 5., 3., 4., 1., 3., 1., 1., 3.],\n        [2., 4., 1., 3., 5., 1., 5., 2., 4., 1.],\n        [5., 2., 2., 3., 1., 4., 5., 5., 4., 2.],\n        [5., 3., 5., 1., 5., 4., 3., 1., 1., 3.],\n        [4., 2., 2., 2., 2., 1., 2., 1., 1., 3.],\n        [2., 2., 1., 4., 1., 4., 5., 2., 5., 1.],\n        [3., 4., 2., 1., 3., 1., 2., 5., 3., 5.],\n        [1., 3., 3., 5., 3., 2., 1., 2., 5., 1.],\n        [3., 4., 2., 4., 2., 3., 4., 1., 1., 1.],\n        [1., 1., 5., 1., 3., 2., 5., 5., 5., 4.],\n        [4., 4., 4., 4., 4., 3., 1., 4., 1., 1.],\n        [3., 4., 5., 4., 1., 5., 2., 3., 1., 3.],\n        [5., 2., 5., 5., 2., 4., 5., 4., 4., 5.],\n        [3., 5., 5., 4., 1., 5., 1., 2., 5., 1.],\n        [2., 4., 3., 5., 4., 5., 2., 5., 3., 3.],\n        [3., 2., 3., 1., 1., 4., 1., 1., 2., 1.],\n        [4., 1., 2., 4., 4., 3., 2., 2., 2., 4.],\n        [2., 2., 3., 2., 3., 2., 2., 5., 4., 3.],\n        [4., 2., 3., 4., 4., 1., 1., 4., 2., 3.],\n        [2., 2., 3., 2., 2., 1., 4., 3., 5., 4.],\n        [5., 5., 5., 4., 2., 1., 3., 1., 3., 3.],\n        [2., 4., 5., 1., 2., 2., 5., 3., 3., 1.],\n        [1., 4., 3., 2., 3., 5., 3., 2., 4., 4.],\n        [1., 3., 2., 1., 2., 3., 2., 2., 5., 2.],\n        [4., 5., 5., 3., 1., 2., 1., 3., 4., 4.],\n        [4., 2., 3., 2., 3., 4., 5., 1., 4., 3.],\n        [3., 2., 1., 3., 2., 2., 5., 5., 5., 1.],\n        [2., 5., 5., 2., 3., 5., 3., 4., 3., 2.],\n        [1., 2., 2., 4., 4., 5., 5., 2., 5., 1.],\n        [4., 4., 1., 5., 2., 4., 4., 2., 4., 2.],\n        [4., 1., 5., 3., 1., 4., 5., 2., 2., 2.],\n        [3., 2., 2., 1., 1., 1., 2., 4., 2., 2.],\n        [1., 1., 3., 2., 2., 4., 3., 3., 2., 2.],\n        [2., 4., 3., 1., 1., 2., 4., 2., 5., 2.],\n        [1., 4., 3., 5., 4., 2., 4., 2., 2., 5.],\n        [4., 4., 5., 5., 4., 3., 4., 1., 4., 5.],\n        [5., 2., 2., 1., 4., 4., 3., 5., 5., 5.],\n        [3., 1., 3., 1., 2., 5., 5., 4., 3., 1.],\n        [5., 5., 5., 3., 5., 3., 3., 3., 3., 3.],\n        [5., 3., 3., 3., 4., 3., 5., 4., 5., 1.],\n        [5., 5., 3., 5., 4., 1., 2., 1., 3., 2.],\n        [5., 3., 4., 1., 5., 2., 4., 4., 2., 1.],\n        [1., 2., 1., 2., 1., 3., 4., 1., 2., 1.],\n        [5., 3., 3., 1., 5., 1., 4., 5., 5., 1.],\n        [2., 2., 5., 2., 3., 5., 1., 5., 4., 2.],\n        [3., 3., 1., 2., 5., 5., 4., 4., 4., 5.],\n        [5., 3., 5., 3., 5., 5., 3., 4., 1., 4.],\n        [5., 3., 2., 5., 1., 2., 4., 3., 1., 4.],\n        [5., 2., 5., 2., 4., 3., 2., 2., 4., 5.],\n        [2., 3., 5., 2., 4., 5., 3., 1., 4., 3.],\n        [3., 3., 1., 4., 5., 2., 1., 3., 4., 4.],\n        [5., 2., 3., 4., 2., 2., 5., 4., 2., 1.],\n        [3., 1., 1., 2., 5., 1., 5., 1., 5., 3.],\n        [3., 5., 1., 5., 3., 4., 5., 5., 4., 3.],\n        [2., 4., 1., 5., 4., 1., 4., 5., 1., 4.],\n        [5., 5., 4., 1., 2., 2., 2., 5., 1., 3.],\n        [5., 2., 3., 3., 4., 3., 3., 4., 3., 2.],\n        [1., 5., 4., 4., 5., 3., 4., 2., 4., 1.],\n        [2., 4., 1., 1., 4., 2., 1., 1., 3., 4.],\n        [4., 4., 2., 3., 2., 2., 3., 5., 4., 1.],\n        [5., 4., 3., 4., 5., 4., 5., 1., 5., 5.],\n        [1., 1., 1., 1., 4., 4., 5., 2., 4., 2.],\n        [2., 4., 1., 2., 4., 3., 5., 1., 4., 4.],\n        [2., 5., 2., 1., 3., 5., 5., 4., 1., 4.]])\n\n\n\nA.shape\n\ntorch.Size([100, 10])\n\n\nLet us decompose A as WH. W is of shape (n, k) and H is of shape (k, n). We can write the above equation as: A = WH\n\n# Randomly initialize A and B\n\nW = torch.randn(n_users, 2, requires_grad=True)\nH = torch.randn(2, n_movies, requires_grad=True)\n\n# Compute the loss\n\nloss = torch.norm(torch.mm(W, H) - A)\nloss\n\ntensor(110.7991, grad_fn=<LinalgVectorNormBackward0>)\n\n\n\npd.DataFrame(torch.mm(W, H).detach().numpy())\n\n\n\n\n\n  \n    \n      \n      0\n      1\n      2\n      3\n      4\n      5\n      6\n      7\n      8\n      9\n    \n  \n  \n    \n      0\n      -1.733831\n      2.962563\n      -0.009936\n      -0.591927\n      2.442282\n      -0.533001\n      -0.500535\n      -0.777075\n      -0.427938\n      -0.050505\n    \n    \n      1\n      -1.605388\n      2.875087\n      0.171515\n      -0.770741\n      2.594427\n      -0.652586\n      -0.512620\n      -0.953935\n      -0.329276\n      -0.023146\n    \n    \n      2\n      0.159360\n      -0.289060\n      -0.022038\n      0.082685\n      -0.266777\n      0.069192\n      0.052250\n      0.101196\n      0.030828\n      0.001642\n    \n    \n      3\n      -3.637741\n      4.346515\n      -2.580031\n      1.911339\n      0.407374\n      1.134387\n      -0.353923\n      1.689442\n      -1.846117\n      -0.440421\n    \n    \n      4\n      1.706123\n      -2.207651\n      0.978520\n      -0.611154\n      -0.617788\n      -0.328235\n      0.228982\n      -0.492014\n      0.780051\n      0.176302\n    \n    \n      ...\n      ...\n      ...\n      ...\n      ...\n      ...\n      ...\n      ...\n      ...\n      ...\n      ...\n    \n    \n      95\n      1.362280\n      -2.751892\n      -0.572962\n      1.180665\n      -2.989312\n      0.929992\n      0.551276\n      1.363935\n      0.121039\n      -0.036218\n    \n    \n      96\n      1.432943\n      -1.514237\n      1.287248\n      -1.086741\n      0.338909\n      -0.685343\n      0.065700\n      -1.016967\n      0.827599\n      0.208897\n    \n    \n      97\n      0.381086\n      0.345669\n      1.366953\n      -1.551476\n      1.978570\n      -1.084161\n      -0.261282\n      -1.599606\n      0.599750\n      0.189461\n    \n    \n      98\n      -3.364117\n      6.450801\n      0.942667\n      -2.333749\n      6.511645\n      -1.880903\n      -1.232884\n      -2.755594\n      -0.473888\n      0.027722\n    \n    \n      99\n      0.877697\n      -1.631227\n      -0.175042\n      0.521516\n      -1.568212\n      0.428319\n      0.302370\n      0.626961\n      0.149908\n      0.002033\n    \n  \n\n100 rows × 10 columns\n\n\n\n\npd.DataFrame(A)\n\n\n\n\n\n  \n    \n      \n      0\n      1\n      2\n      3\n      4\n      5\n      6\n      7\n      8\n      9\n    \n  \n  \n    \n      0\n      1.0\n      5.0\n      4.0\n      3.0\n      4.0\n      3.0\n      1.0\n      3.0\n      3.0\n      4.0\n    \n    \n      1\n      3.0\n      3.0\n      4.0\n      4.0\n      4.0\n      2.0\n      5.0\n      2.0\n      2.0\n      4.0\n    \n    \n      2\n      2.0\n      5.0\n      5.0\n      3.0\n      3.0\n      1.0\n      4.0\n      5.0\n      2.0\n      5.0\n    \n    \n      3\n      4.0\n      2.0\n      1.0\n      5.0\n      1.0\n      5.0\n      1.0\n      1.0\n      5.0\n      1.0\n    \n    \n      4\n      4.0\n      3.0\n      5.0\n      3.0\n      4.0\n      1.0\n      2.0\n      4.0\n      1.0\n      5.0\n    \n    \n      ...\n      ...\n      ...\n      ...\n      ...\n      ...\n      ...\n      ...\n      ...\n      ...\n      ...\n    \n    \n      95\n      4.0\n      4.0\n      2.0\n      3.0\n      2.0\n      2.0\n      3.0\n      5.0\n      4.0\n      1.0\n    \n    \n      96\n      5.0\n      4.0\n      3.0\n      4.0\n      5.0\n      4.0\n      5.0\n      1.0\n      5.0\n      5.0\n    \n    \n      97\n      1.0\n      1.0\n      1.0\n      1.0\n      4.0\n      4.0\n      5.0\n      2.0\n      4.0\n      2.0\n    \n    \n      98\n      2.0\n      4.0\n      1.0\n      2.0\n      4.0\n      3.0\n      5.0\n      1.0\n      4.0\n      4.0\n    \n    \n      99\n      2.0\n      5.0\n      2.0\n      1.0\n      3.0\n      5.0\n      5.0\n      4.0\n      1.0\n      4.0\n    \n  \n\n100 rows × 10 columns\n\n\n\n\n# Optimizer\n\noptimizer = optim.Adam([W, H], lr=0.01)\n\n# Train the model\n\nfor i in range(1000):\n    # Compute the loss\n    loss = torch.norm(torch.mm(W, H) - A)\n    \n    # Zero the gradients\n    optimizer.zero_grad()\n    \n    # Backpropagate\n    loss.backward()\n    \n    # Update the parameters\n    optimizer.step()\n    \n    # Print the loss\n    if i % 10 == 0:\n        print(loss.item())\n\n110.79912567138672\n108.5261001586914\n106.6722412109375\n104.86959075927734\n102.57525634765625\n99.17333984375\n94.17224884033203\n87.41124725341797\n79.23120880126953\n70.51470184326172\n62.338897705078125\n55.442466735839844\n50.24897003173828\n46.78135681152344\n44.567237854003906\n43.125022888183594\n42.18255615234375\n41.56866455078125\n41.16780471801758\n40.899253845214844\n40.70838928222656\n40.56161117553711\n40.439727783203125\n40.33248519897461\n40.23463821411133\n40.143455505371094\n40.05741500854492\n39.9755744934082\n39.89726638793945\n39.82197952270508\n39.749305725097656\n39.678890228271484\n39.610443115234375\n39.54371643066406\n39.478515625\n39.4146842956543\n39.35213088989258\n39.290809631347656\n39.23072052001953\n39.17192077636719\n39.114505767822266\n39.058589935302734\n39.00433349609375\n38.95188903808594\n38.90142059326172\n38.85308837890625\n38.8070182800293\n38.76333999633789\n38.722137451171875\n38.6834716796875\n38.64735412597656\n38.61379623413086\n38.5827522277832\n38.554161071777344\n38.527931213378906\n38.503971099853516\n38.482154846191406\n38.46236038208008\n38.444454193115234\n38.42829132080078\n38.41374588012695\n38.40068435668945\n38.38897705078125\n38.378501892089844\n38.36914825439453\n38.36080551147461\n38.35336685180664\n38.34674835205078\n38.34086608886719\n38.33564376831055\n38.330997467041016\n38.326881408691406\n38.3232307434082\n38.31999206542969\n38.31712341308594\n38.314579010009766\n38.31232833862305\n38.310325622558594\n38.308555603027344\n38.30698013305664\n38.30558776855469\n38.30434799194336\n38.30324935913086\n38.30227279663086\n38.301395416259766\n38.300621032714844\n38.2999267578125\n38.29930114746094\n38.29874801635742\n38.298248291015625\n38.29779815673828\n38.297393798828125\n38.297027587890625\n38.29669189453125\n38.29639434814453\n38.296119689941406\n38.295867919921875\n38.29563903808594\n38.29542922973633\n38.29523468017578\n\n\n\npd.DataFrame(torch.mm(W, H).detach().numpy()).head(2)\n\n\n\n\n\n  \n    \n      \n      0\n      1\n      2\n      3\n      4\n      5\n      6\n      7\n      8\n      9\n    \n  \n  \n    \n      0\n      3.622862\n      3.536414\n      3.945925\n      2.985436\n      2.999869\n      2.749094\n      2.605484\n      2.758482\n      2.209353\n      3.361388\n    \n    \n      1\n      3.622746\n      3.547434\n      3.798462\n      3.133817\n      3.271342\n      3.176287\n      3.221505\n      3.073355\n      2.856927\n      3.383140\n    \n  \n\n\n\n\n\npd.DataFrame(A).head(2)\n\n\n\n\n\n  \n    \n      \n      0\n      1\n      2\n      3\n      4\n      5\n      6\n      7\n      8\n      9\n    \n  \n  \n    \n      0\n      1.0\n      5.0\n      4.0\n      3.0\n      4.0\n      3.0\n      1.0\n      3.0\n      3.0\n      4.0\n    \n    \n      1\n      3.0\n      3.0\n      4.0\n      4.0\n      4.0\n      2.0\n      5.0\n      2.0\n      2.0\n      4.0\n    \n  \n\n\n\n\n\ndef factorize(A, k):\n    \"\"\"Factorize the matrix A into W and H\n    A: input matrix of size (n_users, n_movies)\n    k: number of latent features\n    \n    Returns W and H\n    W: matrix of size (n_users, k)\n    H: matrix of size (k, n_movies)\n    \"\"\"\n    # Randomly initialize W and H\n    W = torch.randn(A.shape[0], k, requires_grad=True)\n    H = torch.randn(k, A.shape[1], requires_grad=True)\n    \n    # Optimizer\n    optimizer = optim.Adam([W, H], lr=0.01)\n    \n    # Train the model\n    for i in range(1000):\n        # Compute the loss\n        loss = torch.norm(torch.mm(W, H) - A)\n        \n        # Zero the gradients\n        optimizer.zero_grad()\n        \n        # Backpropagate\n        loss.backward()\n        \n        # Update the parameters\n        optimizer.step()\n        \n    return W, H, loss\n\n\nfor k in [1, 2, 3, 4, 5, 6, 9, 10, 11]:\n    W, H, loss = factorize(A, k)\n    print(k, loss.item())\n\n1 42.103797912597656\n2 38.35541534423828\n3 34.45906448364258\n4 30.72266387939453\n5 27.430004119873047\n6 23.318540573120117\n9 9.963604927062988\n10 0.16205351054668427\n11 0.18895108997821808\n\n\n\npd.DataFrame(torch.mm(W,H).detach().numpy()).head(2)\n\n\n\n\n\n  \n    \n      \n      0\n      1\n      2\n      3\n      4\n      5\n      6\n      7\n      8\n      9\n    \n  \n  \n    \n      0\n      1.014621\n      5.012642\n      4.012176\n      3.013239\n      4.012656\n      3.010292\n      1.012815\n      3.011410\n      3.015494\n      4.012996\n    \n    \n      1\n      2.987797\n      2.986945\n      3.989305\n      3.987498\n      3.988829\n      1.989375\n      4.989910\n      1.987138\n      1.986990\n      3.987026\n    \n  \n\n\n\n\n\npd.DataFrame(A).head(2)\n\n\n\n\n\n  \n    \n      \n      0\n      1\n      2\n      3\n      4\n      5\n      6\n      7\n      8\n      9\n    \n  \n  \n    \n      0\n      1.0\n      5.0\n      4.0\n      3.0\n      4.0\n      3.0\n      1.0\n      3.0\n      3.0\n      4.0\n    \n    \n      1\n      3.0\n      3.0\n      4.0\n      4.0\n      4.0\n      2.0\n      5.0\n      2.0\n      2.0\n      4.0\n    \n  \n\n\n\n\n\n# With missing values\n\n# Randomly replace some entries with NaN\n\nA = torch.randint(1, 6, (n_users, n_movies), dtype=torch.float)\nA[torch.rand(A.shape) < 0.5] = float('nan')\nA\n\ntensor([[nan, 5., 5., nan, 1., 1., 4., 2., nan, 4.],\n        [nan, 2., 2., 1., nan, nan, nan, nan, 3., nan],\n        [nan, nan, 5., 1., nan, nan, 2., nan, nan, nan],\n        [nan, nan, nan, 1., 4., 2., nan, 2., nan, 4.],\n        [nan, nan, 2., nan, 3., 1., nan, nan, 4., 4.],\n        [nan, 2., 5., nan, 2., nan, 1., nan, 3., nan],\n        [nan, nan, nan, nan, 2., 1., nan, 3., nan, 5.],\n        [nan, 4., nan, 1., 5., nan, 4., 5., 4., nan],\n        [nan, nan, 2., 5., nan, nan, 5., nan, nan, 2.],\n        [nan, nan, 3., 2., nan, 1., 1., 4., 5., nan],\n        [nan, nan, 5., nan, nan, nan, 2., 2., nan, 3.],\n        [nan, 5., 4., 2., nan, nan, nan, 1., 4., 3.],\n        [nan, nan, 1., nan, 4., 4., nan, nan, 3., nan],\n        [nan, 1., nan, nan, 3., nan, nan, nan, nan, 5.],\n        [4., nan, 2., nan, nan, nan, nan, nan, 4., 3.],\n        [4., nan, 3., nan, 3., nan, 4., 1., 1., nan],\n        [5., nan, 3., nan, 3., nan, nan, 1., nan, nan],\n        [2., 5., nan, 5., 3., 4., 3., 3., 5., 5.],\n        [3., 3., nan, nan, nan, nan, nan, nan, 4., nan],\n        [1., nan, 1., 3., 4., 1., nan, nan, 2., nan],\n        [nan, nan, 5., nan, nan, nan, 2., nan, 1., nan],\n        [3., 3., nan, nan, 2., 2., 3., 4., 4., nan],\n        [2., nan, nan, 2., nan, nan, nan, nan, nan, 4.],\n        [nan, 2., nan, 4., 5., 5., nan, 3., 5., nan],\n        [2., 2., 2., 4., nan, 4., nan, 1., nan, nan],\n        [5., 4., 5., 1., nan, 3., 5., 5., 1., 4.],\n        [2., nan, nan, 2., nan, nan, nan, nan, nan, nan],\n        [nan, 1., 5., nan, nan, nan, 2., 2., nan, nan],\n        [2., 3., 4., nan, nan, nan, 1., 4., 4., nan],\n        [2., nan, 1., 4., 1., 1., nan, 5., nan, 1.],\n        [5., nan, 3., 1., 5., nan, nan, nan, 2., nan],\n        [nan, 3., 4., nan, nan, 3., nan, 5., 5., nan],\n        [4., 3., 2., 3., nan, nan, nan, nan, 1., nan],\n        [1., 1., nan, 5., 1., 5., nan, nan, 5., nan],\n        [4., 5., nan, nan, nan, 3., nan, 2., 5., 5.],\n        [nan, 5., 5., nan, nan, nan, nan, 4., nan, nan],\n        [5., nan, 4., 2., 3., 3., nan, nan, 2., 1.],\n        [nan, nan, nan, nan, 5., nan, 2., 2., 4., nan],\n        [3., 5., 1., 5., 3., nan, 5., nan, 2., 4.],\n        [nan, 2., 4., nan, 1., 4., nan, 5., nan, 3.],\n        [5., 5., 2., 5., nan, 4., nan, 2., nan, 3.],\n        [5., nan, nan, 5., 1., 5., nan, nan, 3., 3.],\n        [nan, 4., 2., 5., nan, 2., 3., nan, nan, 1.],\n        [nan, nan, 4., 5., 5., nan, nan, 4., nan, 2.],\n        [nan, nan, nan, nan, nan, nan, nan, 1., 3., nan],\n        [3., 3., 1., 1., 1., 4., nan, nan, nan, 2.],\n        [nan, nan, nan, 4., 5., nan, nan, 3., nan, nan],\n        [5., nan, 5., 2., 4., nan, nan, nan, 5., nan],\n        [nan, 1., 1., nan, 3., 1., nan, 1., nan, 1.],\n        [nan, nan, 1., 2., nan, 3., nan, 2., 2., 4.],\n        [nan, nan, 5., 1., 3., 2., 2., nan, 1., nan],\n        [nan, 2., 2., nan, 4., nan, nan, nan, 3., nan],\n        [nan, nan, nan, nan, 5., 4., nan, 3., nan, nan],\n        [nan, 2., nan, nan, nan, nan, nan, 3., nan, nan],\n        [nan, 2., 5., 2., nan, 3., 4., nan, 1., 2.],\n        [1., nan, 1., nan, nan, 3., 4., 2., nan, 1.],\n        [nan, 4., 4., 1., nan, nan, 5., nan, nan, 2.],\n        [nan, nan, 3., nan, nan, 4., 1., nan, 3., nan],\n        [nan, 1., nan, 3., 2., 3., nan, 2., nan, 4.],\n        [2., 3., 3., nan, 1., 4., 3., nan, nan, 1.],\n        [5., nan, 3., 1., 1., nan, 4., nan, 3., nan],\n        [5., nan, nan, nan, nan, nan, 4., nan, nan, nan],\n        [2., nan, nan, 2., nan, nan, 2., 3., nan, 4.],\n        [3., nan, 4., 5., nan, nan, nan, 1., nan, 3.],\n        [3., 3., 1., nan, 2., 5., 5., nan, 2., nan],\n        [1., 1., 3., 1., nan, nan, 4., 3., 4., 5.],\n        [4., nan, nan, 5., 2., nan, 1., nan, nan, nan],\n        [nan, nan, 2., nan, 5., nan, 2., 1., nan, 4.],\n        [nan, 5., nan, 4., 3., 2., 2., 1., nan, 4.],\n        [nan, nan, 1., nan, nan, nan, 2., nan, nan, nan],\n        [1., nan, nan, 4., 5., 3., nan, 2., nan, nan],\n        [2., nan, 5., 1., 3., nan, 5., nan, nan, nan],\n        [3., 5., nan, nan, nan, 5., 2., nan, nan, 2.],\n        [nan, 2., 5., nan, nan, nan, 2., nan, 1., 2.],\n        [nan, 3., 2., nan, nan, 4., nan, 2., nan, 5.],\n        [nan, 4., 5., 2., 5., nan, nan, nan, nan, 5.],\n        [3., 1., 5., 3., nan, nan, nan, 3., nan, 4.],\n        [nan, 5., nan, 5., nan, 5., 1., 1., 3., 1.],\n        [2., nan, nan, nan, 5., nan, nan, 4., nan, 4.],\n        [nan, 3., 4., 2., nan, 2., nan, 2., nan, nan],\n        [nan, 5., nan, 2., 2., 4., 5., 5., nan, nan],\n        [nan, nan, nan, nan, nan, 5., nan, nan, 5., 4.],\n        [nan, nan, nan, nan, nan, 2., 2., 2., 2., 4.],\n        [nan, nan, nan, 2., 5., 3., 3., nan, nan, nan],\n        [1., 2., 4., 2., nan, 2., 5., 4., nan, 5.],\n        [4., nan, nan, 5., 4., nan, 5., 1., 3., nan],\n        [4., nan, 1., 4., nan, nan, 2., nan, 4., 3.],\n        [4., 2., 1., 3., nan, nan, 1., nan, nan, 1.],\n        [nan, 1., 3., 1., 2., nan, 3., nan, 5., nan],\n        [nan, 1., 1., nan, 1., 1., nan, 4., nan, nan],\n        [nan, nan, nan, nan, 1., 5., nan, 5., 3., nan],\n        [3., 4., nan, 4., 3., nan, 2., 1., nan, nan],\n        [1., 1., nan, 2., nan, nan, nan, 2., 4., 1.],\n        [nan, 4., 2., nan, 3., nan, 2., 1., nan, 2.],\n        [2., nan, 5., nan, 3., nan, 5., 1., nan, nan],\n        [3., 3., nan, nan, 3., 3., nan, 4., 2., nan],\n        [2., nan, 5., nan, 5., 3., nan, nan, 5., nan],\n        [nan, nan, nan, nan, 5., nan, nan, nan, nan, 5.],\n        [4., nan, nan, 1., 4., 5., 1., nan, 2., 4.],\n        [1., nan, nan, nan, 2., nan, 4., nan, nan, nan]])\n\n\n\nW, H, loss = factorize(A, 2)\nloss\n\ntensor(nan, grad_fn=<LinalgVectorNormBackward0>)\n\n\nAs expected, the above function does not work. Our current loss function does not handle missing values.\n\nmask = ~torch.isnan(A)\nmask\n\ntensor([[False,  True,  True, False,  True,  True,  True,  True, False,  True],\n        [False,  True,  True,  True, False, False, False, False,  True, False],\n        [False, False,  True,  True, False, False,  True, False, False, False],\n        [False, False, False,  True,  True,  True, False,  True, False,  True],\n        [False, False,  True, False,  True,  True, False, False,  True,  True],\n        [False,  True,  True, False,  True, False,  True, False,  True, False],\n        [False, False, False, False,  True,  True, False,  True, False,  True],\n        [False,  True, False,  True,  True, False,  True,  True,  True, False],\n        [False, False,  True,  True, False, False,  True, False, False,  True],\n        [False, False,  True,  True, False,  True,  True,  True,  True, False],\n        [False, False,  True, False, False, False,  True,  True, False,  True],\n        [False,  True,  True,  True, False, False, False,  True,  True,  True],\n        [False, False,  True, False,  True,  True, False, False,  True, False],\n        [False,  True, False, False,  True, False, False, False, False,  True],\n        [ True, False,  True, False, False, False, False, False,  True,  True],\n        [ True, False,  True, False,  True, False,  True,  True,  True, False],\n        [ True, False,  True, False,  True, False, False,  True, False, False],\n        [ True,  True, False,  True,  True,  True,  True,  True,  True,  True],\n        [ True,  True, False, False, False, False, False, False,  True, False],\n        [ True, False,  True,  True,  True,  True, False, False,  True, False],\n        [False, False,  True, False, False, False,  True, False,  True, False],\n        [ True,  True, False, False,  True,  True,  True,  True,  True, False],\n        [ True, False, False,  True, False, False, False, False, False,  True],\n        [False,  True, False,  True,  True,  True, False,  True,  True, False],\n        [ True,  True,  True,  True, False,  True, False,  True, False, False],\n        [ True,  True,  True,  True, False,  True,  True,  True,  True,  True],\n        [ True, False, False,  True, False, False, False, False, False, False],\n        [False,  True,  True, False, False, False,  True,  True, False, False],\n        [ True,  True,  True, False, False, False,  True,  True,  True, False],\n        [ True, False,  True,  True,  True,  True, False,  True, False,  True],\n        [ True, False,  True,  True,  True, False, False, False,  True, False],\n        [False,  True,  True, False, False,  True, False,  True,  True, False],\n        [ True,  True,  True,  True, False, False, False, False,  True, False],\n        [ True,  True, False,  True,  True,  True, False, False,  True, False],\n        [ True,  True, False, False, False,  True, False,  True,  True,  True],\n        [False,  True,  True, False, False, False, False,  True, False, False],\n        [ True, False,  True,  True,  True,  True, False, False,  True,  True],\n        [False, False, False, False,  True, False,  True,  True,  True, False],\n        [ True,  True,  True,  True,  True, False,  True, False,  True,  True],\n        [False,  True,  True, False,  True,  True, False,  True, False,  True],\n        [ True,  True,  True,  True, False,  True, False,  True, False,  True],\n        [ True, False, False,  True,  True,  True, False, False,  True,  True],\n        [False,  True,  True,  True, False,  True,  True, False, False,  True],\n        [False, False,  True,  True,  True, False, False,  True, False,  True],\n        [False, False, False, False, False, False, False,  True,  True, False],\n        [ True,  True,  True,  True,  True,  True, False, False, False,  True],\n        [False, False, False,  True,  True, False, False,  True, False, False],\n        [ True, False,  True,  True,  True, False, False, False,  True, False],\n        [False,  True,  True, False,  True,  True, False,  True, False,  True],\n        [False, False,  True,  True, False,  True, False,  True,  True,  True],\n        [False, False,  True,  True,  True,  True,  True, False,  True, False],\n        [False,  True,  True, False,  True, False, False, False,  True, False],\n        [False, False, False, False,  True,  True, False,  True, False, False],\n        [False,  True, False, False, False, False, False,  True, False, False],\n        [False,  True,  True,  True, False,  True,  True, False,  True,  True],\n        [ True, False,  True, False, False,  True,  True,  True, False,  True],\n        [False,  True,  True,  True, False, False,  True, False, False,  True],\n        [False, False,  True, False, False,  True,  True, False,  True, False],\n        [False,  True, False,  True,  True,  True, False,  True, False,  True],\n        [ True,  True,  True, False,  True,  True,  True, False, False,  True],\n        [ True, False,  True,  True,  True, False,  True, False,  True, False],\n        [ True, False, False, False, False, False,  True, False, False, False],\n        [ True, False, False,  True, False, False,  True,  True, False,  True],\n        [ True, False,  True,  True, False, False, False,  True, False,  True],\n        [ True,  True,  True, False,  True,  True,  True, False,  True, False],\n        [ True,  True,  True,  True, False, False,  True,  True,  True,  True],\n        [ True, False, False,  True,  True, False,  True, False, False, False],\n        [False, False,  True, False,  True, False,  True,  True, False,  True],\n        [False,  True, False,  True,  True,  True,  True,  True, False,  True],\n        [False, False,  True, False, False, False,  True, False, False, False],\n        [ True, False, False,  True,  True,  True, False,  True, False, False],\n        [ True, False,  True,  True,  True, False,  True, False, False, False],\n        [ True,  True, False, False, False,  True,  True, False, False,  True],\n        [False,  True,  True, False, False, False,  True, False,  True,  True],\n        [False,  True,  True, False, False,  True, False,  True, False,  True],\n        [False,  True,  True,  True,  True, False, False, False, False,  True],\n        [ True,  True,  True,  True, False, False, False,  True, False,  True],\n        [False,  True, False,  True, False,  True,  True,  True,  True,  True],\n        [ True, False, False, False,  True, False, False,  True, False,  True],\n        [False,  True,  True,  True, False,  True, False,  True, False, False],\n        [False,  True, False,  True,  True,  True,  True,  True, False, False],\n        [False, False, False, False, False,  True, False, False,  True,  True],\n        [False, False, False, False, False,  True,  True,  True,  True,  True],\n        [False, False, False,  True,  True,  True,  True, False, False, False],\n        [ True,  True,  True,  True, False,  True,  True,  True, False,  True],\n        [ True, False, False,  True,  True, False,  True,  True,  True, False],\n        [ True, False,  True,  True, False, False,  True, False,  True,  True],\n        [ True,  True,  True,  True, False, False,  True, False, False,  True],\n        [False,  True,  True,  True,  True, False,  True, False,  True, False],\n        [False,  True,  True, False,  True,  True, False,  True, False, False],\n        [False, False, False, False,  True,  True, False,  True,  True, False],\n        [ True,  True, False,  True,  True, False,  True,  True, False, False],\n        [ True,  True, False,  True, False, False, False,  True,  True,  True],\n        [False,  True,  True, False,  True, False,  True,  True, False,  True],\n        [ True, False,  True, False,  True, False,  True,  True, False, False],\n        [ True,  True, False, False,  True,  True, False,  True,  True, False],\n        [ True, False,  True, False,  True,  True, False, False,  True, False],\n        [False, False, False, False,  True, False, False, False, False,  True],\n        [ True, False, False,  True,  True,  True,  True, False,  True,  True],\n        [ True, False, False, False,  True, False,  True, False, False, False]])\n\n\n\nmask.sum()\n\ntensor(517)\n\n\n\nW = torch.randn(A.shape[0], k, requires_grad=True)\nH = torch.randn(k, A.shape[1],  requires_grad=True)\n\ndiff_matrix = torch.mm(W, H)-A\ndiff_matrix.shape\n\ntorch.Size([100, 10])\n\n\n\n# Mask the matrix\ndiff_matrix[mask].shape\n\ntorch.Size([517])\n\n\n\n# Modify the loss function to ignore NaN values\n\ndef factorize(A, k):\n    \"\"\"Factorize the matrix D into A and B\"\"\"\n    # Randomly initialize A and B\n    W = torch.randn(A.shape[0], k, requires_grad=True)\n    H = torch.randn(k, A.shape[1], requires_grad=True)\n    # Optimizer\n    optimizer = optim.Adam([W, H], lr=0.01)\n    \n    # Train the model\n    for i in range(1000):\n        # Compute the loss\n        diff_matrix = torch.mm(W, H) - A\n        diff_vector = diff_matrix[mask]\n        loss = torch.norm(diff_vector)\n        \n        # Zero the gradients\n        optimizer.zero_grad()\n        \n        # Backpropagate\n        loss.backward()\n        \n        # Update the parameters\n        optimizer.step()\n        \n    return W, H, loss\n\n\nW, H, loss = factorize(A, 5)\nloss\n\ntensor(7.1147, grad_fn=<LinalgVectorNormBackward0>)\n\n\n\ntorch.mm(W, H)\n\ntensor([[-3.7026e+00,  5.1163e+00,  4.9660e+00, -5.8455e-01,  1.0200e+00,\n          9.1470e-01,  3.8727e+00,  2.2007e+00,  1.3782e+01,  3.9267e+00],\n        [ 6.4588e-02,  2.0002e+00,  1.9979e+00,  1.0001e+00,  3.6942e+00,\n          1.1512e+00,  3.8181e+00,  3.5421e+00,  3.0014e+00,  5.0035e+00],\n        [-3.3540e-01, -1.0050e+00,  5.0000e+00,  1.0010e+00,  1.7959e-01,\n          8.6454e-01,  1.9994e+00,  2.9560e+00,  1.0767e+01, -3.4057e-01],\n        [ 2.6321e+00,  3.5523e+00,  2.1706e+00,  9.9769e-01,  3.9995e+00,\n          2.0030e+00,  2.8652e+00,  2.0006e+00,  3.5503e-02,  3.9991e+00],\n        [ 5.3195e-02, -1.3399e+00,  1.9455e+00,  2.2700e+00,  3.0539e+00,\n          1.0086e+00,  3.8842e+00,  5.1128e+00,  4.0248e+00,  3.9763e+00],\n        [ 5.5045e+00,  2.0044e+00,  4.9388e+00,  1.6216e+00,  2.0865e+00,\n          2.8957e+00,  9.2770e-01,  8.8714e-01,  3.0420e+00, -9.2438e-01],\n        [ 6.1366e-01, -1.3394e+00, -6.3292e+00,  4.0202e+00,  2.0028e+00,\n          1.0014e+00,  2.1030e+00,  3.0001e+00, -1.0639e+01,  4.9979e+00],\n        [ 1.6036e+00,  3.6518e+00,  3.7664e+00,  1.2319e+00,  5.1780e+00,\n          2.1295e+00,  4.7475e+00,  4.0635e+00,  4.0645e+00,  5.9223e+00],\n        [-4.1593e+00, -1.1450e+01,  2.0064e+00,  5.0104e+00,  1.7877e-01,\n         -6.8356e-01,  4.9576e+00,  1.0525e+01,  1.2403e+01,  2.0250e+00],\n        [ 1.7769e+00, -4.9137e+00,  3.1228e+00,  2.2575e+00,  5.8793e-01,\n          6.6961e-01,  1.2031e+00,  3.7871e+00,  4.9702e+00, -1.4083e+00],\n        [ 9.1273e+00,  1.4212e+00,  5.0018e+00, -1.0804e+00,  8.9608e+00,\n          1.6892e+00,  2.0130e+00,  1.9936e+00, -7.2410e+00,  2.9931e+00],\n        [ 3.2326e+00,  5.2245e+00,  3.8534e+00,  1.8050e+00,  2.7570e+00,\n          3.2246e+00,  2.7488e+00,  1.4501e+00,  3.9743e+00,  2.7026e+00],\n        [ 9.2220e-01,  6.5451e+00,  9.9373e-01,  4.2199e+00,  4.0030e+00,\n          4.0019e+00,  5.8552e+00,  4.3514e+00,  3.0028e+00,  8.0414e+00],\n        [-2.3552e+00,  1.0013e+00,  9.6726e-01, -4.6631e-01,  3.0005e+00,\n         -4.1134e-01,  3.3274e+00,  3.0678e+00,  3.0946e+00,  4.9978e+00],\n        [ 4.0009e+00,  5.9036e+00,  1.9983e+00,  6.0610e+00,  1.0184e+00,\n          5.6167e+00,  3.5338e+00,  2.5504e+00,  4.0003e+00,  3.0002e+00],\n        [ 4.1839e+00,  9.1531e+00,  2.5008e+00,  3.1248e+00,  3.4309e+00,\n          4.8701e+00,  3.6236e+00,  9.7109e-01,  1.3077e+00,  4.9725e+00],\n        [ 5.0034e+00, -2.6358e+00,  2.9996e+00, -3.1773e-01,  2.9981e+00,\n          3.3085e-01, -3.0125e-01,  1.0002e+00, -2.6015e+00, -1.5107e+00],\n        [ 2.1562e+00,  5.1078e+00,  2.3091e+00,  4.3035e+00,  2.3000e+00,\n          4.1470e+00,  4.2497e+00,  3.3351e+00,  4.7425e+00,  4.5406e+00],\n        [ 2.9999e+00,  2.9999e+00,  3.0624e+00,  4.4992e+00,  4.5262e+00,\n          3.8824e+00,  5.4591e+00,  5.5541e+00,  4.0005e+00,  5.9015e+00],\n        [ 8.1177e-01, -2.9699e+00,  1.2606e+00,  3.0946e+00,  3.9370e+00,\n          1.0488e+00,  4.3280e+00,  6.3317e+00,  1.8619e+00,  4.5940e+00],\n        [ 2.1477e+00,  2.4168e+00,  5.0014e+00, -3.6888e+00,  5.9741e+00,\n         -5.6343e-01,  1.9977e+00,  9.9599e-01,  1.0008e+00,  3.2156e+00],\n        [ 2.5660e+00,  2.4872e+00,  2.9711e+00,  3.0048e+00,  2.5035e+00,\n          2.9551e+00,  3.2466e+00,  3.1642e+00,  4.0380e+00,  2.8930e+00],\n        [ 2.0003e+00,  1.1864e+01, -1.4367e+00,  1.9999e+00,  4.6078e-01,\n          4.1701e+00,  1.3254e+00, -3.0082e+00, -2.7641e+00,  3.9993e+00],\n        [ 1.0449e+01,  2.0032e+00,  8.9659e+00,  3.6977e+00,  4.8085e+00,\n          5.2882e+00,  2.4920e+00,  3.2403e+00,  4.9395e+00, -8.7002e-01],\n        [ 2.0717e+00,  2.1115e+00,  2.0717e+00,  4.2801e+00, -2.0380e+00,\n          3.5172e+00,  9.3884e-01,  9.7155e-01,  6.2354e+00, -1.3328e+00],\n        [ 5.2955e+00,  3.4266e+00,  5.1299e+00,  1.4202e+00,  6.8671e+00,\n          2.9375e+00,  4.3992e+00,  3.9995e+00,  1.2817e+00,  5.0996e+00],\n        [ 2.0001e+00,  1.4791e+00,  2.3388e+00,  2.0000e+00, -6.6995e-01,\n          2.1166e+00,  4.5259e-01,  3.8568e-01,  4.1443e+00, -1.1447e+00],\n        [ 2.9065e+00,  1.0088e+00,  5.0003e+00, -4.4267e-01,  3.6696e+00,\n          1.0351e+00,  1.9735e+00,  2.0205e+00,  3.8361e+00,  1.3199e+00],\n        [ 2.3390e+00,  2.3721e+00,  3.7185e+00,  1.3874e+00,  2.8777e+00,\n          2.1103e+00,  2.7381e+00,  2.4701e+00,  4.1805e+00,  2.4318e+00],\n        [ 1.7971e+00, -4.8495e+00,  9.1239e-01,  3.9631e+00,  1.2733e+00,\n          1.2781e+00,  2.2735e+00,  5.0206e+00,  1.8186e+00,  7.7334e-01],\n        [ 4.4556e+00,  1.2257e+01,  3.8113e+00,  1.3722e+00,  4.8218e+00,\n          4.8774e+00,  3.8956e+00, -1.3451e-01,  1.5725e+00,  6.1126e+00],\n        [ 2.3871e+00,  3.0010e+00,  3.9991e+00,  2.8334e+00,  4.8395e+00,\n          2.9996e+00,  5.1329e+00,  5.0009e+00,  5.0012e+00,  5.6052e+00],\n        [ 3.9920e+00,  3.0004e+00,  2.0131e+00,  3.0049e+00,  1.3189e+00,\n          3.2595e+00,  1.5054e+00,  1.0929e+00,  9.9195e-01,  8.6129e-01],\n        [ 1.3517e+00,  1.3225e+00,  1.2075e+00,  5.6267e+00,  9.9029e-01,\n          3.6713e+00,  4.0205e+00,  4.6894e+00,  5.0908e+00,  3.3918e+00],\n        [ 3.9141e+00,  5.4294e+00,  6.3565e+00,  3.9410e-02,  5.9122e+00,\n          2.6582e+00,  4.0295e+00,  2.6446e+00,  4.8764e+00,  4.5279e+00],\n        [ 5.9703e+00,  5.0000e+00,  5.0006e+00,  5.4552e+00,  3.4764e+00,\n          5.7107e+00,  4.4197e+00,  3.9984e+00,  5.4614e+00,  3.3112e+00],\n        [ 4.9808e+00,  2.5274e+00,  4.0592e+00,  2.0167e+00,  2.9650e+00,\n          2.9926e+00,  1.9145e+00,  1.7219e+00,  1.9706e+00,  1.0164e+00],\n        [ 3.3675e+00,  7.9931e-01,  6.4143e+00, -1.9437e+00,  5.0061e+00,\n          3.9840e-01,  1.9918e+00,  2.0016e+00,  4.0036e+00,  1.4088e+00],\n        [ 3.1524e+00,  4.8411e+00,  1.3102e+00,  5.0749e+00,  2.6352e+00,\n          4.5228e+00,  4.2075e+00,  3.4787e+00,  2.0158e+00,  4.7858e+00],\n        [ 1.1647e+00,  2.0442e+00,  3.9774e+00,  5.2040e+00,  1.0064e+00,\n          3.9541e+00,  4.5550e+00,  5.0695e+00,  1.0370e+01,  2.9545e+00],\n        [ 4.9155e+00,  4.8887e+00,  1.8611e+00,  4.5726e+00,  2.4214e+00,\n          4.6615e+00,  2.9405e+00,  2.1223e+00,  4.9785e-01,  2.9426e+00],\n        [ 4.6095e+00,  7.0277e+00,  2.3640e+00,  4.9826e+00,  1.3639e+00,\n          5.4668e+00,  2.9430e+00,  1.3600e+00,  2.9275e+00,  2.6572e+00],\n        [-9.4300e+00,  3.9400e+00,  1.8115e+00,  4.6790e+00, -7.7135e+00,\n          2.3401e+00,  3.3902e+00,  2.5588e+00,  2.3759e+01,  7.8572e-01],\n        [ 8.8489e+00,  1.3677e+00,  4.0011e+00,  4.9984e+00,  5.0002e+00,\n          4.8811e+00,  3.1127e+00,  4.0020e+00, -1.6249e+00,  1.9996e+00],\n        [-5.3638e+00, -1.6611e+01, -1.2622e+00, -2.9465e+00, -5.3122e+00,\n         -6.6081e+00, -4.5960e+00,  1.0021e+00,  3.0004e+00, -8.7048e+00],\n        [ 2.9505e+00,  3.4944e+00,  1.0966e+00,  2.0104e+00,  1.4645e+00,\n          2.5452e+00,  1.3437e+00,  4.9608e-01, -3.2980e-01,  1.5523e+00],\n        [ 8.8610e+00,  3.4098e+00,  5.4534e+00,  4.0010e+00,  5.0039e+00,\n          5.0527e+00,  2.9819e+00,  2.9969e+00,  4.8445e-01,  1.7580e+00],\n        [ 4.7645e+00,  7.2438e+00,  5.3527e+00,  2.1598e+00,  3.9257e+00,\n          4.3363e+00,  3.5150e+00,  1.6544e+00,  4.8212e+00,  3.4858e+00],\n        [ 3.6301e+00,  8.2968e-01,  1.0952e+00,  5.1852e-01,  2.9273e+00,\n          1.1501e+00,  7.9266e-01,  7.6517e-01, -3.4503e+00,  1.2149e+00],\n        [ 1.2349e+00,  4.7494e+00,  1.1553e+00,  2.2902e+00,  2.1858e+00,\n          2.6806e+00,  3.0526e+00,  1.8136e+00,  1.9800e+00,  4.0943e+00],\n        [ 5.4207e+00,  4.6174e-01,  4.6315e+00,  1.0934e+00,  3.5323e+00,\n          2.1171e+00,  1.4216e+00,  1.9254e+00,  1.2497e+00,  1.5768e-01],\n        [ 8.0981e-01,  1.9982e+00,  1.9823e+00,  2.3342e+00,  4.0156e+00,\n          1.9755e+00,  4.5111e+00,  4.4963e+00,  3.0107e+00,  5.5846e+00],\n        [ 3.4230e+00,  6.7811e+00,  1.3001e+00,  3.2712e+00,  5.0004e+00,\n          4.0008e+00,  4.7148e+00,  2.9985e+00, -8.9564e-01,  6.9733e+00],\n        [ 4.3992e+00,  1.9999e+00,  1.7722e+00,  3.3742e+00,  3.4675e+00,\n          3.1595e+00,  2.8761e+00,  3.0001e+00, -8.2256e-01,  3.0558e+00],\n        [ 6.3852e+00,  1.8676e+00,  5.1417e+00,  2.1083e+00,  5.4183e+00,\n          3.1672e+00,  3.1282e+00,  3.3945e+00,  1.0754e+00,  2.5551e+00],\n        [ 8.1366e-01,  2.6100e+00,  1.2431e+00,  4.6053e+00, -7.3305e-01,\n          3.4299e+00,  2.5706e+00,  2.4739e+00,  5.9303e+00,  1.5624e+00],\n        [-1.5185e+01,  3.9601e+00,  4.1178e+00,  1.1159e+00, -7.8194e+00,\n         -2.6153e-01,  4.5528e+00,  3.2349e+00,  3.2557e+01,  2.2662e+00],\n        [ 4.1539e+00,  6.2482e+00,  3.0004e+00,  2.5108e+00,  4.1870e-01,\n          4.0017e+00,  9.9885e-01, -7.3851e-01,  2.9998e+00,  1.7461e-01],\n        [ 2.4292e+00,  1.3324e+00, -2.4186e+00,  3.4744e+00,  2.2288e+00,\n          2.2009e+00,  2.0940e+00,  2.1399e+00, -5.7555e+00,  3.6885e+00],\n        [ 2.2950e+00,  2.9436e+00,  3.1712e+00,  4.1268e+00,  5.4157e-01,\n          3.7216e+00,  2.8408e+00,  2.7181e+00,  6.7460e+00,  1.4747e+00],\n        [ 5.0664e+00,  4.5652e+01,  2.7328e+00,  1.0374e+00,  1.2891e+00,\n          1.3143e+01,  3.7184e+00, -1.3608e+01,  3.1697e+00,  1.1363e+01],\n        [ 5.0006e+00,  6.9239e+00,  9.1918e-01,  7.2628e+00,  1.5445e+00,\n          6.5242e+00,  4.0004e+00,  2.7856e+00,  1.5080e+00,  4.0918e+00],\n        [ 2.0015e+00, -1.7211e+00, -2.6718e+00,  1.9970e+00,  3.6355e+00,\n          4.8944e-01,  2.0002e+00,  3.0038e+00, -7.9397e+00,  3.9988e+00],\n        [ 2.9915e+00,  1.0068e+01,  4.0126e+00,  5.0140e+00,  2.1576e-01,\n          6.2162e+00,  3.6692e+00,  9.8564e-01,  9.0477e+00,  2.9998e+00],\n        [ 3.1704e+00,  3.0173e+00,  6.3333e-01,  6.8363e+00,  2.2725e+00,\n          4.9317e+00,  4.7652e+00,  5.0099e+00,  2.2206e+00,  4.9007e+00],\n        [ 7.5330e-01,  1.4262e+00,  3.0599e+00,  8.5747e-01,  4.0712e+00,\n          1.1776e+00,  3.8169e+00,  3.8298e+00,  3.8094e+00,  4.5052e+00],\n        [ 4.0428e+00, -2.0650e+01,  2.4385e+00,  4.9425e+00,  1.9279e+00,\n         -1.5739e+00,  1.0876e+00,  1.0297e+01,  9.8782e-01, -4.4288e+00],\n        [ 1.0773e+00,  2.2150e+00,  2.0096e+00, -2.4710e+00,  4.9950e+00,\n         -5.0779e-01,  1.9650e+00,  1.0100e+00, -1.8899e+00,  4.0205e+00],\n        [ 3.4996e+00,  4.5594e+00, -2.5208e+00,  3.3402e+00,  2.6908e+00,\n          3.0928e+00,  2.0393e+00,  8.1359e-01, -7.3751e+00,  4.3822e+00],\n        [-4.8442e+00,  3.4518e+00,  9.9972e-01, -1.2881e+00, -3.5755e-01,\n         -5.3701e-01,  1.9997e+00,  4.9337e-01,  7.5069e+00,  3.0513e+00],\n        [ 1.0026e+00,  7.6105e+00, -7.1104e+00,  3.9509e+00,  4.9733e+00,\n          3.0444e+00,  4.5575e+00,  2.0356e+00, -1.3359e+01,  1.0958e+01],\n        [ 1.9708e+00,  2.2459e+01,  5.0115e+00,  1.0357e+00,  3.0386e+00,\n          7.0322e+00,  4.9501e+00, -3.0939e+00,  8.5776e+00,  8.3022e+00],\n        [ 3.0000e+00,  5.0024e+00, -1.4123e+00,  6.3346e+00, -9.3349e-01,\n          4.9944e+00,  2.0182e+00,  1.1012e+00, -1.8768e-01,  1.9884e+00],\n        [ 4.4226e+00,  2.0069e+00,  5.0098e+00, -8.1680e-01,  5.0611e+00,\n          1.2995e+00,  1.9966e+00,  1.6425e+00,  9.9608e-01,  1.9906e+00],\n        [ 1.1858e+01,  3.1806e+00,  1.9399e+00,  2.0242e+00,  9.7272e+00,\n          3.8295e+00,  2.5867e+00,  2.2628e+00, -1.4185e+01,  4.8150e+00],\n        [ 3.0139e+00,  4.0015e+00,  4.9996e+00,  2.0000e+00,  5.0004e+00,\n          3.0423e+00,  4.6969e+00,  4.0977e+00,  5.4217e+00,  4.9981e+00],\n        [ 3.1070e+00,  1.5608e+00,  4.4961e+00,  2.4194e+00,  3.9092e+00,\n          2.6510e+00,  3.8237e+00,  4.1656e+00,  5.0091e+00,  3.2677e+00],\n        [ 3.6123e+00,  5.0130e+00,  1.2513e+00,  5.0780e+00, -6.2890e-01,\n          4.7738e+00,  1.7050e+00,  7.5555e-01,  2.9369e+00,  7.0034e-01],\n        [ 1.9988e+00, -1.0755e+00,  2.1010e+00,  4.8154e-01,  5.0034e+00,\n          4.1238e-01,  3.1198e+00,  4.0017e+00, -6.4504e-01,  3.9979e+00],\n        [-2.4511e+00,  3.0049e+00,  4.0049e+00,  2.0168e+00, -1.7567e+00,\n          1.9773e+00,  2.5612e+00,  1.9963e+00,  1.3746e+01,  7.7954e-01],\n        [ 1.2900e+00,  4.8906e+00,  1.2285e+01,  2.0178e+00,  2.0017e+00,\n          4.0381e+00,  5.2765e+00,  4.7427e+00,  2.3263e+01,  1.4459e+00],\n        [ 3.4409e+00,  1.6323e+00,  2.1447e+00,  7.1434e+00,  2.1349e+00,\n          4.9995e+00,  4.9455e+00,  5.8905e+00,  5.0000e+00,  4.0006e+00],\n        [-8.3402e+00,  1.6671e+00, -9.7906e+00,  7.5550e+00, -7.1860e+00,\n          1.9594e+00,  2.1880e+00,  1.9448e+00,  1.9841e+00,  3.9175e+00],\n        [ 6.1855e+00,  1.0277e+00,  6.0344e+00,  2.0010e+00,  5.0009e+00,\n          2.9985e+00,  3.0008e+00,  3.6213e+00,  3.0914e+00,  1.7165e+00],\n        [ 9.9264e-01,  2.2125e+00,  3.9075e+00,  1.8425e+00,  4.0571e+00,\n          2.0497e+00,  4.5854e+00,  4.5379e+00,  6.0676e+00,  4.9087e+00],\n        [ 4.1464e+00,  1.4062e+01,  2.4284e+00,  4.7693e+00,  3.6919e+00,\n          6.9404e+00,  5.3224e+00,  1.0755e+00,  2.9501e+00,  7.6420e+00],\n        [ 3.7800e+00,  1.9199e+01,  1.3223e+00,  4.2259e+00, -1.6001e+00,\n          7.9395e+00,  1.7065e+00, -4.9606e+00,  3.8810e+00,  3.1246e+00],\n        [ 4.0234e+00,  2.0156e+00,  9.3090e-01,  2.9352e+00,  1.4458e+00,\n          2.8364e+00,  1.1944e+00,  1.0778e+00, -1.3489e+00,  8.8513e-01],\n        [ 2.9993e-01,  1.0106e+00,  2.8743e+00,  1.0596e+00,  2.1897e+00,\n          1.1528e+00,  2.7986e+00,  2.9140e+00,  5.0939e+00,  2.6367e+00],\n        [-2.7522e+00,  1.0011e+00,  9.9939e-01,  2.1638e+00,  9.9803e-01,\n          9.9864e-01,  3.8559e+00,  4.0029e+00,  6.9205e+00,  4.3317e+00],\n        [ 4.8687e+00, -1.5672e-01,  1.6703e+00,  7.5356e+00,  9.9502e-01,\n          4.9990e+00,  3.3880e+00,  5.0098e+00,  2.9938e+00,  1.4576e+00],\n        [ 3.0192e+00,  3.9819e+00, -5.9198e+00,  3.9832e+00,  2.9753e+00,\n          2.7502e+00,  2.0750e+00,  9.5908e-01, -1.2959e+01,  5.9251e+00],\n        [ 1.0148e+00,  9.7130e-01,  1.9768e+00,  2.0122e+00,  6.6718e-01,\n          1.7201e+00,  1.7755e+00,  1.9466e+00,  4.0138e+00,  1.0400e+00],\n        [ 5.3930e+00,  4.0298e+00,  2.0109e+00,  2.7548e+00,  2.9962e+00,\n          3.5641e+00,  1.8677e+00,  1.0778e+00, -1.7539e+00,  2.0255e+00],\n        [ 1.9953e+00,  1.2843e+01,  5.0056e+00,  2.5516e+00,  2.9983e+00,\n          5.4422e+00,  5.0090e+00,  9.8768e-01,  8.9960e+00,  6.2394e+00],\n        [ 2.8324e+00,  2.8434e+00,  1.9018e+00,  3.8000e+00,  3.1922e+00,\n          3.3458e+00,  3.8883e+00,  3.7678e+00,  2.0126e+00,  4.2686e+00],\n        [ 2.0652e+00,  8.7485e+00,  4.9003e+00, -7.1472e-02,  5.0456e+00,\n          2.9448e+00,  4.2957e+00,  1.4602e+00,  5.0622e+00,  6.0046e+00],\n        [ 1.2368e+00, -8.0124e-01,  4.5406e-01,  5.8132e-01,  5.0025e+00,\n          1.8401e-01,  3.2316e+00,  3.9075e+00, -2.7376e+00,  4.9980e+00],\n        [ 4.4707e+00,  1.3100e+01,  3.8913e+00,  5.0670e-01,  3.1494e+00,\n          4.7096e+00,  2.2617e+00, -2.3287e+00,  1.8589e+00,  3.9039e+00],\n        [ 9.9929e-01,  1.5253e+01,  2.1834e-03,  2.6820e+00,  2.0005e+00,\n          5.3245e+00,  3.9995e+00, -1.3442e+00,  1.4326e+00,  7.5636e+00]],\n       grad_fn=<MmBackward0>)\n\n\n\n# Now use matrix factorization to predict the ratings\n\nimport torch\nimport torch.nn as nn\nimport torch.nn.functional as F\n\n# Create a class for the model\n\nclass MatrixFactorization(nn.Module):\n    def __init__(self, n_users, n_movies, n_factors=20):\n        super().__init__()\n        self.user_factors = nn.Embedding(n_users, n_factors)\n        self.movie_factors = nn.Embedding(n_movies, n_factors)\n\n    def forward(self, user, movie):\n        return (self.user_factors(user) * self.movie_factors(movie)).sum(1)      \n\n\nmodel = MatrixFactorization(n_users, n_movies, 2)\nmodel\n\nMatrixFactorization(\n  (user_factors): Embedding(100, 2)\n  (movie_factors): Embedding(10, 2)\n)\n\n\n\nmodel(torch.tensor([0]), torch.tensor([2]))\n\ntensor([-0.0271], grad_fn=<SumBackward1>)\n\n\n\nA[0, 2]\n\ntensor(5.)\n\n\n\ntype(A)\n\ntorch.Tensor\n\n\n\nmask = ~torch.isnan(A)\n\n# Get the indices of the non-NaN values\ni, j = torch.where(mask)\n\n# Get the values of the non-NaN values\nv = A[mask]\n\n# Store in PyTorch tensors\nusers = i.to(torch.int64)\nmovies = j.to(torch.int64)\nratings = v.to(torch.float32)\n\n\npd.DataFrame({'user': users, 'movie': movies, 'rating': ratings})\n\n\n\n\n\n  \n    \n      \n      user\n      movie\n      rating\n    \n  \n  \n    \n      0\n      0\n      1\n      5.0\n    \n    \n      1\n      0\n      2\n      5.0\n    \n    \n      2\n      0\n      4\n      1.0\n    \n    \n      3\n      0\n      5\n      1.0\n    \n    \n      4\n      0\n      6\n      4.0\n    \n    \n      ...\n      ...\n      ...\n      ...\n    \n    \n      512\n      98\n      8\n      2.0\n    \n    \n      513\n      98\n      9\n      4.0\n    \n    \n      514\n      99\n      0\n      1.0\n    \n    \n      515\n      99\n      4\n      2.0\n    \n    \n      516\n      99\n      6\n      4.0\n    \n  \n\n517 rows × 3 columns\n\n\n\n\n# Fit the Matrix Factorization model\nmodel = MatrixFactorization(n_users, n_movies, 4)\noptimizer = optim.Adam(model.parameters(), lr=0.01)\n\nfor i in range(1000):\n    # Compute the loss\n    pred = model(users, movies)\n    loss = F.mse_loss(pred, ratings)\n    \n    # Zero the gradients\n    optimizer.zero_grad()\n    \n    # Backpropagate\n    loss.backward()\n    \n    # Update the parameters\n    optimizer.step()\n    \n    # Print the loss\n    if i % 100 == 0:\n        print(loss.item())\n\n14.604362487792969\n4.332712650299072\n1.0960761308670044\n0.6966323852539062\n0.5388827919960022\n0.45243579149246216\n0.4012693464756012\n0.3728969395160675\n0.35568001866340637\n0.34289655089378357\n\n\n\nmodel(users, movies)\n\ntensor([3.5693, 4.5338, 2.6934, 1.8316, 4.8915, 2.0194, 2.7778, 1.8601, 2.1124,\n        1.1378, 2.9079, 5.0470, 0.9911, 1.9791, 1.0050, 3.9618, 2.0085, 2.0034,\n        4.0113, 1.9218, 2.9801, 1.0432, 3.8993, 4.1292, 1.9357, 3.8285, 3.5266,\n        1.3640, 2.3989, 2.4166, 0.8559, 3.3685, 4.4493, 3.4018, 1.4722, 4.8378,\n        4.6684, 4.4473, 4.3097, 2.0022, 5.0147, 5.0113, 1.9599, 2.8305, 1.4493,\n        1.6750, 0.9520, 3.8460, 5.1279, 4.7453, 2.1484, 1.8009, 3.2104, 4.2068,\n        4.5473, 2.9229, 1.1817, 3.1108, 3.2157, 1.2238, 3.6272, 3.9029, 3.2554,\n        0.9945, 3.0062, 5.0030, 4.1144, 1.6314, 3.7945, 3.3091, 4.0727, 3.6212,\n        2.4359, 3.5707, 1.2826, 0.9663, 4.9973, 3.0163, 2.9916, 1.0014, 3.1734,\n        3.8712, 4.3364, 3.7119, 4.5313, 2.3875, 4.0274, 4.7121, 4.3851, 2.8072,\n        3.2066, 3.9684, 0.9307, 1.4160, 2.7484, 2.8771, 1.2753, 2.5825, 4.9857,\n        2.0109, 1.0080, 2.2618, 2.7936, 2.5859, 3.0972, 3.1443, 3.8655, 3.2023,\n        2.0061, 1.9866, 4.0068, 2.7861, 4.2803, 4.5452, 3.8177, 2.9951, 5.6040,\n        1.9013, 2.4498, 1.9155, 4.3239, 3.2993, 1.1275, 4.1460, 4.3619, 4.5913,\n        1.1365, 3.0865, 6.0992, 3.9207, 1.8325, 3.8526, 2.0000, 2.0000, 1.0255,\n        5.0484, 1.9858, 1.9716, 2.0854, 2.7726, 3.5053, 1.7365, 3.2607, 4.7006,\n        1.8830, 0.3378, 2.6222, 0.6491, 3.1144, 3.8404, 2.0632, 4.3311, 4.6138,\n        1.6119, 3.0444, 2.4498, 2.7860, 4.0832, 3.2681, 5.0069, 4.8745, 3.6048,\n        3.5065, 1.8871, 2.9108, 0.9982, 0.6787, 1.4787, 5.6890, 1.5117, 4.0205,\n        4.6624, 4.1051, 4.5437, 3.5410, 1.8761, 4.6653, 5.2577, 5.0311, 4.9531,\n        4.0022, 4.7229, 4.0406, 2.5056, 3.2014, 2.9312, 1.3051, 1.3258, 4.9233,\n        2.0871, 1.8761, 4.1304, 3.9279, 4.5547, 1.6639, 4.3163, 1.8149, 4.7431,\n        3.4398, 3.5483, 3.2541, 2.8282, 1.5230, 2.8214, 4.9214, 3.5371, 4.4522,\n        4.7928, 2.4932, 4.8619, 4.7693, 2.3121, 2.3021, 4.6609, 4.7478, 1.7768,\n        5.3910, 2.8929, 2.4920, 4.1654, 1.8382, 3.4456, 3.7108, 2.3989, 1.0480,\n        4.2870, 5.2730, 3.8976, 3.2956, 3.1010, 0.9666, 3.0227, 2.9491, 3.2218,\n        1.4033, 1.7050, 0.5457, 3.1223, 2.1794, 3.9939, 5.0190, 2.9944, 4.5670,\n        5.4131, 2.4720, 4.0239, 4.5689, 0.9386, 1.1827, 2.1553, 1.4232, 0.4127,\n        1.7502, 1.5601, 2.0953, 2.3530, 2.7085, 2.7157, 2.7900, 4.6793, 1.1711,\n        3.4493, 1.7701, 2.1576, 0.8294, 1.9908, 2.1975, 3.6396, 3.1952, 4.9882,\n        4.0091, 2.9998, 1.9985, 3.0063, 3.7149, 4.2018, 1.1992, 2.2550, 3.5132,\n        1.3794, 2.4434, 2.0220, 0.6691, 1.9927, 3.4666, 2.8342, 1.0393, 4.1834,\n        4.0819, 0.8652, 4.8585, 2.0225, 2.9662, 3.9794, 1.0412, 3.0180, 1.0117,\n        3.1728, 2.6027, 2.5184, 2.5120, 3.3483, 3.0602, 3.2139, 1.9144, 1.4899,\n        2.8253, 2.9160, 1.6410, 3.8484, 2.9637, 2.1272, 2.0490, 4.4915, 1.6853,\n        5.0641, 3.9315, 1.8812, 2.1028, 2.1203, 2.8898, 4.0215, 3.3032, 3.6131,\n        4.8380, 0.7513, 3.4182, 3.0527, 3.6200, 1.3040, 1.1657, 4.2705, 4.8569,\n        2.7037, 0.9142, 1.5261, 3.3970, 0.6980, 3.1131, 3.8348, 3.4478, 4.9488,\n        4.0077, 4.9673, 2.0816, 0.9995, 3.4965, 3.2899, 1.0624, 1.4977, 4.3810,\n        4.2225, 3.1540, 4.0191, 3.4060, 2.0160, 1.2814, 2.9608, 1.1513, 1.9530,\n        0.9872, 3.9914, 4.9865, 3.0477, 1.9701, 2.5473, 4.6173, 0.5252, 3.4813,\n        4.7750, 3.5971, 4.1422, 5.2524, 2.0691, 2.0039, 2.1420, 5.0156, 1.8481,\n        0.7781, 2.2183, 2.6443, 2.2889, 4.3373, 2.2449, 4.5594, 3.8624, 5.2333,\n        2.1537, 4.7373, 5.0298, 2.1322, 2.7047, 4.2308, 2.4907, 2.3259, 4.7678,\n        5.0266, 5.2597, 4.7697, 0.9911, 1.0440, 2.7818, 1.1585, 2.1967, 4.4422,\n        3.4151, 4.8498, 2.8759, 4.0001, 1.8111, 2.3611, 1.9162, 4.3893, 2.4916,\n        2.0815, 3.9944, 5.5013, 4.6856, 4.9904, 4.9865, 4.0133, 1.7178, 2.2895,\n        1.9270, 2.6042, 3.5529, 2.0969, 4.9558, 2.9138, 3.0347, 1.6650, 2.2754,\n        3.7474, 0.9570, 2.3175, 4.1652, 4.4857, 5.1715, 5.4181, 3.7923, 4.0080,\n        3.5960, 2.1456, 2.9088, 3.2796, 1.2589, 4.6664, 2.3447, 3.6577, 2.8478,\n        2.8383, 2.9852, 0.9179, 3.0814, 1.2291, 0.7621, 0.8185, 2.3877, 1.1364,\n        2.8636, 3.2811, 4.5790, 0.7829, 1.2192, 0.8060, 1.2341, 3.9681, 1.1422,\n        4.9521, 5.1383, 2.8294, 3.6377, 3.8734, 3.5638, 2.9749, 1.5051, 1.4258,\n        0.5846, 1.0630, 2.7671, 1.7912, 2.8734, 1.8916, 3.9858, 2.5439, 2.6786,\n        1.6704, 1.3576, 1.7701, 2.0514, 5.1632, 2.6842, 4.8280, 1.1577, 2.9727,\n        3.3256, 2.7693, 2.6430, 4.0140, 2.2755, 2.1973, 4.6792, 5.3522, 2.8058,\n        4.9664, 5.2983, 4.7749, 3.8326, 2.4944, 4.2989, 2.8784, 2.0605, 2.8428,\n        3.1081, 1.0411, 1.9078, 3.9594], grad_fn=<SumBackward1>)\n\n\n\n# Now, let's predict the ratings for our df dataframe\n\nA = torch.from_numpy(df.values)\nA.shape\n\ntorch.Size([45, 10])\n\n\n\nmask = ~torch.isnan(A)\n\n# Get the indices of the non-NaN values\ni, j = torch.where(mask)\n\n# Get the values of the non-NaN values\nv = A[mask]\n\n# Store in PyTorch tensors\nusers = i.to(torch.int64)\nmovies = j.to(torch.int64)\nratings = v.to(torch.float32)\n\n\npd.DataFrame({'user': users, 'movie': movies, 'rating': ratings})\n\n\n\n\n\n  \n    \n      \n      user\n      movie\n      rating\n    \n  \n  \n    \n      0\n      0\n      0\n      4.0\n    \n    \n      1\n      0\n      1\n      5.0\n    \n    \n      2\n      0\n      2\n      4.0\n    \n    \n      3\n      0\n      3\n      4.0\n    \n    \n      4\n      0\n      4\n      5.0\n    \n    \n      ...\n      ...\n      ...\n      ...\n    \n    \n      371\n      44\n      3\n      4.0\n    \n    \n      372\n      44\n      4\n      4.0\n    \n    \n      373\n      44\n      5\n      4.0\n    \n    \n      374\n      44\n      6\n      4.0\n    \n    \n      375\n      44\n      7\n      5.0\n    \n  \n\n376 rows × 3 columns\n\n\n\n\n# Fit the Matrix Factorization model\nn_users = A.shape[0]\nn_movies = A.shape[1]\nmodel = MatrixFactorization(n_users, n_movies, 4)\noptimizer = optim.Adam(model.parameters(), lr=0.01)\n\nfor i in range(1000):\n    # Compute the loss\n    pred = model(users, movies)\n    loss = F.mse_loss(pred, ratings)\n    \n    # Zero the gradients\n    optimizer.zero_grad()\n    \n    # Backpropagate\n    loss.backward()\n    \n    # Update the parameters\n    optimizer.step()\n    \n    # Print the loss\n    if i % 100 == 0:\n        print(loss.item())\n\n19.889324188232422\n3.1148574352264404\n0.6727441549301147\n0.5543633103370667\n0.5081750750541687\n0.4629250764846802\n0.4147825837135315\n0.36878159642219543\n0.32987719774246216\n0.29975879192352295\n\n\n\n# Now, let us predict the ratings for any user and movie from df for which we already have the ratings\n\nusername = 'Dhruv'\nmovie = 'The Dark Knight'\n\n# Get the user and movie indices\nuser_idx = df.index.get_loc(username)\nmovie_idx = df.columns.get_loc(movie)\n\n# Predict the rating\npred = model(torch.tensor([user_idx]), torch.tensor([movie_idx]))\npred.item(), df.loc[username, movie]\n\n(5.259384632110596, 5.0)\n\n\n\ndf.loc[username]\n\nSholay                      NaN\nSwades (We The People)      NaN\nThe Matrix (I)              5.0\nInterstellar                5.0\nDangal                      3.0\nTaare Zameen Par            NaN\nShawshank Redemption        5.0\nThe Dark Knight             5.0\nNotting Hill                4.0\nUri: The Surgical Strike    5.0\nName: Dhruv, dtype: float64\n\n\n\n# Now, let us predict the ratings for any user and movie from df for which we do not have the ratings\n\nusername = 'Dhruv'\nmovie = 'Sholay'\n\n# Get the user and movie indices\nuser_idx = df.index.get_loc(username)\nmovie_idx = df.columns.get_loc(movie)\n\n# Predict the rating\npred = model(torch.tensor([user_idx]), torch.tensor([movie_idx]))\npred, df.loc[username, movie]\n\n(tensor([3.7885], grad_fn=<SumBackward1>), nan)\n\n\n\n# Complete the matrix\nwith torch.no_grad():\n    completed_matrix = pd.DataFrame(model.user_factors.weight @ model.movie_factors.weight.t(), index=df.index, columns=df.columns)\n    # round to nearest integer\n    completed_matrix = completed_matrix.round()\n\n\ncompleted_matrix.head()\n\n\n\n\n\n  \n    \n      \n      Sholay\n      Swades (We The People)\n      The Matrix (I)\n      Interstellar\n      Dangal\n      Taare Zameen Par\n      Shawshank Redemption\n      The Dark Knight\n      Notting Hill\n      Uri: The Surgical Strike\n    \n    \n      Your name\n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n    \n  \n  \n    \n      Nipun\n      5.0\n      4.0\n      4.0\n      5.0\n      4.0\n      5.0\n      5.0\n      4.0\n      4.0\n      5.0\n    \n    \n      Gautam Vashishtha\n      3.0\n      3.0\n      4.0\n      4.0\n      2.0\n      3.0\n      4.0\n      5.0\n      4.0\n      3.0\n    \n    \n      Eshan Gujarathi\n      4.0\n      4.0\n      5.0\n      5.0\n      4.0\n      4.0\n      5.0\n      5.0\n      4.0\n      4.0\n    \n    \n      Sai Krishna Avula\n      4.0\n      4.0\n      3.0\n      4.0\n      4.0\n      6.0\n      4.0\n      3.0\n      3.0\n      4.0\n    \n    \n      Ankit Yadav\n      3.0\n      2.0\n      3.0\n      4.0\n      3.0\n      5.0\n      4.0\n      3.0\n      3.0\n      4.0\n    \n  \n\n\n\n\n\ndf.head()\n\n\n\n\n\n  \n    \n      \n      Sholay\n      Swades (We The People)\n      The Matrix (I)\n      Interstellar\n      Dangal\n      Taare Zameen Par\n      Shawshank Redemption\n      The Dark Knight\n      Notting Hill\n      Uri: The Surgical Strike\n    \n    \n      Your name\n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n    \n  \n  \n    \n      Nipun\n      4.0\n      5.0\n      4.0\n      4.0\n      5.0\n      5.0\n      4.0\n      5.0\n      4.0\n      5.0\n    \n    \n      Gautam Vashishtha\n      3.0\n      4.0\n      4.0\n      5.0\n      3.0\n      1.0\n      5.0\n      5.0\n      4.0\n      3.0\n    \n    \n      Eshan Gujarathi\n      4.0\n      NaN\n      5.0\n      5.0\n      4.0\n      5.0\n      5.0\n      5.0\n      NaN\n      4.0\n    \n    \n      Sai Krishna Avula\n      5.0\n      3.0\n      3.0\n      4.0\n      4.0\n      5.0\n      5.0\n      3.0\n      3.0\n      4.0\n    \n    \n      Ankit Yadav\n      3.0\n      3.0\n      2.0\n      5.0\n      2.0\n      5.0\n      5.0\n      3.0\n      3.0\n      4.0"
  },
  {
    "objectID": "notebooks/posts/svm-soft-margin.html",
    "href": "notebooks/posts/svm-soft-margin.html",
    "title": "SVM Soft Margin",
    "section": "",
    "text": "import numpy as np\nimport pandas as pd\nimport matplotlib.pyplot as plt\nfrom matplotlib import cm\n%matplotlib inline\n\n\nfrom sklearn.datasets import make_blobs\n\n\nX, y = make_blobs(centers=2, n_samples=100, random_state=0, cluster_std=1.5)\n\n\nplt.scatter(X[:, 0], X[:, 1], c=y, cmap=cm.autumn)\nplt.gca().set_aspect('equal')\n\n\n\n\n\nfrom sklearn import svm\nX_train = X\ny_train = y\nkernel = 'linear'\nfor fig_num, C in enumerate([0.0001, 0.001, 0.1, 1, 100, 10000, 10e6, 10e10][:]):\n    clf = svm.SVC(kernel=kernel,C = C )\n    clf.fit(X, y)\n\n    plt.figure(fig_num)\n    plt.clf()\n    plt.scatter(X[:, 0], X[:, 1], c=y, zorder=10, cmap=plt.cm.autumn,\n                edgecolor='k',s=80)\n\n\n    plt.axis('tight')\n    x_min = X[:, 0].min()-1\n    x_max = X[:, 0].max()+1\n    y_min = X[:, 1].min()-1\n    y_max = X[:, 1].max()+1\n\n    XX, YY = np.mgrid[x_min:x_max:200j, y_min:y_max:200j]\n    Z = clf.decision_function(np.c_[XX.ravel(), YY.ravel()])\n   \n    # Put the result into a color plot\n    Z = Z.reshape(XX.shape)\n    #plt.pcolormesh(XX, YY, Z > 0, cmap=plt.cm.autumn, alpha=0.2)\n\n    plt.contour(XX, YY, Z, colors=['k', 'k', 'k'],\n                linestyles=['--', '-', '--'], levels=[-1, 0, 1])\n    plt.scatter(clf.support_vectors_[:, 0],\n                clf.support_vectors_[:, 1],\n                s=5, lw=0.001, facecolors='none',zorder=10,c='k', edgecolors='none');\n\n\n    plt.title(\"Linear Kernel with C= {}\\n Number of support vectors = {}\".format(C, len(clf.support_vectors_)))"
  },
  {
    "objectID": "notebooks/posts/svm-rbf-gamma.html",
    "href": "notebooks/posts/svm-rbf-gamma.html",
    "title": "SVM with RBF kernel Gamma Factor",
    "section": "",
    "text": "import numpy as np\nimport pandas as pd\nimport matplotlib.pyplot as plt\nfrom matplotlib import cm\n%matplotlib inline\n\n\nX = np.array([\n    [0, 0],\n    [-1, 0],\n    [1, 0],\n    [0, 1],\n    [0, -1],\n    [-2, 0],\n    [2, 0],\n    [0, -2],\n    [0, 2]\n])\ny = np.array([1, 1, 1, 1, 1, -1, -1, -1, -1])\n\n\nplt.scatter(X[:, 0], X[:, 1], c=y, cmap=cm.Paired)\nplt.gca().set_aspect('equal')\n\n\n\n\n\nimport pandas as pd\n\ndf = pd.DataFrame(X, columns=['x1', 'x2'])\ndf['y'] = y\ndf\n\n\n\n\n\n  \n    \n      \n      x1\n      x2\n      y\n    \n  \n  \n    \n      0\n      0\n      0\n      1\n    \n    \n      1\n      -1\n      0\n      1\n    \n    \n      2\n      1\n      0\n      1\n    \n    \n      3\n      0\n      1\n      1\n    \n    \n      4\n      0\n      -1\n      1\n    \n    \n      5\n      -2\n      0\n      -1\n    \n    \n      6\n      2\n      0\n      -1\n    \n    \n      7\n      0\n      -2\n      -1\n    \n    \n      8\n      0\n      2\n      -1\n    \n  \n\n\n\n\n\nfrom sklearn.metrics.pairwise import rbf_kernel\nimport seaborn as sns\n\ngamma = 0.1  # parameter for RBF kernel\nK = rbf_kernel(X, gamma=gamma)\nsns.heatmap(K, annot=True, cmap=cm.viridis)\n\n<AxesSubplot:>\n\n\n\n\n\n\ngammas = [0.01, 0.1, 1]\nfig, axes = plt.subplots(1, 3, figsize=(16, 4))\nfor ax, gamma in zip(axes.ravel(), gammas):\n    K = rbf_kernel(X, gamma=gamma)\n    # Annotate to 1 decimal digit and use min = 0.0 and max =1.0\n    sns.heatmap(K, annot=True, cmap=cm.viridis, ax=ax, fmt='.1f', vmin=0.0, vmax=1.0)\n    ax.set_title('gamma = {}'.format(gamma))\n\n\n\n\n\n# Compare with the linear kernel\nfrom sklearn.metrics.pairwise import linear_kernel, polynomial_kernel\n\nK = linear_kernel(X)\nsns.heatmap(K, annot=True, cmap=cm.viridis, fmt='.1f')\n\n<AxesSubplot:>\n\n\n\n\n\n\n# Compare with the polynomial kernel\nK = polynomial_kernel(X, degree=2)\nsns.heatmap(K, annot=True, cmap=cm.viridis, fmt='.1f')\n\n<AxesSubplot:>"
  },
  {
    "objectID": "notebooks/posts/split.html",
    "href": "notebooks/posts/split.html",
    "title": "Dataset splitting for machine learning",
    "section": "",
    "text": "import numpy as np\nimport matplotlib.pyplot as plt\nimport pandas as pd\n\n%matplotlib inline\n%config InlineBackend.figure_format='retina'\n\n\n# Create a dataset with 3 features and 1000 samples for a classification problem\n\ndf = pd.DataFrame(np.random.randn(1000, 3), columns=['A', 'B', 'C'])\ndf['D'] = np.random.randint(0, 2, 1000)\n\ndf\n\n\n\n\n\n  \n    \n      \n      A\n      B\n      C\n      D\n    \n  \n  \n    \n      0\n      0.112981\n      -0.033889\n      0.348708\n      1\n    \n    \n      1\n      1.821601\n      1.267423\n      0.274915\n      1\n    \n    \n      2\n      0.148040\n      -1.412712\n      -0.271345\n      1\n    \n    \n      3\n      0.004766\n      -1.209944\n      0.122512\n      1\n    \n    \n      4\n      0.854442\n      -0.559497\n      -0.605376\n      1\n    \n    \n      ...\n      ...\n      ...\n      ...\n      ...\n    \n    \n      995\n      0.161444\n      -0.969567\n      -2.079664\n      0\n    \n    \n      996\n      1.615938\n      0.219218\n      -0.322223\n      0\n    \n    \n      997\n      0.501970\n      -0.874313\n      1.571102\n      1\n    \n    \n      998\n      0.386063\n      -1.481215\n      -1.974313\n      1\n    \n    \n      999\n      0.468528\n      1.060850\n      0.612252\n      1\n    \n  \n\n1000 rows × 4 columns\n\n\n\n\nX, y = df[['A', 'B', 'C']], df['D']\n\n\ntrain_X, test_X = X[:800], X[800:]\ntrain_y, test_y = y[:800], y[800:]\n\n\nfrom sklearn.tree import DecisionTreeClassifier\n\n\ndt = DecisionTreeClassifier(max_depth=2)\ndt.fit(train_X, train_y)\n\nDecisionTreeClassifier(max_depth=2)In a Jupyter environment, please rerun this cell to show the HTML representation or trust the notebook. On GitHub, the HTML representation is unable to render, please try loading this page with nbviewer.org.DecisionTreeClassifierDecisionTreeClassifier(max_depth=2)\n\n\n\nfrom sklearn import tree\ntree.plot_tree(dt)\n\n[Text(0.5, 0.8333333333333334, 'X[0] <= -0.17\\ngini = 0.5\\nsamples = 800\\nvalue = [400, 400]'),\n Text(0.25, 0.5, 'X[0] <= -0.307\\ngini = 0.495\\nsamples = 348\\nvalue = [157, 191]'),\n Text(0.125, 0.16666666666666666, 'gini = 0.499\\nsamples = 316\\nvalue = [153, 163]'),\n Text(0.375, 0.16666666666666666, 'gini = 0.219\\nsamples = 32\\nvalue = [4, 28]'),\n Text(0.75, 0.5, 'X[2] <= 1.656\\ngini = 0.497\\nsamples = 452\\nvalue = [243, 209]'),\n Text(0.625, 0.16666666666666666, 'gini = 0.495\\nsamples = 434\\nvalue = [239, 195]'),\n Text(0.875, 0.16666666666666666, 'gini = 0.346\\nsamples = 18\\nvalue = [4, 14]')]\n\n\n\n\n\n\ny_hat = dt.predict(test_X)\npd.DataFrame({\"y_true\": test_y, \"y_hat\": y_hat})\n\n\n\n\n\n  \n    \n      \n      y_true\n      y_hat\n    \n  \n  \n    \n      800\n      0\n      1\n    \n    \n      801\n      0\n      0\n    \n    \n      802\n      1\n      1\n    \n    \n      803\n      1\n      1\n    \n    \n      804\n      0\n      1\n    \n    \n      ...\n      ...\n      ...\n    \n    \n      995\n      0\n      1\n    \n    \n      996\n      0\n      0\n    \n    \n      997\n      1\n      0\n    \n    \n      998\n      1\n      1\n    \n    \n      999\n      1\n      1\n    \n  \n\n200 rows × 2 columns\n\n\n\n\nfrom sklearn.tree import DecisionTreeClassifier\n\ntrain_scores = {}\ntest_scores = {}\n\nfor i in range(1, 20):\n    dt = DecisionTreeClassifier(max_depth=i)\n    dt.fit(train_X, train_y)\n    train_scores[i] = dt.score(train_X, train_y)\n    \n    test_scores[i] = dt.score(test_X, test_y)\n\n\nscores_df = pd.DataFrame({'train': train_scores, 'test': test_scores})\nscores_df.plot()\n\n<AxesSubplot:>"
  },
  {
    "objectID": "notebooks/posts/hyperparameter-1.html",
    "href": "notebooks/posts/hyperparameter-1.html",
    "title": "Grid Search",
    "section": "",
    "text": "Hyperparameter Tuning\n\nimport pandas as pd\nimport numpy as np\nfrom sklearn.tree import DecisionTreeClassifier\n\n\n\nDataset creation\n\n# Create a DataFrame for classification containing four real features and one binary target\n\ndf = pd.DataFrame({\n    'feature1': np.random.randint(0, 100, 100),\n    'feature2': np.random.randint(0, 100, 100),\n    'feature3': np.random.randint(0, 100, 100),\n    'feature4': np.random.randint(0, 100, 100),\n    'target': np.random.randint(0, 2, 100)\n})\n\n\ndf.head()\n\n\n\n\n\n  \n    \n      \n      feature1\n      feature2\n      feature3\n      feature4\n      target\n    \n  \n  \n    \n      0\n      29\n      14\n      66\n      83\n      1\n    \n    \n      1\n      68\n      70\n      87\n      72\n      1\n    \n    \n      2\n      42\n      5\n      40\n      67\n      1\n    \n    \n      3\n      2\n      54\n      79\n      0\n      1\n    \n    \n      4\n      81\n      36\n      35\n      75\n      0\n    \n  \n\n\n\n\n\ntrain_df = df[:50]\nvalidation_df = df[50:80]\n\n\ndt = DecisionTreeClassifier()\ndt.fit(train_df[['feature1', 'feature2', 'feature3', 'feature4']], train_df['target'])\ndt\n\nDecisionTreeClassifier()In a Jupyter environment, please rerun this cell to show the HTML representation or trust the notebook. On GitHub, the HTML representation is unable to render, please try loading this page with nbviewer.org.DecisionTreeClassifierDecisionTreeClassifier()\n\n\n\ndt.score(validation_df[['feature1', 'feature2', 'feature3', 'feature4']], validation_df['target'])\n\n0.5333333333333333\n\n\n\ndt = DecisionTreeClassifier(criterion='entropy', max_depth=2)\ndt.fit(train_df[['feature1', 'feature2', 'feature3', 'feature4']], train_df['target'])\ndt.score(validation_df[['feature1', 'feature2', 'feature3', 'feature4']], validation_df['target'])\n\n0.5666666666666667\n\n\n\nhyperparams = {'criterion': ['gini', 'entropy'],\n               'max_depth': [2, 3, 4, 5, 6, 7, 8, 9, 10],\n               'min_samples_split': [2, 3, 4, 5, 6, 7, 8, 9, 10]}\n\n\nout = {}\nfor c in hyperparams['criterion']:\n    for d in hyperparams['max_depth']:\n        for s in hyperparams['min_samples_split']:\n            dt = DecisionTreeClassifier(criterion=c, max_depth=d, min_samples_split=s)\n            dt.fit(train_df[['feature1', 'feature2', 'feature3', 'feature4']], train_df['target'])\n            out[(c, d, s)] = dt.score(validation_df[['feature1', 'feature2', 'feature3', 'feature4']], validation_df['target'])\n\n\nhp_ser = pd.Series(out)\nhp_ser.sort_values(ascending=False)\n\nentropy  10  10    0.766667\n         7   7     0.766667\n         9   8     0.766667\n         8   10    0.766667\n             9     0.766667\n                     ...   \ngini     10  5     0.500000\n         8   3     0.500000\n         7   4     0.500000\n             3     0.500000\n         5   2     0.500000\nLength: 162, dtype: float64\n\n\n\nhp_ser.idxmax()\n\n('entropy', 4, 6)\n\n\n\nbest_dt = DecisionTreeClassifier(criterion='entropy', max_depth=4, min_samples_split=6)\n\n\nbest_dt.fit(df[:80][['feature1', 'feature2', 'feature3', 'feature4']], df[:80]['target'])\n\nDecisionTreeClassifier(criterion='entropy', max_depth=4, min_samples_split=6)In a Jupyter environment, please rerun this cell to show the HTML representation or trust the notebook. On GitHub, the HTML representation is unable to render, please try loading this page with nbviewer.org.DecisionTreeClassifierDecisionTreeClassifier(criterion='entropy', max_depth=4, min_samples_split=6)\n\n\n\nbest_dt.score(df[80:][['feature1', 'feature2', 'feature3', 'feature4']], df[80:]['target'])\n\n0.45\n\n\n\n\nWithout using multiple nested loops\n\nprint(hyperparams.items(), len(hyperparams.items()))\n\ndict_items([('criterion', ['gini', 'entropy']), ('max_depth', [2, 3, 4, 5, 6, 7, 8, 9, 10]), ('min_samples_split', [2, 3, 4, 5, 6, 7, 8, 9, 10])]) 3\n\n\n\ndef print_vec(x, y, z):\n    print(f\"[{x} \\n{y} \\n{z}]\")\nprint_vec(*hyperparams.items())\n\n[('criterion', ['gini', 'entropy']) \n('max_depth', [2, 3, 4, 5, 6, 7, 8, 9, 10]) \n('min_samples_split', [2, 3, 4, 5, 6, 7, 8, 9, 10])]\n\n\n\nlist(zip(*hyperparams.items()))\n\n[('criterion', 'max_depth', 'min_samples_split'),\n (['gini', 'entropy'],\n  [2, 3, 4, 5, 6, 7, 8, 9, 10],\n  [2, 3, 4, 5, 6, 7, 8, 9, 10])]\n\n\n\nkeys, values = zip(*hyperparams.items())\n\n\nkeys\n\n('criterion', 'max_depth', 'min_samples_split')\n\n\n\nvalues\n\n(['gini', 'entropy'],\n [2, 3, 4, 5, 6, 7, 8, 9, 10],\n [2, 3, 4, 5, 6, 7, 8, 9, 10])\n\n\n\nimport itertools\nlist(itertools.product(*values))[::10]\n\n[('gini', 2, 2),\n ('gini', 3, 3),\n ('gini', 4, 4),\n ('gini', 5, 5),\n ('gini', 6, 6),\n ('gini', 7, 7),\n ('gini', 8, 8),\n ('gini', 9, 9),\n ('gini', 10, 10),\n ('entropy', 3, 2),\n ('entropy', 4, 3),\n ('entropy', 5, 4),\n ('entropy', 6, 5),\n ('entropy', 7, 6),\n ('entropy', 8, 7),\n ('entropy', 9, 8),\n ('entropy', 10, 9)]\n\n\n\nv = next(itertools.product(*values))\nprint(v)\n\n('gini', 2, 2)\n\n\n\nprint_vec(*zip(keys, v))\n\n[('criterion', 'gini') \n('max_depth', 2) \n('min_samples_split', 2)]\n\n\n\ndef print_dict(**kwargs):\n    print(kwargs)\n\nprint_dict(**(dict(zip(keys, v))))\n\n{'criterion': 'gini', 'max_depth': 2, 'min_samples_split': 2}\n\n\n\nout = {}\nfor v in itertools.product(*values):\n    params = dict(zip(keys, v))\n    dt= DecisionTreeClassifier(**params)\n    dt.fit(train_df[['feature1', 'feature2', 'feature3', 'feature4']], train_df['target'])\n    out[(params['criterion'], params['max_depth'], params['min_samples_split'])] = dt.score(validation_df[['feature1', 'feature2', 'feature3', 'feature4']], validation_df['target'])\n    \n\n\npd.Series(out).sort_values(ascending=False)\n\nentropy  10  10    0.766667\n         7   7     0.766667\n         9   8     0.766667\n         8   10    0.766667\n             9     0.766667\n                     ...   \n         3   3     0.500000\n             4     0.500000\n             5     0.500000\ngini     10  5     0.500000\n             3     0.500000\nLength: 162, dtype: float64"
  },
  {
    "objectID": "notebooks/index.html",
    "href": "notebooks/index.html",
    "title": "Notebook",
    "section": "",
    "text": "Date\n\n\nTitle\n\n\nAuthor\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nApr 25, 2023\n\n\nSVM with RBF kernel\n\n\nNipun Batra\n\n\n\n\nApr 25, 2023\n\n\nSVM Soft Margin\n\n\nNipun Batra\n\n\n\n\nApr 25, 2023\n\n\nSVM with RBF kernel Gamma Factor\n\n\nNipun Batra\n\n\n\n\nApr 20, 2023\n\n\nSVM\n\n\nNipun Batra\n\n\n\n\nApr 20, 2023\n\n\nSVM Kernel\n\n\nNipun Batra\n\n\n\n\nApr 19, 2023\n\n\nKMeans initialisation\n\n\nNipun Batra\n\n\n\n\nApr 18, 2023\n\n\nNumber of clusters in K-means\n\n\nNipun Batra\n\n\n\n\nApr 18, 2023\n\n\nHierarchical Clustering\n\n\nNipun Batra\n\n\n\n\nApr 16, 2023\n\n\nCurse of Dimensionality\n\n\nNipun Batra\n\n\n\n\nApr 16, 2023\n\n\nImage Segmentation using K-Means Clustering\n\n\nNipun Batra\n\n\n\n\nApr 14, 2023\n\n\nImage Completion using Matrix Factorization\n\n\nNipun Batra\n\n\n\n\nApr 14, 2023\n\n\nMovie Recommendation using KNN and Matrix Factorization\n\n\nNipun Batra\n\n\n\n\nApr 13, 2023\n\n\nParametric v/s Non-Parametric\n\n\nNipun Batra\n\n\n\n\nApr 4, 2023\n\n\nAutodiff\n\n\nNipun Batra\n\n\n\n\nApr 4, 2023\n\n\n1d CNN\n\n\nNipun Batra\n\n\n\n\nApr 4, 2023\n\n\nKNN LSH\n\n\nNipun Batra\n\n\n\n\nApr 3, 2023\n\n\nCNN\n\n\nNipun Batra\n\n\n\n\nMar 31, 2023\n\n\nGenerating names using MLPs\n\n\nNipun Batra\n\n\n\n\nMar 1, 2023\n\n\nAutoDiff in JAX and PyTorch\n\n\nNipun Batra\n\n\n\n\nFeb 28, 2023\n\n\nLogistic Regression\n\n\nNipun Batra\n\n\n\n\nFeb 28, 2023\n\n\nNeural Network\n\n\nNipun Batra\n\n\n\n\nFeb 16, 2023\n\n\nGradient Descent\n\n\nNipun Batra\n\n\n\n\nFeb 14, 2023\n\n\nTaylor Series\n\n\nNipun Batra\n\n\n\n\nFeb 10, 2023\n\n\nConditioning and Linear Regression\n\n\nNipun Batra\n\n\n\n\nJan 31, 2023\n\n\nLinear Regression: Geometric Perspective\n\n\nNipun Batra\n\n\n\n\nJan 31, 2023\n\n\nMaths and JAX\n\n\nNipun Batra\n\n\n\n\nJan 31, 2023\n\n\nCNN Edge 2d\n\n\nNipun Batra\n\n\n\n\nJan 31, 2023\n\n\nMaths and JAX: Low Rank\n\n\nNipun Batra\n\n\n\n\nJan 17, 2023\n\n\nSome Python Utilities\n\n\nNipun Batra\n\n\n\n\nJan 17, 2023\n\n\nDataset splitting for machine learning\n\n\nNipun Batra\n\n\n\n\nJan 17, 2023\n\n\nGrid Search\n\n\nNipun Batra\n\n\n\n\nJan 12, 2023\n\n\nDT Regression\n\n\nNipun Batra\n\n\n\n\nJan 12, 2023\n\n\nPandas tips\n\n\nNipun Batra\n\n\n\n\nJan 10, 2023\n\n\nMisc tips\n\n\nNipun Batra\n\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "exams/q4.html",
    "href": "exams/q4.html",
    "title": "Quiz 4 (25 March)",
    "section": "",
    "text": "Total Time: 1 hour 15 mins AND Total Marks: 10\n\n\n\nConsider the figure above, where we fit the model \\(p(y=1 \\mid \\mathbf{x}, \\bm{{\\theta}})=\\sigma\\left(\\theta_0+\\theta_1 x_1+\\theta_2 x_2\\right)\\) by maximum likelihood, i.e., we minimize \\(J_a({\\theta})=-\\ell\\left(\\bm{{\\theta}}, \\mathcal{D}_{\\text {train }}\\right)\\) where \\(\\ell\\left(\\bm{{\\theta}}, \\mathcal{D}_{\\text {train }}\\right)\\) is the log likelihood on the training set. In the questions below, when multiple decision boundaries are possible, you should choose the one which minimizes the number of classification errors on the training dataset.\n\n\nSketch a decision boundary for the model. How many classification errors does your method make? (1 mark)\n\n\nNow, we regularize only the \\(\\theta_0\\) parameter, i.e., we minimize: \\(J_b({\\theta})=-\\ell\\left(\\bm{{\\theta}}, \\mathcal{D}_{\\text {train }}\\right)+\\lambda \\theta_0^2\\). Suppose \\(\\lambda\\) is a very large number, so we regularize \\(\\theta_0\\) all the way to 0, but all other parameters are unregularized. Sketch a possible decision boundary. How many classification errors does your method make? (1 mark)\n\n\nRepeat part (b), but we now instead regularize the \\(\\theta_1\\) parameter. (1 mark)\n\n\nRepeat part (b), but we now instead regularize the \\(\\theta_2\\) parameter. (1 mark)\n\n\nProve that softmax is equivalent to sigmoid when there are only two classes. (1 mark)\n\\(y = \\sigma(z)\\), where \\(\\sigma\\) is the sigmoid function. We also know that \\(z = f(a)\\). Find \\(\\dfrac{\\partial y}{\\partial a}\\). (1 mark)\nLet us consider a \\(K\\)-class logistic regression problem. For some example, \\(x\\), we get our outputs before the application of softmax as: \\(z_1=x^T\\theta_1\\), \\(\\cdots , z_k=x^T\\theta_k\\), \\(\\cdots ,z_K=x^T\\theta_K\\). We denote the vector of outputs as \\(\\vec{z} = \\left[\\begin{array}{@{}c@{}}  z_{1} \\\\  z_{2} \\\\  \\vdots \\\\  z_{K}  \\end{array} \\right]\\)\n\nWe will try to now use the cross entropy loss function to train our model. One of the terms in the cross entropy loss function is: \\(\\log\\left(\\frac{e^{z_k}}{\\sum_{j=1}^K e^{z_j}}\\right)\\) which we refer to as \\(\\mathrm{LOGSOFTMAX}(z_k, \\vec{z})\\). However, we find that \\(\\mathrm{LOGSOFTMAX}(z_k, \\vec{z})\\) cannot be computed directly for several cases. When \\(z_k\\) is a large number (e.g. 5000), a computer is unable to compute \\(e^{z_k}\\) as an overflow occurs (\\(e^{z_k}\\) = inf). When \\(z_k\\) is a large negative number (e.g. -5000), \\(e^{z_k}\\) = 0.0.\n\n\nWhat problem occurs in computing \\(\\mathrm{LOGSOFTMAX}(z_k, \\vec{z})\\) when all elements of \\(\\vec{z}\\) are large (in magnitude) negative numbers (e.g. all \\(z_i < -6000\\))? (1 mark)\n\n\nModify the \\(\\mathrm{LOGSOFTMAX}(z_k, \\vec{z})\\) expression using some trick so that we are able to compute it for any \\(z_k\\) and \\(\\vec{z}\\). You need to show the steps/simplifications you make. Show that this trick solves both the above problems (overflow and the problem you find in part (a) of this question) (2 marks)\n\n\n\nWe use a new type of coin for coin toss experiments. For this coin, the probability of heads goes down exponentially with the draw. Assuming the probaility of heads for the first draw (\\(i=1\\)) is \\(\\theta\\) and for the \\(i\\)th draw is \\(\\theta_i = \\dfrac{\\theta}{2^{i-1}}\\). What is the maximum likelihood estimate for \\(\\theta\\) for obtaining the draws as: T, H, H. Assume that each draw is independent of the others. Ofcourse, the identical assumption can not be made. (1 mark)"
  },
  {
    "objectID": "exams/q2.html",
    "href": "exams/q2.html",
    "title": "Quiz 2 (8 Feb)",
    "section": "",
    "text": "Total Time: 1 hour 15 mins AND Total Marks: 10\n\n\nIn bootstrap sampling, we sample with replacement from the original dataset. Let us assume that the original dataset of size \\(N\\) has all distinct elements. As an example if \\(N=8\\), we may have the dataset as \\(\\{1, 2,3, 4, 5, 6, 7, 8\\}\\). A bootstrap sample (or round) is also of size \\(N\\) and can contain some elements more than once. For example, a bootstrap sample may be \\(\\{8, 8, 3, 4, 5, 1, 8, 5\\}\\). The unique elements in this sample are: \\(\\{1, 3, 4, 5, 8\\}\\). This sample has 5 unique elements. Show that on average the number of unique elements in a bootstrap sample is \\(63.2\\%\\) of \\(N\\). [1.5 marks]\nWe studied the ADABoost classification algorithm for binary classification. We wrote the final prediction as: \\(\\mathrm{SIGN}(\\sum{\\alpha_i}h_i(x))\\) where \\(\\alpha_i\\) is the weight of the classifier \\(h_i\\) and \\(h_i(x)\\) is the prediction of the classifier \\(h_i\\) on the input \\(x\\). We also noted that each prediction \\(h_i(x)\\) is either \\(+1\\) or \\(-1\\).\nExtend ADABoost to multi-class classification where we have \\(K\\) classes and each classifier predicts one of the \\(K\\) classes (a number from \\(\\{1 \\cdots K\\}\\)). As an example, if we have \\(m=4\\) members in the ensemble, we may have something like \\(h_1(x) = 1\\), \\(h_2(x) = 2\\), \\(h_3(x) = 3\\) and \\(h_4(x) = 2\\). Now, write the formula for prediction for multi-class classification using the ensemble of classifiers, i.e. for any input \\(x\\), which class amongst \\(\\{1 \\cdots K\\}\\)) will be predicted as a function of \\(\\alpha_i\\)s and \\(h_i(x)\\)? Note: do not use the concept of one-vs-one or one-vs-all here. [2 marks]\nWhich hyperparameter can you vary to control the bias-variance tradeoff (or complexity) for decision trees? Draw the bias variance tradeoff curve for decision trees using this hyperparameter. Explain your answer. [1.5 mark]\nThe normal equation for linear regression is given as: \\(\\hat{\\theta} = (X^TX)^{-1}X^Ty\\). Instead of computing the normal equation directly, let us use the SVD decomposition of X. We decompose X as \\(X = U\\Sigma V^T\\).\n\n\nRewrite the normal equation using the reduced SVD decomposition of X, that is write \\(\\hat{\\theta}\\) in terms of \\(U\\), \\(\\Sigma\\) and \\(V\\) and \\(y\\).\n\n\nFor this question, let us assume that \\(X\\) is of size \\(n \\times m\\) and \\(y\\) is of size \\(n \\times 1\\). Let us also assume that the number of features \\(m\\) is significantly less than the number of samples \\(n\\).\n\n\nOnce you have written \\(\\hat{\\theta}\\) in terms of \\(U\\), \\(\\Sigma\\) and \\(V\\) and \\(y\\), find the time complexity of computing \\(\\hat{\\theta}\\) using the reduced form of SVD decomposition of \\(X\\). [4 marks]\n\n\nWe provide some background on the SVD decomposition of a matrix \\(X\\) below: The reduced form of SVD decomposition of \\(X\\) is given as \\(X = U\\Sigma V^T\\) where \\(U\\) is of size \\(n \\times m\\), \\(\\Sigma\\) is of size \\(m \\times m\\) and \\(V\\) is of size \\(m \\times m\\). The columns of \\(U\\) are called the left singular vectors of \\(X\\) and the columns of \\(V\\) are called the right singular vectors of \\(X\\). The singular matrix \\(\\Sigma\\) is a diagonal matrix: it has zeros everywhere except on the diagonal. The diagonal elements of \\(\\Sigma\\) are the singular values of \\(X\\). The singular values of \\(X\\) are always non-negative and are arranged in decreasing order. The singular values of \\(X\\) are also called the eigenvalues of \\(X^TX\\).\n\n\nFurther, for reduced SVD, \\(U^TU = I\\) and \\(V^TV = I\\) and \\(VV^T = I\\) where \\(I\\) is the identity matrix.\n\n\nWe also provide some background on the time complexity of matrix multiplication below: Let \\(A\\) be of size \\(n \\times m\\), \\(B\\) be of size \\(m \\times p\\) and \\(C\\) be of size \\(n \\times p\\). The time complexity of computing \\(C = AB\\) is \\(O(nmp)\\). Further, the time complexity of inverse of a \\(n \\times n\\) matrix \\(A\\) is \\(O(n^3)\\). The time complexity of computing SVD of the above \\(n \\times m\\) matrix \\(X\\) is \\(O(nm^2)\\). You should factor this time complexity in your answer for computing \\(\\hat{\\theta}\\).\n\n\nBONUS: Solve the above problem (computing \\(\\hat{\\theta}\\) and its time complexity) with the full version of SVD, what changes will you need to make? The full version of SVD is given as \\(X = U\\Sigma V^T\\) where \\(U\\) is of size \\(n \\times n\\), \\(\\Sigma\\) is of size \\(n \\times m\\) and \\(V\\) is of size \\(m \\times m\\). \\(U\\) and \\(V\\) are orthogonal matrices. [2 marks]\n\n\nLet us assume \\(K\\) members in an ensemble. For simplicity let us assume that each member in the ensemble has the same probability of error \\(p<0.5\\). We saw in the class that the probability of error (given by the binomial expansion) reduces as we increase the number of members in the ensemble. But, empirically adding more members in an ensemble may not always reduce the error. Why? [1 mark]"
  },
  {
    "objectID": "exams/q5.html",
    "href": "exams/q5.html",
    "title": "Quiz 5 (6 April)",
    "section": "",
    "text": "Total Time: 1 hour 15 mins AND Total Marks: 10\n\n\nAssume that we want to design a neural network with two layers by composing two linear layers. That is, the output of the first layer becomes the input of the second layer. Why would such a naive composition not work? Or, in other words show that without using a non-linear activation, we get a linear model. You can show this for a single datapoint \\((1 X D)\\) instead of showing this for \\(N\\) datapoints.(1 mark)\nFor this task, we are trying to use a neural network to predict a non-negative real number. However, in general, the output of a neural network is not constrained to be non-negative. Thus, we try to solve this problem by learning \\(f(\\hat{y})\\) as the output of the neural network, and we then apply \\(f^{-1}(f(\\hat{y}))\\) to finally get a \\(\\hat{y}\\) which is guaranteed to be non-negative? Can you give an example of what \\(f\\) and thus its inverse can be? Please note: you are not allowed to use ReLU activation. Further, we want our function f and its inverse to be continuous and differentiable everywhere.(1 mark)\nDraw a simple perceptron with two inputs and one output for the binary AND problem. Remember that the simple perceptron works on binary input and produces binary outputs. Show that your model works for all four inputs ((1, 1), (1, 0), (0, 0) and (0, 1))(1 mark)\nShow that the following network using ReLu activation works for the XOR problem. (1 mark; 0.25 marks for each of the four possible inputs (0,0), (0,1), (1,0), (1,1)) \nAssume we are solving the 3-class classification problem. We have two models (M1 and M2) from which we get two different output probabilities: \\(\\hat{y}_1 = (0.2, 0.7, 0.1)\\), \\(\\hat{y}_1 = (0.2, 0.5, 0.3)\\). The true class is \\(y = 0\\). Which of M1 or M2 has a higher cross-entropy losses? (1 mark)\nWe have the following code\n\nclass M_A(nn.Module):\n    def __init__(self):\n        super().__init__()\n        self.fc1 = nn.Linear(784, 64)\n        self.fc2 = nn.Linear(64, 32)\n        self.fc3 = nn.Linear(32, 10)\n        \n    def forward(self, x):\n        z1 = self.fc1(x)\n        a1 = F.relu(z1)\n        z2 = self.fc2(a1)\n        a2 = F.relu(z2)\n        z3 = self.fc3(a2) # logits\n        return z3\n\nclass M_B(nn.Module):\n    def __init__(self):\n        super().__init__()\n        self.fc1 = nn.Linear(784, 64)\n        self.fc2 = nn.Linear(64, 32)\n        self.fc3 = nn.Linear(32, 10)\n        \n    def forward(self, x):\n        z1 = self.fc1(x)\n        z2 = self.fc2(z1)\n        z3 = self.fc3(z2) \n        return z3\nBoth models have the same number of parameters despite some differences. Explain? (1 mark)\n\nLet us learn a model to predict the next character given a context of k previous characters. We have a total v characters in our vocabulary (e.g., a, b, …, z, _) Let us use an embedding size of e, i.e. each character in our vocabulary is represented as e length vector. Now, let us use a simple MLP with one hidden layer with h hidden units. What is the total number of parameters in this model? (1 mark)\nAssume the above setup in Q7. We observe that our embedding has “overfitted”, i.e. the embedding vectors are very far from the origin. Can you suggest an additional loss term that can help us to bring the embeddings closer to the origin and thus act as a regularisation? (1 mark)\nAs discussed in the lecture, chatGPT like systems are similar to the above model. But, we know that chatGPT can produce many different outputs for the same input. Let us use a simplification and consider next character prediction problem. Our model outputs a probability distribution over the next character. However, if we just pick up the most probable class/character, we should always get the same output given the same input. But, how do chatGPT like systems generate different outputs? (1 mark)\nAssume a MLP input of 4 dimensions, 2 real outputs, first hidden layers of 3 units, second hidden layer of 2 units, and a final output layer of 2 units. What is the total number of parameters in this model? (1 mark)"
  },
  {
    "objectID": "exams/prereq.html",
    "href": "exams/prereq.html",
    "title": "Prerequsite test",
    "section": "",
    "text": "Instructions\n\nThis test is open book, open internet, open notes. You can use any resources you want to solve the problems.\nYou should be typing your answers in a Jupyter notebook.\nThe submission would be a link to a public GitHub repository containing the notebook. Fill this form to submit your solution.\nA random subset of students may have a viva post the exam. The viva would be based on the notebook and the solutions you have provided.\nThe test is open till 6th January 2022 9 PM. You can submit your solutions anytime before that.\nThis problem has to be solved individually. You cannot collaborate with anyone else.\nThe code should be written using Python.\nSome questions may require you to answer in text. You can use markdown cells to write your answers. Some questions may require you to write code. You can use code cells to write your code. Some questions may require you to write mathematical expressions. You can use LaTeX to write your expressions. You can write such LaTeX expressions in markdown cells.\nFor any other questions, please ask on the General channel on Slack.\n\n\n\n\nQuestions\n\nHow many multiplications and additions do you need to perform a matrix multiplication between a (n, k) and (k, m) matrix? Explain.\nWrite Python code to multiply the above two matrices. Solve using list of lists and then use numpy. Compare the timing of both solutions. Which one is faster? Why?\nFinding the highest element in a list requires one pass of the array. Finding the second highest element requires 2 passes of the the array. Using this method, what is the time complexity of finding the median of the array? Can you suggest a better method? Can you implement both these methods in Python and compare against numpy.median routine in terms of time?\nWhat is the gradient of the following function with respect to x and y? \\[\nx^2y+y^3\\sin(x)\n\\]\nUse JAX to confirm the gradient evaluated by your method matches the analytical solution corresponding to a few random values of x and y\nUse sympy to confirm that you obtain the same gradient analytically.\nCreate a Python nested dictionary to represent hierarchical information. We want to store record of students and their marks. Something like:\n\n2022\n\nBranch 1\n\nRoll Number: 1, Name: N, Marks:\n\nMaths: 100, English: 70 …\n\n\nBranch 2\n\n2023\n\nBranch 1\nBranch 2\n\n2024\n\nBranch 1\nBranch 2\n\n2025\n\nBranch 1\nBranch 2\n\n\nStore the same information using Python classes. We have an overall database which is a list of year objects. Each year contains a list of branches. Each branch contains a list of students. Each student has some properties like name, roll number and has marks in some subjects.\nUsing matplotlib plot the following functions on the domain: x = 0.5 to 100.0 in steps of 0.5.\n\n\\(y = x\\)\n\\(y = x^2\\)\n\\(y = \\frac{x^3}{100}\\)\n\\(y = \\sin(x)\\)\n\\(y = \\frac{\\sin(x)}{x}\\)\n\\(y = \\log(x)\\)\n\\(y = e^x\\)\n\nUsing numpy generate a matrix of size 20X5 containing random numbers drawn uniformly from the range of 1 to 2. Using Pandas create a dataframe out of this matrix. Name the columns of the dataframe as “a”, “b”, “c”, “d”, “e”. Find the column with the highest standard deviation. Find the row with the lowest mean.\nAdd a new column to the dataframe called “f” which is the sum of the columns “a”, “b”, “c”, “d”, “e”. Create another column called “g”. The value in the column “g” should be “LT8” if the value in the column “f” is less than 8 and “GT8” otherwise. Find the number of rows in the dataframe where the value in the column “g” is “LT8”. Find the standard deviation of the column “f” for the rows where the value in the column “g” is “LT8” and “GT8” respectively.\nWrite a small piece of code to explain broadcasting in numpy.\nWrite a function to compute the argmin of a numpy array. The function should take a numpy array as input and return the index of the minimum element. You can use the np.argmin function to verify your solution."
  },
  {
    "objectID": "exams/q3.html",
    "href": "exams/q3.html",
    "title": "Quiz 3 (27 Feb)",
    "section": "",
    "text": "Total Time: 1 hour 15 mins AND Total Marks: 10\n\n\nMany evaluation metrics decompose over the training examples. For example, the loss function for linear regression (proportional to mean squared error) is given as: \\[L(\\theta) = \\frac{1}{2N}\\sum_{i=1}^N (y_i - \\sum_{d=1}^D \\theta_d x_i^d)^2\\] where \\(N\\) is the number of training examples, \\(x_i\\) is the \\(i^{th}\\) training example and \\(y_i\\) is the corresponding label. Mention any evaluation metric/loss function in machine learning that does not decompose over the training examples. [1 mark]\nWe saw the figure showing SGD convergence. \n\n\n2A) Prove that SGD is an unbiased estimator. [1 mark]\n2B) It seems that the SGD algorithm is not converging to the global minimum. Why do you think this is the case? [1 mark]\n2C). Why is it generally a good idea to use a small learning rate for SGD? [1 mark]\n2D) It seems that while the SGD algorithm is not converging, but it seems to be very quickly moving close to the global minimum. Why is SGD good initially when the loss is high? To help you answer this question, we pose a series of questions. Consider a simplification of linear regression. Our data is 1d. Our model is \\(y=\\theta x\\). Consider a dataset of \\(N\\) examples. Obtain the closed form solution for \\(\\theta\\) in terms of the scalars \\(x_i\\) and \\(y_i\\) for \\(i=1, \\cdots, N\\). [1 marks]\n2E) Consider \\(N=3\\) and a datset of the form \\(x_1=1, x_2=2, x_3=3, y_1=1, y_2=2.2, y_3=2.8\\). Plot the approximate contour plot of the loss function \\(L(\\theta)\\) for \\(\\theta \\in [-1, 3]\\). [1 marks].\n2F) Plot the loss v/s parameters (\\(\\theta\\)) corresponding to the loss for each training input. [1 marks]\n2G) Now, answer why SGD works initially, when the loss is high. [1 marks]\n\n\nIn an above question, we proved that the SGD estimator is an unbiased estimator. We have also previously discussed that we typically have a bias-variance tradeoff in our models. In the recent assignment question, we have plotted the bias and variance for different complexity trees. In this question, you have to derive the mean squared error in terms of three terms: bias, variance and irreducible noise.\n\n\nLet us assume our data is generated from a `true’ function \\(f(x)\\) and we have some additional zero mean normally distributed noise \\(\\epsilon \\sim \\mathcal{N}(0, \\sigma^2)\\).\n\\[y = f(x) + \\epsilon\\]\nWe can use some model such as a decision tree or linear regression to approximate \\(f(x)\\). We now consider a single training example \\((x_0, y_0)\\). We can define the mean squared error as:\n\\[MSE = \\mathbb{E}[(y_0 - \\hat{f}(x_0)^2)]\\]\nwhere \\(y\\) is the true label and \\(\\hat{f}(x_0)\\) is the predicted label. The expectation is over all possible training sets that could have been generated.\nTo keep the notation simple, we refer \\(f(x_0)\\) as \\(f\\) and \\(\\hat{f}(x_0)\\) as \\(\\hat{f}\\). Thus, we can write \\[MSE = \\mathbb{E}[(f - \\hat{f})^2]\\] We also define the bias as the difference between the true function and the predicted function, evaluated at the training example: \\[bias = \\mathbb{E}[\\hat{f}] - f\\] or, \\[bias = \\overline{f} - f\\] where \\(\\overline{f}\\) is the average/expectation of the predicted function over all possible training sets.\nWe define the variance as: \\[variance = VAR(\\hat{f})\\] or,\n\\[variance = \\mathbb{E}[(\\hat{f} - \\overline{f})^2]\\]\nWe define irreducible noise as the variance of the noise term \\(\\epsilon\\):\n\\[irreducible = VAR(\\epsilon)\\] or,\n\\[irreducible = \\sigma^2\\]\nUsing the above definitions, show that the mean squared error can be written as:\n\\[MSE = bias^2 + variance + irreducible\\]\n[2 marks]"
  },
  {
    "objectID": "exams/assignment-5.html",
    "href": "exams/assignment-5.html",
    "title": "Assignment 5",
    "section": "",
    "text": "General instructions\n\nFeel free to use any framework of your choice: PyTorch, JAX (+Flax/Equinox), Tensorflow (+Keras)\nWe are not providing any code template. However, it is recommended you adhere to high code quality standards.\nFeel free to make use of ChatGPT, CoPilot, etc. like tools. Cite where you used them. However, you should still be able to explain your code during the viva. Also, you need to be careful with the hallucinations of these tools!\nAs before, this assignment is in a group of two students. You do not need to submit the assignment but can show your private repo to the TA during the viva.\n\n\n\nIn this question, you have to compare the performance on a binary classification task of the following models:\n\nVGG (1 block)\nVGG (3 blocks)\nVGG (3 blocks) with data augmentation\nTransfer learning using VGG16 or VGG19\n\nRefer this article You do not need to write your own code. You can reuse the code from the post. Or, you could roll out your own implemenation. Either way, you should be able to explain your code during the viva.\nYou need to create the dataset on your own based on your first names. For instance if the first name of the team members are: Siya and Raghav, they can choose a dataset of their liking based on any names, place, animal or thing. As examples:\n\nSeoul v/s Riyadh\nSnake v/s Rat\nSquirrel v/s Rabbit\nSambhar v/s Roti\n\nYou can refer to resource 1 or resource 2 or plainly download 100 images of both classes (total 200 images). Of these 100 images of each class, we will use 80 for training and 20 for testing. You get 1 mark for dataset creation [1 mark]\nCreate a table with models as rows and the following columns [2 marks (0.5 marks for each model)]\n\nTraining time\nTraining loss\nTraining accuracy\nTesting accuracy\nNumber of model parameters\n\nWe will now be using Tensorboard for visualizing network performance. You are suggested to refer to:\n\nPyTorch + Tensorboard\nTensorflow + Tensorboard\n\nUse Tensorboard to log the following and present screenshots/images [1 mark]\nScalars\n\nTraining loss v/s iterations (and not epochs)\nTraining accuracy v/s iterations (and not epochs)\nTesting accuracy v/s iterations (and not epochs)\n\nImages\n\nShow all images from the test set and their predictions\n\nNow you have to present various insights. For instance, you should discuss the following: [2 marks (0.5 marks for each question)]\n\nAre the results as expected? Why or why not?\nDoes data augmentation help? Why or why not?\nDoes it matter how many epochs you fine tune the model? Why or why not?\nAre there any particular images that the model is confused about? Why or why not?\n\nNow, create a MLP model with comparable number of parameters as VGG16 and compare your performance with the other models in the table. You can choose the distribution of number of neurons and number of layers. What can you conclude? [1 mark]"
  },
  {
    "objectID": "exams/q1.html",
    "href": "exams/q1.html",
    "title": "Quiz 1 (18 Jan)",
    "section": "",
    "text": "Instructions\n\nTotal Time: 30 mins\n\n\n\nRemember the entropy discussion we had in the lecture. We saw that for the Tennis example, the maximum entropy is 1.0. What is the maximum entropy an Imagenet classification problem, where we have 1024 classes? [1 mark]\nGiven the following dataset, what attribute/feature would the decision tree algorithm choose to split the data on for the first iteration? Why? [1 mark]\n\n\n\n\n\n\n\n\n\n\n\nSample #\nTomato radius\nTomato weight\nTomato color\nTomato quality\n\n\n\n\n1\n1\n1\n1\nGood\n\n\n2\n1\n1\n2\nGood\n\n\n3\n1\n2\n1\nBad\n\n\n4\n1\n2\n2\nBad\n\n\n5\n2\n1\n1\nGood\n\n\n6\n2\n2\n2\nGood\n\n\n\n\nIn the lectures we saw that np.std(x) and pd.Series(x).std() are different. Why? [1 mark]\nQuoting Wikipedia:\n\n\nPruning is a data compression technique in machine learning and search algorithms that reduces the size of decision trees by removing sections of the tree that are non-critical and redundant to classify instances. Pruning reduces the complexity of the final classifier, and hence improves predictive accuracy by the reduction of overfitting.\n\n\nPre-pruning procedures prevent a complete induction of the training set by replacing a stop () criterion in the induction algorithm (e.g. max. Tree depth or information gain (Attr)> minGain). Pre-pruning methods are do not induce an entire set, but rather trees remain small from the start.\n\nCreate a decision tree for the following classification problem. Explain why the pre-pruning using information gain approach can be limiting? [2 marks]\n\n\n\n\\(x_1\\)\n\\(x_2\\)\n\\(y\\)\n\n\n\n\n0\n0\n0\n\n\n0\n1\n1\n\n\n1\n0\n1\n\n\n1\n1\n0\n\n\n\n\nVisualize the decision tree for the following regression problem, where the ground truth is the function \\(y = x + 2\\). Use \\(x = \\{1, 2, \\cdots 4\\}\\) as the training dataset. Also visualize the learnt function [2 marks]\nCreate an example ground truth and prediction where the mean absolute error is 100 and mean error is 0. [0.5 marks]\nCreate one confusion matrix for 100 total examples where the precision is 0.8, recall is 0.5. [1 mark]\nShow visualisation of 1d regression problem for continuous inputs showing a good fit, a high bias and a high variance fit. [1.5 mark]"
  },
  {
    "objectID": "grading.html",
    "href": "grading.html",
    "title": "Grading Policy",
    "section": "",
    "text": "Quizzes: 60%\n\n10% each\nBest 6 out of 8\n\n\n\n\nAssignments: 40%\n\nVariable weight (e.g. some assignments would be 5%, some 10%, etc.)\nSome assignments would involve:\n\nMaking pull requests to public repositories\nWriting Hugging Face Spaces like demos\n\n\n\n\n\nBonus: up to 6%\n\nMaking a non-trivial pull request to a well-starred public repo (4%)\nGetting the PR accepted (2%)"
  },
  {
    "objectID": "schedule.html",
    "href": "schedule.html",
    "title": "Schedule",
    "section": "",
    "text": "Lecture #\nDate\nTopic\n\n\n\n\n1\n3 Jan\nIntroduction and Logistics [Slides]\n\n\nNone\n4 Jan\nPre-requisites quiz released\n\n\n2\n5 Jan\nConvention, Metrics, Classification, Regression [Slides]\n\n\n3\n10 Jan\nDecision Trees - 1[Slides][Notebook]\n\n\n4\n12 Jan\nDecision Trees - 2[Slides][Notebook]\n\n\n5\n17 Jan\nBias and Variance[Slides][Notebook on Python utils][Notebook on Grid Search]\n\n\nNone\n18 Jan\nQuiz 1\n\n\n6\n19 Jan\nBias, Variance 2, Cross Validation[Slides]\n\n\n7\n24 Jan\nEnsemble Methods[Slides]\n\n\n8\n31 Jan\nEnsemble Methods[Slides], Weighted samples in decision trees[Slides], Maths for ML-1 [Slides] [Notebook-1] [Notebook 2], [Streamlit app] Linear Regression [Slides]\n\n\n9\n2 Feb\nLinear Regression [Slides], Contour Plots [Slides], Geometric View of Linear Regression [Slides]\n\n\n10\n9 Feb\nLinear Regression II [Slides]\n\n\n11\n14 Feb\nGradient Descent [Slides], Taylor’s Series, Notebook on Taylor’s series, Reference on relationship between Taylor’s series and GD, Reference 2\n\n\n12\n16 Feb\nGradient Descent [Slides] Notebook\n\n\n13\n21 Feb\nGradient Descent continued, [Ridge Regression], [Streamlit demo], [Additional reading on SGD being an unbiased estimator]\n\n\n14\n23 Feb\nRidge regression, LASSO, [Interactive article on Optimization algorithms]\n\n\n15\n28 Feb\nLogistic regression [Slides], [Notebook] (best run locally to render interactive visualisations)\n\n\n16\n2 Mar\nLogistic regression [Slides]\n\n\n17\n14 Mar\nLogistic regression [Slides]\n\n\n18\n16 Mar\nMLP [Slides]\n\n\n19\n21 Mar\nMLP [Slides], Notebook\n\n\n20\n28 Mar\nMLP [Slides]\n\n\n21\n30 Mar\nNext work prediction [Slides], Notebook\n\n\n22\n4 Apr\nConvolutional Neural Networks [Slides], 1d CNN slides, Notebook 1, Notebook 2, Notebook 3, Equivariance v/s Invariance, Reference1, Reference2, Notebook\n\n\n23\n6 Apr\nAutograd [Slides], Notebook on Autodiff, Reference on chain rule Naive Bayes [Slides]\n\n\n24\n11 Apr\nNaive Bayes [Slides], KNN [Slides]\n\n\n25\n13 Apr\nKNN, Parametric v/s Non-Parametric, Movie Recommendation\n\n\n26\n18 Apr\nCurse of Dimensionality, Segment Anything demo, Unsupervised learning, Image segmentation, Image completion, KMeans Viz 1, Viz 2, PCA reference\n\n\n27\n20 Apr\nConstrained Optimization (self study), Support Vector Machines -1\n\n\n28\n23 Apr\nSupport Vector Machines\n\n\n29\n25 Apr\nSupport Vector Machines (Soft Margin)"
  },
  {
    "objectID": "faq.html",
    "href": "faq.html",
    "title": "FAQ",
    "section": "",
    "text": "Prerequisites\n\nWhat are the course prerequisites?\n\nThe course has no “formal” prerequisites like all courses at IITGn. However, it is assumed that you have a basic understanding of:\n\nprogramming (Python), and data structures (ES242 equivalent)\nprobability and statistics\nlinear algebra\ncalculus\n\n\nHow can I prepare for the prerequisite exam?\n\nYour UG course material should be sufficient to prepare for the exam.\nYou may additionally refer to the “prerequisite” reading section on the course homepage.\n\nWhat happens if I do not clear the prerequisite exam?\n\nYou will not be allowed to take the course.\n\nWhat do you mean by “clear” the exam?\n\nLike all courses at IITGn, the instructor will decide the cut-off for the exam. You will have to score above the cut-off to clear the exam. No cut-off will be revealed to the students apriori.\n\n\n\n\n\nQuizzes\n\nWhat happens if I miss a quiz due to any reason?\n\nThe quiz will be marked as 0.\nThe provision of best 6 out of 8 quizzes is designed keeping in mind such scenarios.\n\nWill the quizzes and end-semester exam be open book? Will I be allowed to carry notes?\n\nNo, the exams and quizzes will be closed book. You are not permitted to carry notes.\n\nHow soon can I expect to receive my answer sheets back?\n\nYou should expect to receive answer sheets back in 4-5 working days.\n\nIs there an end-semester exam or mid-semester exam?\n\nNo, there is no end-semester exam or mid-semester exam. However, some of the quizzes may be held in the exam slot. In total we will have 8 equal weightage quizzes. The best 6 out of them will be considered for the final grade.\n\nWill the quizzes be MCQs or subjective?\n\nThe quizzes may contain both the MCQs and subjective questions.\n\n\n\n\n\nAssignments\n\nWhat happens if I miss an assignment due to any reason?\n\nThere will no extensions for assignments.\n\nI have a doubt in the assignment. Whom should I write to?\n\nAsk on the slack General channel. If you don’t get a response within 2 days, write to the course instructor.\n\nI do not know Python. Can I code assignments in some other language?\n\nUnfortunately, no. You have to stick to Python.\n\nHow will you evaluate the assignment?\n\nThe assignments would be followed by a viva. The TAs would first check the code and compare against the submission. Any change from the submitted code is not allowed and any instance of the same would culminate in a warning. The TAs would run the code and ask a few questions. About 75% of these questions would be based on the assignment in question and about 25% would be based on the theory behind the concepts covered in the assignment.\nThe grade breakup would be: i) code runs correctly and solves the problem [50% marks]; ii) questions based on the assignment and student understanding of code [25% marks]; iii) code quality [12.5% marks]; iv) questions based on the theory behind the concepts covered in the assignments [12.5% marks]\n\nIs the assignment individual or group?\n\nThe assignment is TBA. In case of group, all team members get the same grade for the assignment.\n\n\n\n\n\nAttendance\n\nAttendance policy\n\nAttendance is not mandatory, but highly encouraged. Marks often correlated with attendance.\n\n\n\n\n\nProjects\n\nIs there a project component in the course?\n\nNo. There is no project component in the course.\n\n\n\n\n\nBonus\n\nCan I choose a PR of my choice.\n\nYes, you can choose a PR of your choice from a list of PRs decided by the teaching staff. The teaching staff hold the right to decide whether a PR is suitable or not."
  },
  {
    "objectID": "quizzes.html",
    "href": "quizzes.html",
    "title": "Quizzes",
    "section": "",
    "text": "Order By\n       Default\n         \n          Date - Oldest\n        \n         \n          Date - Newest\n        \n         \n          Title\n        \n         \n          Author\n        \n     \n  \n    \n      \n      \n    \n\n\n\n\n\n\nDate\n\n\nTitle\n\n\nAuthor\n\n\n\n\n\n\nJan 5, 2023\n\n\nPrerequsite test\n\n\n\n\n\n\nJan 18, 2023\n\n\nQuiz 1 (18 Jan)\n\n\n\n\n\n\nFeb 8, 2023\n\n\nQuiz 2 (8 Feb)\n\n\n\n\n\n\nFeb 27, 2023\n\n\nQuiz 3 (27 Feb)\n\n\n\n\n\n\nMar 25, 2023\n\n\nQuiz 4 (25 March)\n\n\n\n\n\n\nMar 26, 2023\n\n\nAssignment 5\n\n\n\n\n\n\nApr 6, 2023\n\n\nQuiz 5 (6 April)\n\n\n\n\n\n\n\n\nNo matching items"
  }
]